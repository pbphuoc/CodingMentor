!SESSION 2022-09-28 14:38:40.165 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_AU
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2022-09-28 14:39:12.176
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-09-28 14:39:12.176
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-09-28 14:39:12.176
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-09-28 14:39:22.537
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\ffpbp'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.core.jobs 4 2 2022-09-28 14:39:39.519
!MESSAGE An internal error occurred during: "https://www.eclipse.org/setups/setups.zip".
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.osgi.framework.BundleContext.createFilter(String)" because "context" is null
	at org.osgi.util.tracker.ServiceTracker.<init>(ServiceTracker.java:187)
	at org.osgi.util.tracker.ServiceTracker.<init>(ServiceTracker.java:250)
	at org.eclipse.ecf.internal.provider.filetransfer.httpclient5.Activator.getLogService(Activator.java:202)
	at org.eclipse.ecf.internal.provider.filetransfer.httpclient5.Activator.log(Activator.java:213)
	at org.eclipse.ecf.provider.filetransfer.httpclient5.HttpClientRetrieveFileTransfer.hardClose(HttpClientRetrieveFileTransfer.java:200)
	at org.eclipse.ecf.provider.filetransfer.retrieve.AbstractRetrieveFileTransfer$1.performFileTransfer(AbstractRetrieveFileTransfer.java:199)
	at org.eclipse.ecf.filetransfer.FileTransferJob.run(FileTransferJob.java:76)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.core.jobs 2 2 2022-09-28 14:39:40.943
!MESSAGE Job found still running after platform shutdown.  Jobs should be canceled by the plugin that scheduled them during shutdown: org.eclipse.oomph.internal.ui.EarlyStart$1
!SESSION 2022-09-28 21:15:50.858 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_AU
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2022-09-28 21:17:21.809
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-09-28 21:17:21.810
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-09-28 21:17:21.810
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-09-28 21:17:29.430
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\ffpbp'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-10-01 19:04:45.880 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_AU
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2022-10-01 19:06:13.513
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-10-01 19:06:13.513
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-10-01 19:06:13.513
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-10-01 19:06:20.202
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\ffpbp'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-10-04 19:44:14.804 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_AU
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2022-10-04 19:45:45.313
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-10-04 19:45:45.313
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-10-04 19:45:45.313
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-10-04 19:45:52.108
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\ffpbp'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.ui.workbench.texteditor 4 0 2022-10-04 20:06:12.945
!MESSAGE Disconnected before saving. Please post stacktrace to https://bugs.eclipse.org/bugs/show_bug.cgi?id=569286 org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor main.java
!STACK 0
java.lang.IllegalStateException: Disconnected before saving. Please post stacktrace to https://bugs.eclipse.org/bugs/show_bug.cgi?id=569286 org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor main.java
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.disconnectEditor(AbstractTextEditor.java:7136)
	at org.eclipse.ui.texteditor.AbstractTextEditor.doSetInput(AbstractTextEditor.java:4156)
	at org.eclipse.ui.texteditor.StatusTextEditor.doSetInput(StatusTextEditor.java:262)
	at org.eclipse.ui.texteditor.AbstractDecoratedTextEditor.doSetInput(AbstractDecoratedTextEditor.java:1479)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.internalDoSetInput(JavaEditor.java:2554)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.doSetInput(JavaEditor.java:2541)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.doSetInput(CompilationUnitEditor.java:1411)
	at org.eclipse.ui.texteditor.AbstractTextEditor.setInputWithNotify(AbstractTextEditor.java:4236)
	at org.eclipse.ui.texteditor.AbstractTextEditor.setInput(AbstractTextEditor.java:4256)
	at org.eclipse.ui.texteditor.AbstractTextEditor$ElementStateListener$1.run(AbstractTextEditor.java:533)
	at org.eclipse.ui.texteditor.AbstractTextEditor$ElementStateListener.execute(AbstractTextEditor.java:594)
	at org.eclipse.ui.texteditor.AbstractTextEditor$ElementStateListener.elementMoved(AbstractTextEditor.java:561)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider$FileBufferListener.underlyingFileMoved(TextFileDocumentProvider.java:335)
	at org.eclipse.core.internal.filebuffers.TextFileBufferManager$6.run(TextFileBufferManager.java:709)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.filebuffers.TextFileBufferManager.fireUnderlyingFileMoved(TextFileBufferManager.java:706)
	at org.eclipse.core.internal.filebuffers.ResourceFileBuffer.handleFileMoved(ResourceFileBuffer.java:422)
	at org.eclipse.core.internal.filebuffers.ResourceFileBuffer$FileSynchronizer$3.execute(ResourceFileBuffer.java:163)
	at org.eclipse.core.internal.filebuffers.ResourceFileBuffer$SafeFileChange.run(ResourceFileBuffer.java:86)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:132)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4043)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3648)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.block(ModalContext.java:166)
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:368)
	at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.run(RefactoringWizardDialog2.java:324)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizard.internalPerformFinish(RefactoringWizard.java:636)
	at org.eclipse.ltk.internal.ui.refactoring.ErrorWizardPage.performFinish(ErrorWizardPage.java:151)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizard.performFinish(RefactoringWizard.java:710)
	at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.okPressed(RefactoringWizardDialog2.java:450)
	at org.eclipse.jface.dialogs.Dialog.buttonPressed(Dialog.java:468)
	at org.eclipse.jface.dialogs.Dialog.lambda$0(Dialog.java:619)
	at org.eclipse.swt.events.SelectionListener$1.widgetSelected(SelectionListener.java:84)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:252)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4068)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3645)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:823)
	at org.eclipse.jface.window.Window.open(Window.java:799)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.lambda$0(RefactoringWizardOpenOperation.java:190)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.run(RefactoringWizardOpenOperation.java:209)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.run(RefactoringWizardOpenOperation.java:126)
	at org.eclipse.jdt.internal.ui.refactoring.actions.RefactoringStarter.activate(RefactoringStarter.java:41)
	at org.eclipse.jdt.internal.ui.refactoring.UserInterfaceStarter.activate(UserInterfaceStarter.java:65)
	at org.eclipse.jdt.internal.ui.refactoring.reorg.RenameUserInterfaceStarter.activate(RenameUserInterfaceStarter.java:35)
	at org.eclipse.jdt.ui.refactoring.RenameSupport.openDialog(RenameSupport.java:165)
	at org.eclipse.jdt.ui.refactoring.RenameSupport.openDialog(RenameSupport.java:121)
	at org.eclipse.jdt.internal.corext.refactoring.RefactoringExecutionStarter.startRenameRefactoring(RefactoringExecutionStarter.java:443)
	at org.eclipse.jdt.internal.ui.refactoring.actions.RenameJavaElementAction.run(RenameJavaElementAction.java:252)
	at org.eclipse.jdt.internal.ui.refactoring.actions.RenameJavaElementAction.run(RenameJavaElementAction.java:123)
	at org.eclipse.jdt.ui.actions.RenameAction.run(RenameAction.java:113)
	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.dispatchRun(SelectionDispatchAction.java:274)
	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.run(SelectionDispatchAction.java:252)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:580)
	at org.eclipse.jface.action.ActionContributionItem.lambda$4(ActionContributionItem.java:414)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4068)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3645)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
	Suppressed: java.lang.IllegalStateException: isDirty check after disconnect
		at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.isDirty(AbstractTextEditor.java:7185)
		at org.eclipse.ui.internal.Workbench.getFilteredSaveables(Workbench.java:3431)
		at org.eclipse.ui.internal.Workbench.saveAll(Workbench.java:3404)
		at org.eclipse.ui.ide.IDE$1.run(IDE.java:1458)
		at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
		at org.eclipse.ui.ide.IDE.saveAllEditors(IDE.java:1446)
		at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.doSave(SaveScopeResourcesHandler.java:228)
		at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.handleStatus(SaveScopeResourcesHandler.java:182)
		at org.eclipse.debug.internal.ui.sourcelookup.Prompter.lambda$0(Prompter.java:73)
		at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
		at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:172)
		at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
		at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:132)
		at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4043)
		at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3648)
		... 21 more
!SESSION 2022-10-08 18:36:03.936 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_AU
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2022-10-08 18:36:40.600
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-10-08 18:36:40.600
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-10-08 18:36:40.600
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-10-08 18:36:45.099
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\ffpbp'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2022-10-08 23:16:48.212
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.util.Scanner;

public class MainDay3 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Scanner scanner = new Scanner(System.in);
		System.out.println("Please enter your average point of Maths: ");
		Double mathsPoint = scanner.nextDouble();
		System.out.println("Please enter your average point of English: ");
		Double englishPoint = scanner.nextDouble();
		System.out.println("Please enter your average point of Literature: ");
		Double literaturePoint = scanner.nextDouble();
		Double minPoint = (mathsPoint > englishPoint) ? englishPoint : mathsPoint;
		minPoint = (literaturePoint >)
		Double averagePoint = (mathsPoint + englishPoint + literaturePoint) / 3;

		scanner.close();
	}

	public static char getGrade(double point) {
		if (point >= 9)
			return 'S';
		else if (point >= 8)
			return 'A';
		else if (point >= 7)
			return 'B';
		else if (point >= 6)
			return 'C';
		else if (point >= 5)
			return 'D';
		else
			return 'F';
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1207)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2022-10-08 23:16:48.216
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1207)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2022-10-08 23:16:48.216
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1207)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-08 23:16:48.349
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.util.Scanner;

public class MainDay3 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Scanner scanner = new Scanner(System.in);
		System.out.println("Please enter your average point of Maths: ");
		Double mathsPoint = scanner.nextDouble();
		System.out.println("Please enter your average point of English: ");
		Double englishPoint = scanner.nextDouble();
		System.out.println("Please enter your average point of Literature: ");
		Double literaturePoint = scanner.nextDouble();
		Double minPoint = (mathsPoint > englishPoint) ? englishPoint : mathsPoint;
		minPoint = (literaturePoint >)
		Double averagePoint = (mathsPoint + englishPoint + literaturePoint) / 3;

		scanner.close();
	}

	public static char getGrade(double point) {
		if (point >= 9)
			return 'S';
		else if (point >= 8)
			return 'A';
		else if (point >= 7)
			return 'B';
		else if (point >= 6)
			return 'C';
		else if (point >= 5)
			return 'D';
		else
			return 'F';
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1207)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-10-08 23:16:48.350
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1207)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-10-08 23:16:48.350
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1207)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-08 23:16:49.142
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.util.Scanner;

public class MainDay3 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Scanner scanner = new Scanner(System.in);
		System.out.println("Please enter your average point of Maths: ");
		Double mathsPoint = scanner.nextDouble();
		System.out.println("Please enter your average point of English: ");
		Double englishPoint = scanner.nextDouble();
		System.out.println("Please enter your average point of Literature: ");
		Double literaturePoint = scanner.nextDouble();
		Double minPoint = (mathsPoint > englishPoint) ? englishPoint : mathsPoint;
		minPoint = (literaturePoint > )
		Double averagePoint = (mathsPoint + englishPoint + literaturePoint) / 3;

		scanner.close();
	}

	public static char getGrade(double point) {
		if (point >= 9)
			return 'S';
		else if (point >= 8)
			return 'A';
		else if (point >= 7)
			return 'B';
		else if (point >= 6)
			return 'C';
		else if (point >= 5)
			return 'D';
		else
			return 'F';
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1207)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2022-10-08 23:16:49.142
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1207)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2022-10-08 23:16:49.143
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1207)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-08 23:16:49.276
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.util.Scanner;

public class MainDay3 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Scanner scanner = new Scanner(System.in);
		System.out.println("Please enter your average point of Maths: ");
		Double mathsPoint = scanner.nextDouble();
		System.out.println("Please enter your average point of English: ");
		Double englishPoint = scanner.nextDouble();
		System.out.println("Please enter your average point of Literature: ");
		Double literaturePoint = scanner.nextDouble();
		Double minPoint = (mathsPoint > englishPoint) ? englishPoint : mathsPoint;
		minPoint = (literaturePoint > )
		Double averagePoint = (mathsPoint + englishPoint + literaturePoint) / 3;

		scanner.close();
	}

	public static char getGrade(double point) {
		if (point >= 9)
			return 'S';
		else if (point >= 8)
			return 'A';
		else if (point >= 7)
			return 'B';
		else if (point >= 6)
			return 'C';
		else if (point >= 5)
			return 'D';
		else
			return 'F';
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1207)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-10-08 23:16:49.277
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1207)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-10-08 23:16:49.277
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1207)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2022-10-09 22:43:40.197 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_AU
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2022-10-09 22:44:21.034
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-10-09 22:44:21.034
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-10-09 22:44:21.034
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-10-09 22:44:27.876
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\ffpbp'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2022-10-09 23:56:44.100
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.Scanner;

public class MainDay3 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

		// SINGLE NUMBER
		int[] nums1 = { 2, 2, 1 };
		int[] nums2 = { 4, 1, 2, 1, 2 };
		int[] nums3 = { 1 };
		int[] nums4 = { 6, 3, 1, 9, 7, 2, 5, 8, 4 };
		int[] nums5 = { 1, 2, 3, 4, 5, 6, 5, 6, 4, 3, 2, 1, 7 };
		mergeSort(nums4);
		(secondArrCurrentIndex < secondHalArrSize)
//		 PRIME NUMBER
//		int[] numbers = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };
//		for (int num : numbers) {
//			System.out.println("Is " + num + " a Prime number? " + isPrimeNumber(num));
//		}
		// PALINDROME
//		int[] intArr = { 1, 1, 1, 1 };
//		System.out.println("Is Palindrome: " + isPalindrome(intArr));
		// MIN MAX AVERAGE
//		int[] intArr = { 4, 6, 2, 1, 7, 9, 10, 15, 0 };
//		int min = intArr[0];
//		int max = intArr[0];
//		double average = 0;
//		for (int i = 0; i < intArr.length; i++) {
//			if (intArr[i] > max)
//				max = intArr[i];
//			if (intArr[i] < min)
//				min = intArr[i];
//			average += intArr[i];
//		}
//		System.out.println("Min is: " + min);
//		System.out.println("Max is: " + max);
//		System.out.println("Average is: " + Math.ceil(average * 100.00 / intArr.length) / 100.00);

		// GRADE
//		Scanner scanner = new Scanner(System.in);
//		System.out.println("Please enter your average point of Maths: ");
//		Double mathsPoint = scanner.nextDouble();
//		System.out.println("Your Maths Grade is: " + getGrade(mathsPoint));
//		System.out.println("Please enter your average point of English: ");
//		Double englishPoint = scanner.nextDouble();
//		System.out.println("Your English Grade is: " + getGrade(englishPoint));
//		System.out.println("Please enter your average point of Literature: ");
//		Double literaturePoint = scanner.nextDouble();
//		System.out.println("Your Literature Grade is: " + getGrade(literaturePoint));
//
//		Double averagePoint = Math.ceil((mathsPoint + englishPoint + literaturePoint) * 100.00 / 3) / 100.00;
//		System.out.println("Your Average Point is: " + averagePoint);
//
//		Double minPoint = (mathsPoint > englishPoint) ? englishPoint : mathsPoint;
//		minPoint = (minPoint > literaturePoint) ? literaturePoint : minPoint;
//		char grade;
//		if (minPoint < 5) {
//			grade = 'F';
//		} else if (averagePoint - minPoint > 1) {
//			grade = getGrade(minPoint + 1);
//			System.out.println("Your Grade is: " + grade);
//
//		} else {
//			grade = getGrade(averagePoint);
//			System.out.println("Your Grade is: " + grade);
//		}
//		switch (grade) {
//		case 'S':
//			System.out.println("Excellent Student");
//			break;
//		case 'A':
//			System.out.println("Good Student");
//			break;
//		case 'B':
//			System.out.println("Normal Student");
//			break;
//		case 'C':
//			System.out.println("Average Student");
//			break;
//		case 'D':
//			System.out.println("Not Bad Student");
//			break;
//		case 'F':
//			System.out.println("Fail Student");
//			break;
//		}
//		scanner.close();
	}

	public static char getGrade(double point) {
		if (point >= 9)
			return 'S';
		else if (point >= 8)
			return 'A';
		else if (point >= 7)
			return 'B';
		else if (point >= 6)
			return 'C';
		else if (point >= 5)
			return 'D';
		else
			return 'F';
	}

	public static boolean isPalindrome(int[] numbers) {
		if (numbers.length == 0)
			return false;
		else if (numbers.length == 1)
			return true;
		else {
			for (int i = 0; i < numbers.length / 2; i++) {
				if (numbers[i] != numbers[numbers.length - 1 - i])
					return false;
			}
			return true;
		}
	}

	// upgraded. Chi can chay toi 1 + number/2 la dc roi
	public static boolean isPrimeNumber(int number) {
		if (number <= 0)
			return false;
		else if (number <= 2)
			return true;
		else {
			for (int i = 2; i < 1 + number / 2; i++) {
				if (number % i == 0)
					return false;
			}
			return true;
		}
	}

	public static void mergeSort(int[] nums) {
		// dk thoat recursive
		if (nums.length >= 2) {
			int endIndex = nums.length - 1;
			int middleIndex = nums.length / 2;

			int firstHalfArrSize = middleIndex;
			int secondHalArrSize = endIndex - middleIndex + 1;

			int[] firstHalfArr = new int[firstHalfArrSize];
			int[] secondHalfArr = new int[secondHalArrSize];

			// copy qua 2 sub array
			for (int i = 0; i < firstHalfArrSize; i++) {
				firstHalfArr[i] = nums[i];
			}
			for (int i = 0; i < secondHalArrSize; i++) {
				secondHalfArr[i] = nums[i + firstHalfArrSize];
			}
			//recursive call
			mergeSort(firstHalfArr);
			mergeSort(secondHalfArr);
			// merge 2 sorted subarray
			int firstArrCurrentIndex = 0;
			int secondArrCurrentIndex = 0;
			int currentNumsArrIndex = 0;
			// loop qua 2 sub array de compare va copy qua nums cho toi khi finish 1 trong 2
			// cai array
			while ((firstArrCurrentIndex < firstHalfArrSize) && (secondArrCurrentIndex < secondHalArrSize)) {				
				if (firstHalfArr[firstArrCurrentIndex] <= secondHalfArr[secondArrCurrentIndex]) {
					nums[currentNumsArrIndex++] = firstHalfArr[firstArrCurrentIndex++];					
				} else {
					nums[currentNumsArrIndex++] = secondHalfArr[secondArrCurrentIndex++];
				}
			}
			// copy phan con lai cua 1 trong 2 cai array qua nums
			if (firstArrCurrentIndex < firstHalfArrSize) {
				nums[currentNumsArrIndex++] = firstHalfArr[firstArrCurrentIndex++];
			} else if (secondArrCurrentIndex < secondHalArrSize){
				nums[currentNumsArrIndex++] = secondHalfArr[secondArrCurrentIndex++];
			}
		}
	}

	public static int singleNumber(int[] nums) {
		int singleNumber = nums[0];
		int count = 0;
		for (int i = 0; i < nums.length; i++) {
			if (nums[i] == nums.length)
				continue;
			boolean pairFound = false;
			for (int j = i + 1; j < nums.length; j++) {
				System.out.println(Arrays.toString(nums));
				count++;
				if (nums[i] == nums[j]) {
					pairFound = true;
					nums[j] = nums.length;
					break;
				}
			}
			if (!pairFound) {
				singleNumber = nums[i];
				break;
			}
		}
		System.out.println("N: " + nums.length + " - loop: " + count);
		return singleNumber;
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2022-10-09 23:56:44.102
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2022-10-09 23:56:44.102
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-10 02:57:36.991
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.Scanner;

public class MainDay3 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

		// SINGLE NUMBER
		int[] nums1 = { 2, 2, 1 };
		int[] nums2 = { 4, 1, 2, 1, 2 };
		int[] nums3 = { 1 };
		int[] nums4 = { 6, 3, 1, 7, 2, 5, 8, 4 };
		int[] nums5 = { 1, 2, 3, 4, 5, 6, 5, 6, 4, 3, 2, 1, 7 };
		1 3 5 5 3 1 7 a b c b c a d 2a+
		2 4 6 6 4 2
		
		System.out.println("Average: " + findSingle(nums5));
//		mergeSort(nums5);
//		System.out.println("Sorted array: " + Arrays.toString(nums5));
//		System.out.println("Single number: " + findSingleNumber(nums5));
//		 PRIME NUMBER
//		int[] numbers = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };
//		for (int num : numbers) {
//			System.out.println("Is " + num + " a Prime number? " + isPrimeNumber(num));
//		}
		// PALINDROME
//		int[] intArr = { 1, 1, 1, 1 };
//		System.out.println("Is Palindrome: " + isPalindrome(intArr));
		// MIN MAX AVERAGE
//		int[] intArr = { 4, 6, 2, 1, 7, 9, 10, 15, 0 };
//		int min = intArr[0];
//		int max = intArr[0];
//		double average = 0;
//		for (int i = 0; i < intArr.length; i++) {
//			if (intArr[i] > max)
//				max = intArr[i];
//			if (intArr[i] < min)
//				min = intArr[i];
//			average += intArr[i];
//		}
//		System.out.println("Min is: " + min);
//		System.out.println("Max is: " + max);
//		System.out.println("Average is: " + Math.ceil(average * 100.00 / intArr.length) / 100.00);

		// GRADE
//		Scanner scanner = new Scanner(System.in);
//		System.out.println("Please enter your average point of Maths: ");
//		Double mathsPoint = scanner.nextDouble();
//		System.out.println("Your Maths Grade is: " + getGrade(mathsPoint));
//		System.out.println("Please enter your average point of English: ");
//		Double englishPoint = scanner.nextDouble();
//		System.out.println("Your English Grade is: " + getGrade(englishPoint));
//		System.out.println("Please enter your average point of Literature: ");
//		Double literaturePoint = scanner.nextDouble();
//		System.out.println("Your Literature Grade is: " + getGrade(literaturePoint));
//
//		Double averagePoint = Math.ceil((mathsPoint + englishPoint + literaturePoint) * 100.00 / 3) / 100.00;
//		System.out.println("Your Average Point is: " + averagePoint);
//
//		Double minPoint = (mathsPoint > englishPoint) ? englishPoint : mathsPoint;
//		minPoint = (minPoint > literaturePoint) ? literaturePoint : minPoint;
//		char grade;
//		if (minPoint < 5) {
//			grade = 'F';
//		} else if (averagePoint - minPoint > 1) {
//			grade = getGrade(minPoint + 1);
//			System.out.println("Your Grade is: " + grade);
//
//		} else {
//			grade = getGrade(averagePoint);
//			System.out.println("Your Grade is: " + grade);
//		}
//		switch (grade) {
//		case 'S':
//			System.out.println("Excellent Student");
//			break;
//		case 'A':
//			System.out.println("Good Student");
//			break;
//		case 'B':
//			System.out.println("Normal Student");
//			break;
//		case 'C':
//			System.out.println("Average Student");
//			break;
//		case 'D':
//			System.out.println("Not Bad Student");
//			break;
//		case 'F':
//			System.out.println("Fail Student");
//			break;
//		}
//		scanner.close();
	}

	public static char getGrade(double point) {
		if (point >= 9)
			return 'S';
		else if (point >= 8)
			return 'A';
		else if (point >= 7)
			return 'B';
		else if (point >= 6)
			return 'C';
		else if (point >= 5)
			return 'D';
		else
			return 'F';
	}

	public static boolean isPalindrome(int[] numbers) {
		if (numbers.length == 0)
			return false;
		else if (numbers.length == 1)
			return true;
		else {
			for (int i = 0; i < numbers.length / 2; i++) {
				if (numbers[i] != numbers[numbers.length - 1 - i])
					return false;
			}
			return true;
		}
	}

	// upgraded. Chi can chay toi 1 + number/2 la dc roi
	public static boolean isPrimeNumber(int number) {
		if (number <= 0)
			return false;
		else if (number <= 2)
			return true;
		else {
			for (int i = 2; i < 1 + number / 2; i++) {
				if (number % i == 0)
					return false;
			}
			return true;
		}
	}

	public static void mergeSort(int[] nums) {
		// chia doi nums thanh nums1 va nums2
		int endIndex = nums.length - 1;
		int middleIndex = nums.length / 2;
		int firstHalfArrSize = middleIndex;
		int secondHalArrSize = endIndex - middleIndex + 1;
		int[] firstHalfArr = new int[firstHalfArrSize];
		int[] secondHalfArr = new int[secondHalArrSize];
		// copy qua 2 sub array
		for (int i = 0; i < firstHalfArrSize; i++) {
			firstHalfArr[i] = nums[i];
		}
		for (int i = 0; i < secondHalArrSize; i++) {
			secondHalfArr[i] = nums[i + firstHalfArrSize];
		}
		// tiep tuc goi recursive cho toi khi nums.length = 1 moi bat dau swap
		// vay tu nums.length de chia xuong con 1 thi se co' log2(nums.length) lan chia
		// lan chia dau tien ton 1 effort
		// lan chia thu 2 ton 2 effort
		// lan chia thu 3 ton 4 effort
		// lan chia thu log2(nums.length) ton 2^(log2(nums.length) - 1) effort
		// vay tong cong ton 2^0 + 2^1 + 2^2 +..+ 2^(log2(nums.length)-1) effort de goi
		// recursive
		if (firstHalfArrSize > 1)
			mergeSort(firstHalfArr);
		if (secondHalArrSize > 1)
			mergeSort(secondHalfArr);
		// merge 2 sorted subarray
		int firstArrCurrentIndex = 0;
		int secondArrCurrentIndex = 0;
		int currentNumsArrIndex = 0;
		// loop qua 2 sub array de compare va copy qua nums cho toi khi finish 1 trong 2
		// cai array
		// moi recursive se loop qua firstHalf va secondHalf, tuc la nums.length effort
		// co log2(nums.length) level, vay tong cong ton log2(nums.length) * nums.length
		// effort
		while ((firstArrCurrentIndex < firstHalfArrSize) && (secondArrCurrentIndex < secondHalArrSize)) {
			if (firstHalfArr[firstArrCurrentIndex] <= secondHalfArr[secondArrCurrentIndex]) {
				nums[currentNumsArrIndex++] = firstHalfArr[firstArrCurrentIndex++];
			} else {
				nums[currentNumsArrIndex++] = secondHalfArr[secondArrCurrentIndex++];
			}
		}
		// copy phan con lai cua 1 trong 2 cai array qua nums
		if (firstArrCurrentIndex < firstHalfArrSize) {
			nums[currentNumsArrIndex++] = firstHalfArr[firstArrCurrentIndex++];
		} else if (secondArrCurrentIndex < secondHalArrSize) {
			nums[currentNumsArrIndex++] = secondHalfArr[secondArrCurrentIndex++];
		}
		// vay tong cong se ton 2^0 + 2^1 + ... + 2^(log2(nums.length)-1) +
		// log2(nums.length) * nums.length effort
	}

	public static int findSingleNumber(int[] nums) {
		// vi array da sort nen worst cua findSingleNumber la 1 + nums.length / 2
		// vay tong cong effot de tim so single la 2^0 + 2^1 + ... +
		// 2^(log2(nums.length)-1) + log2(nums.length) * nums.length + 1 + nums.length /
		// 2
		int singleNumber = nums[0];
		if (nums.length == 1)
			return singleNumber;
		for (int i = 1; i < nums.length; i++) {
			if (singleNumber == nums[i])
				singleNumber = nums[++i];
			else
				return singleNumber;
		}
		return singleNumber;
	}

	public static int singleNumber(int[] nums) {
		int singleNumber = nums[0];
		int count = 0;
		for (int i = 0; i < nums.length; i++) {
			if (nums[i] == nums.length)
				continue;
			boolean pairFound = false;
			for (int j = i + 1; j < nums.length; j++) {
				System.out.println(Arrays.toString(nums));
				count++;
				if (nums[i] == nums[j]) {
					pairFound = true;
					nums[j] = nums.length;
					break;
				}
			}
			if (!pairFound) {
				singleNumber = nums[i];
				break;
			}
		}
		System.out.println("N: " + nums.length + " - loop: " + count);
		return singleNumber;
	}

	public static int findSingle(int[] nums) {
		int[] firstHalf = new int[1 + nums.length / 2];
		int[] secondHalf = new int[1 + nums.length / 2];
		int firstHalfIndex = 0;
		int secondHalfIndex = 0;
		for (int num : nums) {
			if (num % 2 == 0) 
				firstHalf[firstHalfIndex++] = num;
			else
				secondHalf[secondHalfIndex++] = num;
		}
		if(firstHalfIndex > secondHalfIndex) {
			
		}else {
			
		}
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2022-10-10 02:57:36.991
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2022-10-10 02:57:36.994
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-10 02:57:37.001
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.Scanner;

public class MainDay3 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

		// SINGLE NUMBER
		int[] nums1 = { 2, 2, 1 };
		int[] nums2 = { 4, 1, 2, 1, 2 };
		int[] nums3 = { 1 };
		int[] nums4 = { 6, 3, 1, 7, 2, 5, 8, 4 };
		int[] nums5 = { 1, 2, 3, 4, 5, 6, 5, 6, 4, 3, 2, 1, 7 };
		1 3 5 5 3 1 7 a b c b c a d 2a+
		2 4 6 6 4 2
		
		System.out.println("Average: " + findSingle(nums5));
//		mergeSort(nums5);
//		System.out.println("Sorted array: " + Arrays.toString(nums5));
//		System.out.println("Single number: " + findSingleNumber(nums5));
//		 PRIME NUMBER
//		int[] numbers = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };
//		for (int num : numbers) {
//			System.out.println("Is " + num + " a Prime number? " + isPrimeNumber(num));
//		}
		// PALINDROME
//		int[] intArr = { 1, 1, 1, 1 };
//		System.out.println("Is Palindrome: " + isPalindrome(intArr));
		// MIN MAX AVERAGE
//		int[] intArr = { 4, 6, 2, 1, 7, 9, 10, 15, 0 };
//		int min = intArr[0];
//		int max = intArr[0];
//		double average = 0;
//		for (int i = 0; i < intArr.length; i++) {
//			if (intArr[i] > max)
//				max = intArr[i];
//			if (intArr[i] < min)
//				min = intArr[i];
//			average += intArr[i];
//		}
//		System.out.println("Min is: " + min);
//		System.out.println("Max is: " + max);
//		System.out.println("Average is: " + Math.ceil(average * 100.00 / intArr.length) / 100.00);

		// GRADE
//		Scanner scanner = new Scanner(System.in);
//		System.out.println("Please enter your average point of Maths: ");
//		Double mathsPoint = scanner.nextDouble();
//		System.out.println("Your Maths Grade is: " + getGrade(mathsPoint));
//		System.out.println("Please enter your average point of English: ");
//		Double englishPoint = scanner.nextDouble();
//		System.out.println("Your English Grade is: " + getGrade(englishPoint));
//		System.out.println("Please enter your average point of Literature: ");
//		Double literaturePoint = scanner.nextDouble();
//		System.out.println("Your Literature Grade is: " + getGrade(literaturePoint));
//
//		Double averagePoint = Math.ceil((mathsPoint + englishPoint + literaturePoint) * 100.00 / 3) / 100.00;
//		System.out.println("Your Average Point is: " + averagePoint);
//
//		Double minPoint = (mathsPoint > englishPoint) ? englishPoint : mathsPoint;
//		minPoint = (minPoint > literaturePoint) ? literaturePoint : minPoint;
//		char grade;
//		if (minPoint < 5) {
//			grade = 'F';
//		} else if (averagePoint - minPoint > 1) {
//			grade = getGrade(minPoint + 1);
//			System.out.println("Your Grade is: " + grade);
//
//		} else {
//			grade = getGrade(averagePoint);
//			System.out.println("Your Grade is: " + grade);
//		}
//		switch (grade) {
//		case 'S':
//			System.out.println("Excellent Student");
//			break;
//		case 'A':
//			System.out.println("Good Student");
//			break;
//		case 'B':
//			System.out.println("Normal Student");
//			break;
//		case 'C':
//			System.out.println("Average Student");
//			break;
//		case 'D':
//			System.out.println("Not Bad Student");
//			break;
//		case 'F':
//			System.out.println("Fail Student");
//			break;
//		}
//		scanner.close();
	}

	public static char getGrade(double point) {
		if (point >= 9)
			return 'S';
		else if (point >= 8)
			return 'A';
		else if (point >= 7)
			return 'B';
		else if (point >= 6)
			return 'C';
		else if (point >= 5)
			return 'D';
		else
			return 'F';
	}

	public static boolean isPalindrome(int[] numbers) {
		if (numbers.length == 0)
			return false;
		else if (numbers.length == 1)
			return true;
		else {
			for (int i = 0; i < numbers.length / 2; i++) {
				if (numbers[i] != numbers[numbers.length - 1 - i])
					return false;
			}
			return true;
		}
	}

	// upgraded. Chi can chay toi 1 + number/2 la dc roi
	public static boolean isPrimeNumber(int number) {
		if (number <= 0)
			return false;
		else if (number <= 2)
			return true;
		else {
			for (int i = 2; i < 1 + number / 2; i++) {
				if (number % i == 0)
					return false;
			}
			return true;
		}
	}

	public static void mergeSort(int[] nums) {
		// chia doi nums thanh nums1 va nums2
		int endIndex = nums.length - 1;
		int middleIndex = nums.length / 2;
		int firstHalfArrSize = middleIndex;
		int secondHalArrSize = endIndex - middleIndex + 1;
		int[] firstHalfArr = new int[firstHalfArrSize];
		int[] secondHalfArr = new int[secondHalArrSize];
		// copy qua 2 sub array
		for (int i = 0; i < firstHalfArrSize; i++) {
			firstHalfArr[i] = nums[i];
		}
		for (int i = 0; i < secondHalArrSize; i++) {
			secondHalfArr[i] = nums[i + firstHalfArrSize];
		}
		// tiep tuc goi recursive cho toi khi nums.length = 1 moi bat dau swap
		// vay tu nums.length de chia xuong con 1 thi se co' log2(nums.length) lan chia
		// lan chia dau tien ton 1 effort
		// lan chia thu 2 ton 2 effort
		// lan chia thu 3 ton 4 effort
		// lan chia thu log2(nums.length) ton 2^(log2(nums.length) - 1) effort
		// vay tong cong ton 2^0 + 2^1 + 2^2 +..+ 2^(log2(nums.length)-1) effort de goi
		// recursive
		if (firstHalfArrSize > 1)
			mergeSort(firstHalfArr);
		if (secondHalArrSize > 1)
			mergeSort(secondHalfArr);
		// merge 2 sorted subarray
		int firstArrCurrentIndex = 0;
		int secondArrCurrentIndex = 0;
		int currentNumsArrIndex = 0;
		// loop qua 2 sub array de compare va copy qua nums cho toi khi finish 1 trong 2
		// cai array
		// moi recursive se loop qua firstHalf va secondHalf, tuc la nums.length effort
		// co log2(nums.length) level, vay tong cong ton log2(nums.length) * nums.length
		// effort
		while ((firstArrCurrentIndex < firstHalfArrSize) && (secondArrCurrentIndex < secondHalArrSize)) {
			if (firstHalfArr[firstArrCurrentIndex] <= secondHalfArr[secondArrCurrentIndex]) {
				nums[currentNumsArrIndex++] = firstHalfArr[firstArrCurrentIndex++];
			} else {
				nums[currentNumsArrIndex++] = secondHalfArr[secondArrCurrentIndex++];
			}
		}
		// copy phan con lai cua 1 trong 2 cai array qua nums
		if (firstArrCurrentIndex < firstHalfArrSize) {
			nums[currentNumsArrIndex++] = firstHalfArr[firstArrCurrentIndex++];
		} else if (secondArrCurrentIndex < secondHalArrSize) {
			nums[currentNumsArrIndex++] = secondHalfArr[secondArrCurrentIndex++];
		}
		// vay tong cong se ton 2^0 + 2^1 + ... + 2^(log2(nums.length)-1) +
		// log2(nums.length) * nums.length effort
	}

	public static int findSingleNumber(int[] nums) {
		// vi array da sort nen worst cua findSingleNumber la 1 + nums.length / 2
		// vay tong cong effot de tim so single la 2^0 + 2^1 + ... +
		// 2^(log2(nums.length)-1) + log2(nums.length) * nums.length + 1 + nums.length /
		// 2
		int singleNumber = nums[0];
		if (nums.length == 1)
			return singleNumber;
		for (int i = 1; i < nums.length; i++) {
			if (singleNumber == nums[i])
				singleNumber = nums[++i];
			else
				return singleNumber;
		}
		return singleNumber;
	}

	public static int singleNumber(int[] nums) {
		int singleNumber = nums[0];
		int count = 0;
		for (int i = 0; i < nums.length; i++) {
			if (nums[i] == nums.length)
				continue;
			boolean pairFound = false;
			for (int j = i + 1; j < nums.length; j++) {
				System.out.println(Arrays.toString(nums));
				count++;
				if (nums[i] == nums[j]) {
					pairFound = true;
					nums[j] = nums.length;
					break;
				}
			}
			if (!pairFound) {
				singleNumber = nums[i];
				break;
			}
		}
		System.out.println("N: " + nums.length + " - loop: " + count);
		return singleNumber;
	}

	public static int findSingle(int[] nums) {
		int[] firstHalf = new int[1 + nums.length / 2];
		int[] secondHalf = new int[1 + nums.length / 2];
		int firstHalfIndex = 0;
		int secondHalfIndex = 0;
		for (int num : nums) {
			if (num % 2 == 0) 
				firstHalf[firstHalfIndex++] = num;
			else
				secondHalf[secondHalfIndex++] = num;
		}
		if(firstHalfIndex > secondHalfIndex) {
			
		}else {
			
		}
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-10-10 02:57:37.002
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-10-10 02:57:37.003
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-10 02:57:38.198
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.Scanner;

public class MainDay3 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

		// SINGLE NUMBER
		int[] nums1 = { 2, 2, 1 };
		int[] nums2 = { 4, 1, 2, 1, 2 };
		int[] nums3 = { 1 };
		int[] nums4 = { 6, 3, 1, 7, 2, 5, 8, 4 };
		int[] nums5 = { 1, 2, 3, 4, 5, 6, 5, 6, 4, 3, 2, 1, 7 };
		1 3 5 5 3 1 7 a b c b c a d 2a+2b
		2 4 6 6 4 2
		
		System.out.println("Average: " + findSingle(nums5));
//		mergeSort(nums5);
//		System.out.println("Sorted array: " + Arrays.toString(nums5));
//		System.out.println("Single number: " + findSingleNumber(nums5));
//		 PRIME NUMBER
//		int[] numbers = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };
//		for (int num : numbers) {
//			System.out.println("Is " + num + " a Prime number? " + isPrimeNumber(num));
//		}
		// PALINDROME
//		int[] intArr = { 1, 1, 1, 1 };
//		System.out.println("Is Palindrome: " + isPalindrome(intArr));
		// MIN MAX AVERAGE
//		int[] intArr = { 4, 6, 2, 1, 7, 9, 10, 15, 0 };
//		int min = intArr[0];
//		int max = intArr[0];
//		double average = 0;
//		for (int i = 0; i < intArr.length; i++) {
//			if (intArr[i] > max)
//				max = intArr[i];
//			if (intArr[i] < min)
//				min = intArr[i];
//			average += intArr[i];
//		}
//		System.out.println("Min is: " + min);
//		System.out.println("Max is: " + max);
//		System.out.println("Average is: " + Math.ceil(average * 100.00 / intArr.length) / 100.00);

		// GRADE
//		Scanner scanner = new Scanner(System.in);
//		System.out.println("Please enter your average point of Maths: ");
//		Double mathsPoint = scanner.nextDouble();
//		System.out.println("Your Maths Grade is: " + getGrade(mathsPoint));
//		System.out.println("Please enter your average point of English: ");
//		Double englishPoint = scanner.nextDouble();
//		System.out.println("Your English Grade is: " + getGrade(englishPoint));
//		System.out.println("Please enter your average point of Literature: ");
//		Double literaturePoint = scanner.nextDouble();
//		System.out.println("Your Literature Grade is: " + getGrade(literaturePoint));
//
//		Double averagePoint = Math.ceil((mathsPoint + englishPoint + literaturePoint) * 100.00 / 3) / 100.00;
//		System.out.println("Your Average Point is: " + averagePoint);
//
//		Double minPoint = (mathsPoint > englishPoint) ? englishPoint : mathsPoint;
//		minPoint = (minPoint > literaturePoint) ? literaturePoint : minPoint;
//		char grade;
//		if (minPoint < 5) {
//			grade = 'F';
//		} else if (averagePoint - minPoint > 1) {
//			grade = getGrade(minPoint + 1);
//			System.out.println("Your Grade is: " + grade);
//
//		} else {
//			grade = getGrade(averagePoint);
//			System.out.println("Your Grade is: " + grade);
//		}
//		switch (grade) {
//		case 'S':
//			System.out.println("Excellent Student");
//			break;
//		case 'A':
//			System.out.println("Good Student");
//			break;
//		case 'B':
//			System.out.println("Normal Student");
//			break;
//		case 'C':
//			System.out.println("Average Student");
//			break;
//		case 'D':
//			System.out.println("Not Bad Student");
//			break;
//		case 'F':
//			System.out.println("Fail Student");
//			break;
//		}
//		scanner.close();
	}

	public static char getGrade(double point) {
		if (point >= 9)
			return 'S';
		else if (point >= 8)
			return 'A';
		else if (point >= 7)
			return 'B';
		else if (point >= 6)
			return 'C';
		else if (point >= 5)
			return 'D';
		else
			return 'F';
	}

	public static boolean isPalindrome(int[] numbers) {
		if (numbers.length == 0)
			return false;
		else if (numbers.length == 1)
			return true;
		else {
			for (int i = 0; i < numbers.length / 2; i++) {
				if (numbers[i] != numbers[numbers.length - 1 - i])
					return false;
			}
			return true;
		}
	}

	// upgraded. Chi can chay toi 1 + number/2 la dc roi
	public static boolean isPrimeNumber(int number) {
		if (number <= 0)
			return false;
		else if (number <= 2)
			return true;
		else {
			for (int i = 2; i < 1 + number / 2; i++) {
				if (number % i == 0)
					return false;
			}
			return true;
		}
	}

	public static void mergeSort(int[] nums) {
		// chia doi nums thanh nums1 va nums2
		int endIndex = nums.length - 1;
		int middleIndex = nums.length / 2;
		int firstHalfArrSize = middleIndex;
		int secondHalArrSize = endIndex - middleIndex + 1;
		int[] firstHalfArr = new int[firstHalfArrSize];
		int[] secondHalfArr = new int[secondHalArrSize];
		// copy qua 2 sub array
		for (int i = 0; i < firstHalfArrSize; i++) {
			firstHalfArr[i] = nums[i];
		}
		for (int i = 0; i < secondHalArrSize; i++) {
			secondHalfArr[i] = nums[i + firstHalfArrSize];
		}
		// tiep tuc goi recursive cho toi khi nums.length = 1 moi bat dau swap
		// vay tu nums.length de chia xuong con 1 thi se co' log2(nums.length) lan chia
		// lan chia dau tien ton 1 effort
		// lan chia thu 2 ton 2 effort
		// lan chia thu 3 ton 4 effort
		// lan chia thu log2(nums.length) ton 2^(log2(nums.length) - 1) effort
		// vay tong cong ton 2^0 + 2^1 + 2^2 +..+ 2^(log2(nums.length)-1) effort de goi
		// recursive
		if (firstHalfArrSize > 1)
			mergeSort(firstHalfArr);
		if (secondHalArrSize > 1)
			mergeSort(secondHalfArr);
		// merge 2 sorted subarray
		int firstArrCurrentIndex = 0;
		int secondArrCurrentIndex = 0;
		int currentNumsArrIndex = 0;
		// loop qua 2 sub array de compare va copy qua nums cho toi khi finish 1 trong 2
		// cai array
		// moi recursive se loop qua firstHalf va secondHalf, tuc la nums.length effort
		// co log2(nums.length) level, vay tong cong ton log2(nums.length) * nums.length
		// effort
		while ((firstArrCurrentIndex < firstHalfArrSize) && (secondArrCurrentIndex < secondHalArrSize)) {
			if (firstHalfArr[firstArrCurrentIndex] <= secondHalfArr[secondArrCurrentIndex]) {
				nums[currentNumsArrIndex++] = firstHalfArr[firstArrCurrentIndex++];
			} else {
				nums[currentNumsArrIndex++] = secondHalfArr[secondArrCurrentIndex++];
			}
		}
		// copy phan con lai cua 1 trong 2 cai array qua nums
		if (firstArrCurrentIndex < firstHalfArrSize) {
			nums[currentNumsArrIndex++] = firstHalfArr[firstArrCurrentIndex++];
		} else if (secondArrCurrentIndex < secondHalArrSize) {
			nums[currentNumsArrIndex++] = secondHalfArr[secondArrCurrentIndex++];
		}
		// vay tong cong se ton 2^0 + 2^1 + ... + 2^(log2(nums.length)-1) +
		// log2(nums.length) * nums.length effort
	}

	public static int findSingleNumber(int[] nums) {
		// vi array da sort nen worst cua findSingleNumber la 1 + nums.length / 2
		// vay tong cong effot de tim so single la 2^0 + 2^1 + ... +
		// 2^(log2(nums.length)-1) + log2(nums.length) * nums.length + 1 + nums.length /
		// 2
		int singleNumber = nums[0];
		if (nums.length == 1)
			return singleNumber;
		for (int i = 1; i < nums.length; i++) {
			if (singleNumber == nums[i])
				singleNumber = nums[++i];
			else
				return singleNumber;
		}
		return singleNumber;
	}

	public static int singleNumber(int[] nums) {
		int singleNumber = nums[0];
		int count = 0;
		for (int i = 0; i < nums.length; i++) {
			if (nums[i] == nums.length)
				continue;
			boolean pairFound = false;
			for (int j = i + 1; j < nums.length; j++) {
				System.out.println(Arrays.toString(nums));
				count++;
				if (nums[i] == nums[j]) {
					pairFound = true;
					nums[j] = nums.length;
					break;
				}
			}
			if (!pairFound) {
				singleNumber = nums[i];
				break;
			}
		}
		System.out.println("N: " + nums.length + " - loop: " + count);
		return singleNumber;
	}

	public static int findSingle(int[] nums) {
		int[] firstHalf = new int[1 + nums.length / 2];
		int[] secondHalf = new int[1 + nums.length / 2];
		int firstHalfIndex = 0;
		int secondHalfIndex = 0;
		for (int num : nums) {
			if (num % 2 == 0) 
				firstHalf[firstHalfIndex++] = num;
			else
				secondHalf[secondHalfIndex++] = num;
		}
		if(firstHalfIndex > secondHalfIndex) {
			
		}else {
			
		}
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2022-10-10 02:57:38.199
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2022-10-10 02:57:38.199
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-10 02:57:38.349
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.Scanner;

public class MainDay3 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

		// SINGLE NUMBER
		int[] nums1 = { 2, 2, 1 };
		int[] nums2 = { 4, 1, 2, 1, 2 };
		int[] nums3 = { 1 };
		int[] nums4 = { 6, 3, 1, 7, 2, 5, 8, 4 };
		int[] nums5 = { 1, 2, 3, 4, 5, 6, 5, 6, 4, 3, 2, 1, 7 };
		1 3 5 5 3 1 7 a b c b c a d 2a+2b
		2 4 6 6 4 2
		
		System.out.println("Average: " + findSingle(nums5));
//		mergeSort(nums5);
//		System.out.println("Sorted array: " + Arrays.toString(nums5));
//		System.out.println("Single number: " + findSingleNumber(nums5));
//		 PRIME NUMBER
//		int[] numbers = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };
//		for (int num : numbers) {
//			System.out.println("Is " + num + " a Prime number? " + isPrimeNumber(num));
//		}
		// PALINDROME
//		int[] intArr = { 1, 1, 1, 1 };
//		System.out.println("Is Palindrome: " + isPalindrome(intArr));
		// MIN MAX AVERAGE
//		int[] intArr = { 4, 6, 2, 1, 7, 9, 10, 15, 0 };
//		int min = intArr[0];
//		int max = intArr[0];
//		double average = 0;
//		for (int i = 0; i < intArr.length; i++) {
//			if (intArr[i] > max)
//				max = intArr[i];
//			if (intArr[i] < min)
//				min = intArr[i];
//			average += intArr[i];
//		}
//		System.out.println("Min is: " + min);
//		System.out.println("Max is: " + max);
//		System.out.println("Average is: " + Math.ceil(average * 100.00 / intArr.length) / 100.00);

		// GRADE
//		Scanner scanner = new Scanner(System.in);
//		System.out.println("Please enter your average point of Maths: ");
//		Double mathsPoint = scanner.nextDouble();
//		System.out.println("Your Maths Grade is: " + getGrade(mathsPoint));
//		System.out.println("Please enter your average point of English: ");
//		Double englishPoint = scanner.nextDouble();
//		System.out.println("Your English Grade is: " + getGrade(englishPoint));
//		System.out.println("Please enter your average point of Literature: ");
//		Double literaturePoint = scanner.nextDouble();
//		System.out.println("Your Literature Grade is: " + getGrade(literaturePoint));
//
//		Double averagePoint = Math.ceil((mathsPoint + englishPoint + literaturePoint) * 100.00 / 3) / 100.00;
//		System.out.println("Your Average Point is: " + averagePoint);
//
//		Double minPoint = (mathsPoint > englishPoint) ? englishPoint : mathsPoint;
//		minPoint = (minPoint > literaturePoint) ? literaturePoint : minPoint;
//		char grade;
//		if (minPoint < 5) {
//			grade = 'F';
//		} else if (averagePoint - minPoint > 1) {
//			grade = getGrade(minPoint + 1);
//			System.out.println("Your Grade is: " + grade);
//
//		} else {
//			grade = getGrade(averagePoint);
//			System.out.println("Your Grade is: " + grade);
//		}
//		switch (grade) {
//		case 'S':
//			System.out.println("Excellent Student");
//			break;
//		case 'A':
//			System.out.println("Good Student");
//			break;
//		case 'B':
//			System.out.println("Normal Student");
//			break;
//		case 'C':
//			System.out.println("Average Student");
//			break;
//		case 'D':
//			System.out.println("Not Bad Student");
//			break;
//		case 'F':
//			System.out.println("Fail Student");
//			break;
//		}
//		scanner.close();
	}

	public static char getGrade(double point) {
		if (point >= 9)
			return 'S';
		else if (point >= 8)
			return 'A';
		else if (point >= 7)
			return 'B';
		else if (point >= 6)
			return 'C';
		else if (point >= 5)
			return 'D';
		else
			return 'F';
	}

	public static boolean isPalindrome(int[] numbers) {
		if (numbers.length == 0)
			return false;
		else if (numbers.length == 1)
			return true;
		else {
			for (int i = 0; i < numbers.length / 2; i++) {
				if (numbers[i] != numbers[numbers.length - 1 - i])
					return false;
			}
			return true;
		}
	}

	// upgraded. Chi can chay toi 1 + number/2 la dc roi
	public static boolean isPrimeNumber(int number) {
		if (number <= 0)
			return false;
		else if (number <= 2)
			return true;
		else {
			for (int i = 2; i < 1 + number / 2; i++) {
				if (number % i == 0)
					return false;
			}
			return true;
		}
	}

	public static void mergeSort(int[] nums) {
		// chia doi nums thanh nums1 va nums2
		int endIndex = nums.length - 1;
		int middleIndex = nums.length / 2;
		int firstHalfArrSize = middleIndex;
		int secondHalArrSize = endIndex - middleIndex + 1;
		int[] firstHalfArr = new int[firstHalfArrSize];
		int[] secondHalfArr = new int[secondHalArrSize];
		// copy qua 2 sub array
		for (int i = 0; i < firstHalfArrSize; i++) {
			firstHalfArr[i] = nums[i];
		}
		for (int i = 0; i < secondHalArrSize; i++) {
			secondHalfArr[i] = nums[i + firstHalfArrSize];
		}
		// tiep tuc goi recursive cho toi khi nums.length = 1 moi bat dau swap
		// vay tu nums.length de chia xuong con 1 thi se co' log2(nums.length) lan chia
		// lan chia dau tien ton 1 effort
		// lan chia thu 2 ton 2 effort
		// lan chia thu 3 ton 4 effort
		// lan chia thu log2(nums.length) ton 2^(log2(nums.length) - 1) effort
		// vay tong cong ton 2^0 + 2^1 + 2^2 +..+ 2^(log2(nums.length)-1) effort de goi
		// recursive
		if (firstHalfArrSize > 1)
			mergeSort(firstHalfArr);
		if (secondHalArrSize > 1)
			mergeSort(secondHalfArr);
		// merge 2 sorted subarray
		int firstArrCurrentIndex = 0;
		int secondArrCurrentIndex = 0;
		int currentNumsArrIndex = 0;
		// loop qua 2 sub array de compare va copy qua nums cho toi khi finish 1 trong 2
		// cai array
		// moi recursive se loop qua firstHalf va secondHalf, tuc la nums.length effort
		// co log2(nums.length) level, vay tong cong ton log2(nums.length) * nums.length
		// effort
		while ((firstArrCurrentIndex < firstHalfArrSize) && (secondArrCurrentIndex < secondHalArrSize)) {
			if (firstHalfArr[firstArrCurrentIndex] <= secondHalfArr[secondArrCurrentIndex]) {
				nums[currentNumsArrIndex++] = firstHalfArr[firstArrCurrentIndex++];
			} else {
				nums[currentNumsArrIndex++] = secondHalfArr[secondArrCurrentIndex++];
			}
		}
		// copy phan con lai cua 1 trong 2 cai array qua nums
		if (firstArrCurrentIndex < firstHalfArrSize) {
			nums[currentNumsArrIndex++] = firstHalfArr[firstArrCurrentIndex++];
		} else if (secondArrCurrentIndex < secondHalArrSize) {
			nums[currentNumsArrIndex++] = secondHalfArr[secondArrCurrentIndex++];
		}
		// vay tong cong se ton 2^0 + 2^1 + ... + 2^(log2(nums.length)-1) +
		// log2(nums.length) * nums.length effort
	}

	public static int findSingleNumber(int[] nums) {
		// vi array da sort nen worst cua findSingleNumber la 1 + nums.length / 2
		// vay tong cong effot de tim so single la 2^0 + 2^1 + ... +
		// 2^(log2(nums.length)-1) + log2(nums.length) * nums.length + 1 + nums.length /
		// 2
		int singleNumber = nums[0];
		if (nums.length == 1)
			return singleNumber;
		for (int i = 1; i < nums.length; i++) {
			if (singleNumber == nums[i])
				singleNumber = nums[++i];
			else
				return singleNumber;
		}
		return singleNumber;
	}

	public static int singleNumber(int[] nums) {
		int singleNumber = nums[0];
		int count = 0;
		for (int i = 0; i < nums.length; i++) {
			if (nums[i] == nums.length)
				continue;
			boolean pairFound = false;
			for (int j = i + 1; j < nums.length; j++) {
				System.out.println(Arrays.toString(nums));
				count++;
				if (nums[i] == nums[j]) {
					pairFound = true;
					nums[j] = nums.length;
					break;
				}
			}
			if (!pairFound) {
				singleNumber = nums[i];
				break;
			}
		}
		System.out.println("N: " + nums.length + " - loop: " + count);
		return singleNumber;
	}

	public static int findSingle(int[] nums) {
		int[] firstHalf = new int[1 + nums.length / 2];
		int[] secondHalf = new int[1 + nums.length / 2];
		int firstHalfIndex = 0;
		int secondHalfIndex = 0;
		for (int num : nums) {
			if (num % 2 == 0) 
				firstHalf[firstHalfIndex++] = num;
			else
				secondHalf[secondHalfIndex++] = num;
		}
		if(firstHalfIndex > secondHalfIndex) {
			
		}else {
			
		}
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-10-10 02:57:38.350
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-10-10 02:57:38.350
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-10 02:57:38.958
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.Scanner;

public class MainDay3 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

		// SINGLE NUMBER
		int[] nums1 = { 2, 2, 1 };
		int[] nums2 = { 4, 1, 2, 1, 2 };
		int[] nums3 = { 1 };
		int[] nums4 = { 6, 3, 1, 7, 2, 5, 8, 4 };
		int[] nums5 = { 1, 2, 3, 4, 5, 6, 5, 6, 4, 3, 2, 1, 7 };
		1 3 5 5 3 1 7 a b c b c a d 2a+2b+
		2 4 6 6 4 2
		
		System.out.println("Average: " + findSingle(nums5));
//		mergeSort(nums5);
//		System.out.println("Sorted array: " + Arrays.toString(nums5));
//		System.out.println("Single number: " + findSingleNumber(nums5));
//		 PRIME NUMBER
//		int[] numbers = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };
//		for (int num : numbers) {
//			System.out.println("Is " + num + " a Prime number? " + isPrimeNumber(num));
//		}
		// PALINDROME
//		int[] intArr = { 1, 1, 1, 1 };
//		System.out.println("Is Palindrome: " + isPalindrome(intArr));
		// MIN MAX AVERAGE
//		int[] intArr = { 4, 6, 2, 1, 7, 9, 10, 15, 0 };
//		int min = intArr[0];
//		int max = intArr[0];
//		double average = 0;
//		for (int i = 0; i < intArr.length; i++) {
//			if (intArr[i] > max)
//				max = intArr[i];
//			if (intArr[i] < min)
//				min = intArr[i];
//			average += intArr[i];
//		}
//		System.out.println("Min is: " + min);
//		System.out.println("Max is: " + max);
//		System.out.println("Average is: " + Math.ceil(average * 100.00 / intArr.length) / 100.00);

		// GRADE
//		Scanner scanner = new Scanner(System.in);
//		System.out.println("Please enter your average point of Maths: ");
//		Double mathsPoint = scanner.nextDouble();
//		System.out.println("Your Maths Grade is: " + getGrade(mathsPoint));
//		System.out.println("Please enter your average point of English: ");
//		Double englishPoint = scanner.nextDouble();
//		System.out.println("Your English Grade is: " + getGrade(englishPoint));
//		System.out.println("Please enter your average point of Literature: ");
//		Double literaturePoint = scanner.nextDouble();
//		System.out.println("Your Literature Grade is: " + getGrade(literaturePoint));
//
//		Double averagePoint = Math.ceil((mathsPoint + englishPoint + literaturePoint) * 100.00 / 3) / 100.00;
//		System.out.println("Your Average Point is: " + averagePoint);
//
//		Double minPoint = (mathsPoint > englishPoint) ? englishPoint : mathsPoint;
//		minPoint = (minPoint > literaturePoint) ? literaturePoint : minPoint;
//		char grade;
//		if (minPoint < 5) {
//			grade = 'F';
//		} else if (averagePoint - minPoint > 1) {
//			grade = getGrade(minPoint + 1);
//			System.out.println("Your Grade is: " + grade);
//
//		} else {
//			grade = getGrade(averagePoint);
//			System.out.println("Your Grade is: " + grade);
//		}
//		switch (grade) {
//		case 'S':
//			System.out.println("Excellent Student");
//			break;
//		case 'A':
//			System.out.println("Good Student");
//			break;
//		case 'B':
//			System.out.println("Normal Student");
//			break;
//		case 'C':
//			System.out.println("Average Student");
//			break;
//		case 'D':
//			System.out.println("Not Bad Student");
//			break;
//		case 'F':
//			System.out.println("Fail Student");
//			break;
//		}
//		scanner.close();
	}

	public static char getGrade(double point) {
		if (point >= 9)
			return 'S';
		else if (point >= 8)
			return 'A';
		else if (point >= 7)
			return 'B';
		else if (point >= 6)
			return 'C';
		else if (point >= 5)
			return 'D';
		else
			return 'F';
	}

	public static boolean isPalindrome(int[] numbers) {
		if (numbers.length == 0)
			return false;
		else if (numbers.length == 1)
			return true;
		else {
			for (int i = 0; i < numbers.length / 2; i++) {
				if (numbers[i] != numbers[numbers.length - 1 - i])
					return false;
			}
			return true;
		}
	}

	// upgraded. Chi can chay toi 1 + number/2 la dc roi
	public static boolean isPrimeNumber(int number) {
		if (number <= 0)
			return false;
		else if (number <= 2)
			return true;
		else {
			for (int i = 2; i < 1 + number / 2; i++) {
				if (number % i == 0)
					return false;
			}
			return true;
		}
	}

	public static void mergeSort(int[] nums) {
		// chia doi nums thanh nums1 va nums2
		int endIndex = nums.length - 1;
		int middleIndex = nums.length / 2;
		int firstHalfArrSize = middleIndex;
		int secondHalArrSize = endIndex - middleIndex + 1;
		int[] firstHalfArr = new int[firstHalfArrSize];
		int[] secondHalfArr = new int[secondHalArrSize];
		// copy qua 2 sub array
		for (int i = 0; i < firstHalfArrSize; i++) {
			firstHalfArr[i] = nums[i];
		}
		for (int i = 0; i < secondHalArrSize; i++) {
			secondHalfArr[i] = nums[i + firstHalfArrSize];
		}
		// tiep tuc goi recursive cho toi khi nums.length = 1 moi bat dau swap
		// vay tu nums.length de chia xuong con 1 thi se co' log2(nums.length) lan chia
		// lan chia dau tien ton 1 effort
		// lan chia thu 2 ton 2 effort
		// lan chia thu 3 ton 4 effort
		// lan chia thu log2(nums.length) ton 2^(log2(nums.length) - 1) effort
		// vay tong cong ton 2^0 + 2^1 + 2^2 +..+ 2^(log2(nums.length)-1) effort de goi
		// recursive
		if (firstHalfArrSize > 1)
			mergeSort(firstHalfArr);
		if (secondHalArrSize > 1)
			mergeSort(secondHalfArr);
		// merge 2 sorted subarray
		int firstArrCurrentIndex = 0;
		int secondArrCurrentIndex = 0;
		int currentNumsArrIndex = 0;
		// loop qua 2 sub array de compare va copy qua nums cho toi khi finish 1 trong 2
		// cai array
		// moi recursive se loop qua firstHalf va secondHalf, tuc la nums.length effort
		// co log2(nums.length) level, vay tong cong ton log2(nums.length) * nums.length
		// effort
		while ((firstArrCurrentIndex < firstHalfArrSize) && (secondArrCurrentIndex < secondHalArrSize)) {
			if (firstHalfArr[firstArrCurrentIndex] <= secondHalfArr[secondArrCurrentIndex]) {
				nums[currentNumsArrIndex++] = firstHalfArr[firstArrCurrentIndex++];
			} else {
				nums[currentNumsArrIndex++] = secondHalfArr[secondArrCurrentIndex++];
			}
		}
		// copy phan con lai cua 1 trong 2 cai array qua nums
		if (firstArrCurrentIndex < firstHalfArrSize) {
			nums[currentNumsArrIndex++] = firstHalfArr[firstArrCurrentIndex++];
		} else if (secondArrCurrentIndex < secondHalArrSize) {
			nums[currentNumsArrIndex++] = secondHalfArr[secondArrCurrentIndex++];
		}
		// vay tong cong se ton 2^0 + 2^1 + ... + 2^(log2(nums.length)-1) +
		// log2(nums.length) * nums.length effort
	}

	public static int findSingleNumber(int[] nums) {
		// vi array da sort nen worst cua findSingleNumber la 1 + nums.length / 2
		// vay tong cong effot de tim so single la 2^0 + 2^1 + ... +
		// 2^(log2(nums.length)-1) + log2(nums.length) * nums.length + 1 + nums.length /
		// 2
		int singleNumber = nums[0];
		if (nums.length == 1)
			return singleNumber;
		for (int i = 1; i < nums.length; i++) {
			if (singleNumber == nums[i])
				singleNumber = nums[++i];
			else
				return singleNumber;
		}
		return singleNumber;
	}

	public static int singleNumber(int[] nums) {
		int singleNumber = nums[0];
		int count = 0;
		for (int i = 0; i < nums.length; i++) {
			if (nums[i] == nums.length)
				continue;
			boolean pairFound = false;
			for (int j = i + 1; j < nums.length; j++) {
				System.out.println(Arrays.toString(nums));
				count++;
				if (nums[i] == nums[j]) {
					pairFound = true;
					nums[j] = nums.length;
					break;
				}
			}
			if (!pairFound) {
				singleNumber = nums[i];
				break;
			}
		}
		System.out.println("N: " + nums.length + " - loop: " + count);
		return singleNumber;
	}

	public static int findSingle(int[] nums) {
		int[] firstHalf = new int[1 + nums.length / 2];
		int[] secondHalf = new int[1 + nums.length / 2];
		int firstHalfIndex = 0;
		int secondHalfIndex = 0;
		for (int num : nums) {
			if (num % 2 == 0) 
				firstHalf[firstHalfIndex++] = num;
			else
				secondHalf[secondHalfIndex++] = num;
		}
		if(firstHalfIndex > secondHalfIndex) {
			
		}else {
			
		}
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2022-10-10 02:57:38.959
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2022-10-10 02:57:38.959
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-10 02:57:39.149
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.Scanner;

public class MainDay3 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

		// SINGLE NUMBER
		int[] nums1 = { 2, 2, 1 };
		int[] nums2 = { 4, 1, 2, 1, 2 };
		int[] nums3 = { 1 };
		int[] nums4 = { 6, 3, 1, 7, 2, 5, 8, 4 };
		int[] nums5 = { 1, 2, 3, 4, 5, 6, 5, 6, 4, 3, 2, 1, 7 };
		1 3 5 5 3 1 7 a b c b c a d 2a+2b+2
		2 4 6 6 4 2
		
		System.out.println("Average: " + findSingle(nums5));
//		mergeSort(nums5);
//		System.out.println("Sorted array: " + Arrays.toString(nums5));
//		System.out.println("Single number: " + findSingleNumber(nums5));
//		 PRIME NUMBER
//		int[] numbers = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };
//		for (int num : numbers) {
//			System.out.println("Is " + num + " a Prime number? " + isPrimeNumber(num));
//		}
		// PALINDROME
//		int[] intArr = { 1, 1, 1, 1 };
//		System.out.println("Is Palindrome: " + isPalindrome(intArr));
		// MIN MAX AVERAGE
//		int[] intArr = { 4, 6, 2, 1, 7, 9, 10, 15, 0 };
//		int min = intArr[0];
//		int max = intArr[0];
//		double average = 0;
//		for (int i = 0; i < intArr.length; i++) {
//			if (intArr[i] > max)
//				max = intArr[i];
//			if (intArr[i] < min)
//				min = intArr[i];
//			average += intArr[i];
//		}
//		System.out.println("Min is: " + min);
//		System.out.println("Max is: " + max);
//		System.out.println("Average is: " + Math.ceil(average * 100.00 / intArr.length) / 100.00);

		// GRADE
//		Scanner scanner = new Scanner(System.in);
//		System.out.println("Please enter your average point of Maths: ");
//		Double mathsPoint = scanner.nextDouble();
//		System.out.println("Your Maths Grade is: " + getGrade(mathsPoint));
//		System.out.println("Please enter your average point of English: ");
//		Double englishPoint = scanner.nextDouble();
//		System.out.println("Your English Grade is: " + getGrade(englishPoint));
//		System.out.println("Please enter your average point of Literature: ");
//		Double literaturePoint = scanner.nextDouble();
//		System.out.println("Your Literature Grade is: " + getGrade(literaturePoint));
//
//		Double averagePoint = Math.ceil((mathsPoint + englishPoint + literaturePoint) * 100.00 / 3) / 100.00;
//		System.out.println("Your Average Point is: " + averagePoint);
//
//		Double minPoint = (mathsPoint > englishPoint) ? englishPoint : mathsPoint;
//		minPoint = (minPoint > literaturePoint) ? literaturePoint : minPoint;
//		char grade;
//		if (minPoint < 5) {
//			grade = 'F';
//		} else if (averagePoint - minPoint > 1) {
//			grade = getGrade(minPoint + 1);
//			System.out.println("Your Grade is: " + grade);
//
//		} else {
//			grade = getGrade(averagePoint);
//			System.out.println("Your Grade is: " + grade);
//		}
//		switch (grade) {
//		case 'S':
//			System.out.println("Excellent Student");
//			break;
//		case 'A':
//			System.out.println("Good Student");
//			break;
//		case 'B':
//			System.out.println("Normal Student");
//			break;
//		case 'C':
//			System.out.println("Average Student");
//			break;
//		case 'D':
//			System.out.println("Not Bad Student");
//			break;
//		case 'F':
//			System.out.println("Fail Student");
//			break;
//		}
//		scanner.close();
	}

	public static char getGrade(double point) {
		if (point >= 9)
			return 'S';
		else if (point >= 8)
			return 'A';
		else if (point >= 7)
			return 'B';
		else if (point >= 6)
			return 'C';
		else if (point >= 5)
			return 'D';
		else
			return 'F';
	}

	public static boolean isPalindrome(int[] numbers) {
		if (numbers.length == 0)
			return false;
		else if (numbers.length == 1)
			return true;
		else {
			for (int i = 0; i < numbers.length / 2; i++) {
				if (numbers[i] != numbers[numbers.length - 1 - i])
					return false;
			}
			return true;
		}
	}

	// upgraded. Chi can chay toi 1 + number/2 la dc roi
	public static boolean isPrimeNumber(int number) {
		if (number <= 0)
			return false;
		else if (number <= 2)
			return true;
		else {
			for (int i = 2; i < 1 + number / 2; i++) {
				if (number % i == 0)
					return false;
			}
			return true;
		}
	}

	public static void mergeSort(int[] nums) {
		// chia doi nums thanh nums1 va nums2
		int endIndex = nums.length - 1;
		int middleIndex = nums.length / 2;
		int firstHalfArrSize = middleIndex;
		int secondHalArrSize = endIndex - middleIndex + 1;
		int[] firstHalfArr = new int[firstHalfArrSize];
		int[] secondHalfArr = new int[secondHalArrSize];
		// copy qua 2 sub array
		for (int i = 0; i < firstHalfArrSize; i++) {
			firstHalfArr[i] = nums[i];
		}
		for (int i = 0; i < secondHalArrSize; i++) {
			secondHalfArr[i] = nums[i + firstHalfArrSize];
		}
		// tiep tuc goi recursive cho toi khi nums.length = 1 moi bat dau swap
		// vay tu nums.length de chia xuong con 1 thi se co' log2(nums.length) lan chia
		// lan chia dau tien ton 1 effort
		// lan chia thu 2 ton 2 effort
		// lan chia thu 3 ton 4 effort
		// lan chia thu log2(nums.length) ton 2^(log2(nums.length) - 1) effort
		// vay tong cong ton 2^0 + 2^1 + 2^2 +..+ 2^(log2(nums.length)-1) effort de goi
		// recursive
		if (firstHalfArrSize > 1)
			mergeSort(firstHalfArr);
		if (secondHalArrSize > 1)
			mergeSort(secondHalfArr);
		// merge 2 sorted subarray
		int firstArrCurrentIndex = 0;
		int secondArrCurrentIndex = 0;
		int currentNumsArrIndex = 0;
		// loop qua 2 sub array de compare va copy qua nums cho toi khi finish 1 trong 2
		// cai array
		// moi recursive se loop qua firstHalf va secondHalf, tuc la nums.length effort
		// co log2(nums.length) level, vay tong cong ton log2(nums.length) * nums.length
		// effort
		while ((firstArrCurrentIndex < firstHalfArrSize) && (secondArrCurrentIndex < secondHalArrSize)) {
			if (firstHalfArr[firstArrCurrentIndex] <= secondHalfArr[secondArrCurrentIndex]) {
				nums[currentNumsArrIndex++] = firstHalfArr[firstArrCurrentIndex++];
			} else {
				nums[currentNumsArrIndex++] = secondHalfArr[secondArrCurrentIndex++];
			}
		}
		// copy phan con lai cua 1 trong 2 cai array qua nums
		if (firstArrCurrentIndex < firstHalfArrSize) {
			nums[currentNumsArrIndex++] = firstHalfArr[firstArrCurrentIndex++];
		} else if (secondArrCurrentIndex < secondHalArrSize) {
			nums[currentNumsArrIndex++] = secondHalfArr[secondArrCurrentIndex++];
		}
		// vay tong cong se ton 2^0 + 2^1 + ... + 2^(log2(nums.length)-1) +
		// log2(nums.length) * nums.length effort
	}

	public static int findSingleNumber(int[] nums) {
		// vi array da sort nen worst cua findSingleNumber la 1 + nums.length / 2
		// vay tong cong effot de tim so single la 2^0 + 2^1 + ... +
		// 2^(log2(nums.length)-1) + log2(nums.length) * nums.length + 1 + nums.length /
		// 2
		int singleNumber = nums[0];
		if (nums.length == 1)
			return singleNumber;
		for (int i = 1; i < nums.length; i++) {
			if (singleNumber == nums[i])
				singleNumber = nums[++i];
			else
				return singleNumber;
		}
		return singleNumber;
	}

	public static int singleNumber(int[] nums) {
		int singleNumber = nums[0];
		int count = 0;
		for (int i = 0; i < nums.length; i++) {
			if (nums[i] == nums.length)
				continue;
			boolean pairFound = false;
			for (int j = i + 1; j < nums.length; j++) {
				System.out.println(Arrays.toString(nums));
				count++;
				if (nums[i] == nums[j]) {
					pairFound = true;
					nums[j] = nums.length;
					break;
				}
			}
			if (!pairFound) {
				singleNumber = nums[i];
				break;
			}
		}
		System.out.println("N: " + nums.length + " - loop: " + count);
		return singleNumber;
	}

	public static int findSingle(int[] nums) {
		int[] firstHalf = new int[1 + nums.length / 2];
		int[] secondHalf = new int[1 + nums.length / 2];
		int firstHalfIndex = 0;
		int secondHalfIndex = 0;
		for (int num : nums) {
			if (num % 2 == 0) 
				firstHalf[firstHalfIndex++] = num;
			else
				secondHalf[secondHalfIndex++] = num;
		}
		if(firstHalfIndex > secondHalfIndex) {
			
		}else {
			
		}
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2022-10-10 02:57:39.150
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2022-10-10 02:57:39.154
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-10 02:57:39.160
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.Scanner;

public class MainDay3 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

		// SINGLE NUMBER
		int[] nums1 = { 2, 2, 1 };
		int[] nums2 = { 4, 1, 2, 1, 2 };
		int[] nums3 = { 1 };
		int[] nums4 = { 6, 3, 1, 7, 2, 5, 8, 4 };
		int[] nums5 = { 1, 2, 3, 4, 5, 6, 5, 6, 4, 3, 2, 1, 7 };
		1 3 5 5 3 1 7 a b c b c a d 2a+2b+2
		2 4 6 6 4 2
		
		System.out.println("Average: " + findSingle(nums5));
//		mergeSort(nums5);
//		System.out.println("Sorted array: " + Arrays.toString(nums5));
//		System.out.println("Single number: " + findSingleNumber(nums5));
//		 PRIME NUMBER
//		int[] numbers = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };
//		for (int num : numbers) {
//			System.out.println("Is " + num + " a Prime number? " + isPrimeNumber(num));
//		}
		// PALINDROME
//		int[] intArr = { 1, 1, 1, 1 };
//		System.out.println("Is Palindrome: " + isPalindrome(intArr));
		// MIN MAX AVERAGE
//		int[] intArr = { 4, 6, 2, 1, 7, 9, 10, 15, 0 };
//		int min = intArr[0];
//		int max = intArr[0];
//		double average = 0;
//		for (int i = 0; i < intArr.length; i++) {
//			if (intArr[i] > max)
//				max = intArr[i];
//			if (intArr[i] < min)
//				min = intArr[i];
//			average += intArr[i];
//		}
//		System.out.println("Min is: " + min);
//		System.out.println("Max is: " + max);
//		System.out.println("Average is: " + Math.ceil(average * 100.00 / intArr.length) / 100.00);

		// GRADE
//		Scanner scanner = new Scanner(System.in);
//		System.out.println("Please enter your average point of Maths: ");
//		Double mathsPoint = scanner.nextDouble();
//		System.out.println("Your Maths Grade is: " + getGrade(mathsPoint));
//		System.out.println("Please enter your average point of English: ");
//		Double englishPoint = scanner.nextDouble();
//		System.out.println("Your English Grade is: " + getGrade(englishPoint));
//		System.out.println("Please enter your average point of Literature: ");
//		Double literaturePoint = scanner.nextDouble();
//		System.out.println("Your Literature Grade is: " + getGrade(literaturePoint));
//
//		Double averagePoint = Math.ceil((mathsPoint + englishPoint + literaturePoint) * 100.00 / 3) / 100.00;
//		System.out.println("Your Average Point is: " + averagePoint);
//
//		Double minPoint = (mathsPoint > englishPoint) ? englishPoint : mathsPoint;
//		minPoint = (minPoint > literaturePoint) ? literaturePoint : minPoint;
//		char grade;
//		if (minPoint < 5) {
//			grade = 'F';
//		} else if (averagePoint - minPoint > 1) {
//			grade = getGrade(minPoint + 1);
//			System.out.println("Your Grade is: " + grade);
//
//		} else {
//			grade = getGrade(averagePoint);
//			System.out.println("Your Grade is: " + grade);
//		}
//		switch (grade) {
//		case 'S':
//			System.out.println("Excellent Student");
//			break;
//		case 'A':
//			System.out.println("Good Student");
//			break;
//		case 'B':
//			System.out.println("Normal Student");
//			break;
//		case 'C':
//			System.out.println("Average Student");
//			break;
//		case 'D':
//			System.out.println("Not Bad Student");
//			break;
//		case 'F':
//			System.out.println("Fail Student");
//			break;
//		}
//		scanner.close();
	}

	public static char getGrade(double point) {
		if (point >= 9)
			return 'S';
		else if (point >= 8)
			return 'A';
		else if (point >= 7)
			return 'B';
		else if (point >= 6)
			return 'C';
		else if (point >= 5)
			return 'D';
		else
			return 'F';
	}

	public static boolean isPalindrome(int[] numbers) {
		if (numbers.length == 0)
			return false;
		else if (numbers.length == 1)
			return true;
		else {
			for (int i = 0; i < numbers.length / 2; i++) {
				if (numbers[i] != numbers[numbers.length - 1 - i])
					return false;
			}
			return true;
		}
	}

	// upgraded. Chi can chay toi 1 + number/2 la dc roi
	public static boolean isPrimeNumber(int number) {
		if (number <= 0)
			return false;
		else if (number <= 2)
			return true;
		else {
			for (int i = 2; i < 1 + number / 2; i++) {
				if (number % i == 0)
					return false;
			}
			return true;
		}
	}

	public static void mergeSort(int[] nums) {
		// chia doi nums thanh nums1 va nums2
		int endIndex = nums.length - 1;
		int middleIndex = nums.length / 2;
		int firstHalfArrSize = middleIndex;
		int secondHalArrSize = endIndex - middleIndex + 1;
		int[] firstHalfArr = new int[firstHalfArrSize];
		int[] secondHalfArr = new int[secondHalArrSize];
		// copy qua 2 sub array
		for (int i = 0; i < firstHalfArrSize; i++) {
			firstHalfArr[i] = nums[i];
		}
		for (int i = 0; i < secondHalArrSize; i++) {
			secondHalfArr[i] = nums[i + firstHalfArrSize];
		}
		// tiep tuc goi recursive cho toi khi nums.length = 1 moi bat dau swap
		// vay tu nums.length de chia xuong con 1 thi se co' log2(nums.length) lan chia
		// lan chia dau tien ton 1 effort
		// lan chia thu 2 ton 2 effort
		// lan chia thu 3 ton 4 effort
		// lan chia thu log2(nums.length) ton 2^(log2(nums.length) - 1) effort
		// vay tong cong ton 2^0 + 2^1 + 2^2 +..+ 2^(log2(nums.length)-1) effort de goi
		// recursive
		if (firstHalfArrSize > 1)
			mergeSort(firstHalfArr);
		if (secondHalArrSize > 1)
			mergeSort(secondHalfArr);
		// merge 2 sorted subarray
		int firstArrCurrentIndex = 0;
		int secondArrCurrentIndex = 0;
		int currentNumsArrIndex = 0;
		// loop qua 2 sub array de compare va copy qua nums cho toi khi finish 1 trong 2
		// cai array
		// moi recursive se loop qua firstHalf va secondHalf, tuc la nums.length effort
		// co log2(nums.length) level, vay tong cong ton log2(nums.length) * nums.length
		// effort
		while ((firstArrCurrentIndex < firstHalfArrSize) && (secondArrCurrentIndex < secondHalArrSize)) {
			if (firstHalfArr[firstArrCurrentIndex] <= secondHalfArr[secondArrCurrentIndex]) {
				nums[currentNumsArrIndex++] = firstHalfArr[firstArrCurrentIndex++];
			} else {
				nums[currentNumsArrIndex++] = secondHalfArr[secondArrCurrentIndex++];
			}
		}
		// copy phan con lai cua 1 trong 2 cai array qua nums
		if (firstArrCurrentIndex < firstHalfArrSize) {
			nums[currentNumsArrIndex++] = firstHalfArr[firstArrCurrentIndex++];
		} else if (secondArrCurrentIndex < secondHalArrSize) {
			nums[currentNumsArrIndex++] = secondHalfArr[secondArrCurrentIndex++];
		}
		// vay tong cong se ton 2^0 + 2^1 + ... + 2^(log2(nums.length)-1) +
		// log2(nums.length) * nums.length effort
	}

	public static int findSingleNumber(int[] nums) {
		// vi array da sort nen worst cua findSingleNumber la 1 + nums.length / 2
		// vay tong cong effot de tim so single la 2^0 + 2^1 + ... +
		// 2^(log2(nums.length)-1) + log2(nums.length) * nums.length + 1 + nums.length /
		// 2
		int singleNumber = nums[0];
		if (nums.length == 1)
			return singleNumber;
		for (int i = 1; i < nums.length; i++) {
			if (singleNumber == nums[i])
				singleNumber = nums[++i];
			else
				return singleNumber;
		}
		return singleNumber;
	}

	public static int singleNumber(int[] nums) {
		int singleNumber = nums[0];
		int count = 0;
		for (int i = 0; i < nums.length; i++) {
			if (nums[i] == nums.length)
				continue;
			boolean pairFound = false;
			for (int j = i + 1; j < nums.length; j++) {
				System.out.println(Arrays.toString(nums));
				count++;
				if (nums[i] == nums[j]) {
					pairFound = true;
					nums[j] = nums.length;
					break;
				}
			}
			if (!pairFound) {
				singleNumber = nums[i];
				break;
			}
		}
		System.out.println("N: " + nums.length + " - loop: " + count);
		return singleNumber;
	}

	public static int findSingle(int[] nums) {
		int[] firstHalf = new int[1 + nums.length / 2];
		int[] secondHalf = new int[1 + nums.length / 2];
		int firstHalfIndex = 0;
		int secondHalfIndex = 0;
		for (int num : nums) {
			if (num % 2 == 0) 
				firstHalf[firstHalfIndex++] = num;
			else
				secondHalf[secondHalfIndex++] = num;
		}
		if(firstHalfIndex > secondHalfIndex) {
			
		}else {
			
		}
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-10-10 02:57:39.161
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-10-10 02:57:39.162
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-10 02:57:39.945
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.Scanner;

public class MainDay3 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

		// SINGLE NUMBER
		int[] nums1 = { 2, 2, 1 };
		int[] nums2 = { 4, 1, 2, 1, 2 };
		int[] nums3 = { 1 };
		int[] nums4 = { 6, 3, 1, 7, 2, 5, 8, 4 };
		int[] nums5 = { 1, 2, 3, 4, 5, 6, 5, 6, 4, 3, 2, 1, 7 };
		1 3 5 5 3 1 7 a b c b c a d 2a+2b+2c
		2 4 6 6 4 2
		
		System.out.println("Average: " + findSingle(nums5));
//		mergeSort(nums5);
//		System.out.println("Sorted array: " + Arrays.toString(nums5));
//		System.out.println("Single number: " + findSingleNumber(nums5));
//		 PRIME NUMBER
//		int[] numbers = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };
//		for (int num : numbers) {
//			System.out.println("Is " + num + " a Prime number? " + isPrimeNumber(num));
//		}
		// PALINDROME
//		int[] intArr = { 1, 1, 1, 1 };
//		System.out.println("Is Palindrome: " + isPalindrome(intArr));
		// MIN MAX AVERAGE
//		int[] intArr = { 4, 6, 2, 1, 7, 9, 10, 15, 0 };
//		int min = intArr[0];
//		int max = intArr[0];
//		double average = 0;
//		for (int i = 0; i < intArr.length; i++) {
//			if (intArr[i] > max)
//				max = intArr[i];
//			if (intArr[i] < min)
//				min = intArr[i];
//			average += intArr[i];
//		}
//		System.out.println("Min is: " + min);
//		System.out.println("Max is: " + max);
//		System.out.println("Average is: " + Math.ceil(average * 100.00 / intArr.length) / 100.00);

		// GRADE
//		Scanner scanner = new Scanner(System.in);
//		System.out.println("Please enter your average point of Maths: ");
//		Double mathsPoint = scanner.nextDouble();
//		System.out.println("Your Maths Grade is: " + getGrade(mathsPoint));
//		System.out.println("Please enter your average point of English: ");
//		Double englishPoint = scanner.nextDouble();
//		System.out.println("Your English Grade is: " + getGrade(englishPoint));
//		System.out.println("Please enter your average point of Literature: ");
//		Double literaturePoint = scanner.nextDouble();
//		System.out.println("Your Literature Grade is: " + getGrade(literaturePoint));
//
//		Double averagePoint = Math.ceil((mathsPoint + englishPoint + literaturePoint) * 100.00 / 3) / 100.00;
//		System.out.println("Your Average Point is: " + averagePoint);
//
//		Double minPoint = (mathsPoint > englishPoint) ? englishPoint : mathsPoint;
//		minPoint = (minPoint > literaturePoint) ? literaturePoint : minPoint;
//		char grade;
//		if (minPoint < 5) {
//			grade = 'F';
//		} else if (averagePoint - minPoint > 1) {
//			grade = getGrade(minPoint + 1);
//			System.out.println("Your Grade is: " + grade);
//
//		} else {
//			grade = getGrade(averagePoint);
//			System.out.println("Your Grade is: " + grade);
//		}
//		switch (grade) {
//		case 'S':
//			System.out.println("Excellent Student");
//			break;
//		case 'A':
//			System.out.println("Good Student");
//			break;
//		case 'B':
//			System.out.println("Normal Student");
//			break;
//		case 'C':
//			System.out.println("Average Student");
//			break;
//		case 'D':
//			System.out.println("Not Bad Student");
//			break;
//		case 'F':
//			System.out.println("Fail Student");
//			break;
//		}
//		scanner.close();
	}

	public static char getGrade(double point) {
		if (point >= 9)
			return 'S';
		else if (point >= 8)
			return 'A';
		else if (point >= 7)
			return 'B';
		else if (point >= 6)
			return 'C';
		else if (point >= 5)
			return 'D';
		else
			return 'F';
	}

	public static boolean isPalindrome(int[] numbers) {
		if (numbers.length == 0)
			return false;
		else if (numbers.length == 1)
			return true;
		else {
			for (int i = 0; i < numbers.length / 2; i++) {
				if (numbers[i] != numbers[numbers.length - 1 - i])
					return false;
			}
			return true;
		}
	}

	// upgraded. Chi can chay toi 1 + number/2 la dc roi
	public static boolean isPrimeNumber(int number) {
		if (number <= 0)
			return false;
		else if (number <= 2)
			return true;
		else {
			for (int i = 2; i < 1 + number / 2; i++) {
				if (number % i == 0)
					return false;
			}
			return true;
		}
	}

	public static void mergeSort(int[] nums) {
		// chia doi nums thanh nums1 va nums2
		int endIndex = nums.length - 1;
		int middleIndex = nums.length / 2;
		int firstHalfArrSize = middleIndex;
		int secondHalArrSize = endIndex - middleIndex + 1;
		int[] firstHalfArr = new int[firstHalfArrSize];
		int[] secondHalfArr = new int[secondHalArrSize];
		// copy qua 2 sub array
		for (int i = 0; i < firstHalfArrSize; i++) {
			firstHalfArr[i] = nums[i];
		}
		for (int i = 0; i < secondHalArrSize; i++) {
			secondHalfArr[i] = nums[i + firstHalfArrSize];
		}
		// tiep tuc goi recursive cho toi khi nums.length = 1 moi bat dau swap
		// vay tu nums.length de chia xuong con 1 thi se co' log2(nums.length) lan chia
		// lan chia dau tien ton 1 effort
		// lan chia thu 2 ton 2 effort
		// lan chia thu 3 ton 4 effort
		// lan chia thu log2(nums.length) ton 2^(log2(nums.length) - 1) effort
		// vay tong cong ton 2^0 + 2^1 + 2^2 +..+ 2^(log2(nums.length)-1) effort de goi
		// recursive
		if (firstHalfArrSize > 1)
			mergeSort(firstHalfArr);
		if (secondHalArrSize > 1)
			mergeSort(secondHalfArr);
		// merge 2 sorted subarray
		int firstArrCurrentIndex = 0;
		int secondArrCurrentIndex = 0;
		int currentNumsArrIndex = 0;
		// loop qua 2 sub array de compare va copy qua nums cho toi khi finish 1 trong 2
		// cai array
		// moi recursive se loop qua firstHalf va secondHalf, tuc la nums.length effort
		// co log2(nums.length) level, vay tong cong ton log2(nums.length) * nums.length
		// effort
		while ((firstArrCurrentIndex < firstHalfArrSize) && (secondArrCurrentIndex < secondHalArrSize)) {
			if (firstHalfArr[firstArrCurrentIndex] <= secondHalfArr[secondArrCurrentIndex]) {
				nums[currentNumsArrIndex++] = firstHalfArr[firstArrCurrentIndex++];
			} else {
				nums[currentNumsArrIndex++] = secondHalfArr[secondArrCurrentIndex++];
			}
		}
		// copy phan con lai cua 1 trong 2 cai array qua nums
		if (firstArrCurrentIndex < firstHalfArrSize) {
			nums[currentNumsArrIndex++] = firstHalfArr[firstArrCurrentIndex++];
		} else if (secondArrCurrentIndex < secondHalArrSize) {
			nums[currentNumsArrIndex++] = secondHalfArr[secondArrCurrentIndex++];
		}
		// vay tong cong se ton 2^0 + 2^1 + ... + 2^(log2(nums.length)-1) +
		// log2(nums.length) * nums.length effort
	}

	public static int findSingleNumber(int[] nums) {
		// vi array da sort nen worst cua findSingleNumber la 1 + nums.length / 2
		// vay tong cong effot de tim so single la 2^0 + 2^1 + ... +
		// 2^(log2(nums.length)-1) + log2(nums.length) * nums.length + 1 + nums.length /
		// 2
		int singleNumber = nums[0];
		if (nums.length == 1)
			return singleNumber;
		for (int i = 1; i < nums.length; i++) {
			if (singleNumber == nums[i])
				singleNumber = nums[++i];
			else
				return singleNumber;
		}
		return singleNumber;
	}

	public static int singleNumber(int[] nums) {
		int singleNumber = nums[0];
		int count = 0;
		for (int i = 0; i < nums.length; i++) {
			if (nums[i] == nums.length)
				continue;
			boolean pairFound = false;
			for (int j = i + 1; j < nums.length; j++) {
				System.out.println(Arrays.toString(nums));
				count++;
				if (nums[i] == nums[j]) {
					pairFound = true;
					nums[j] = nums.length;
					break;
				}
			}
			if (!pairFound) {
				singleNumber = nums[i];
				break;
			}
		}
		System.out.println("N: " + nums.length + " - loop: " + count);
		return singleNumber;
	}

	public static int findSingle(int[] nums) {
		int[] firstHalf = new int[1 + nums.length / 2];
		int[] secondHalf = new int[1 + nums.length / 2];
		int firstHalfIndex = 0;
		int secondHalfIndex = 0;
		for (int num : nums) {
			if (num % 2 == 0) 
				firstHalf[firstHalfIndex++] = num;
			else
				secondHalf[secondHalfIndex++] = num;
		}
		if(firstHalfIndex > secondHalfIndex) {
			
		}else {
			
		}
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2022-10-10 02:57:39.945
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2022-10-10 02:57:39.946
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-10 02:57:40.099
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.Scanner;

public class MainDay3 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

		// SINGLE NUMBER
		int[] nums1 = { 2, 2, 1 };
		int[] nums2 = { 4, 1, 2, 1, 2 };
		int[] nums3 = { 1 };
		int[] nums4 = { 6, 3, 1, 7, 2, 5, 8, 4 };
		int[] nums5 = { 1, 2, 3, 4, 5, 6, 5, 6, 4, 3, 2, 1, 7 };
		1 3 5 5 3 1 7 a b c b c a d 2a+2b+2c
		2 4 6 6 4 2
		
		System.out.println("Average: " + findSingle(nums5));
//		mergeSort(nums5);
//		System.out.println("Sorted array: " + Arrays.toString(nums5));
//		System.out.println("Single number: " + findSingleNumber(nums5));
//		 PRIME NUMBER
//		int[] numbers = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };
//		for (int num : numbers) {
//			System.out.println("Is " + num + " a Prime number? " + isPrimeNumber(num));
//		}
		// PALINDROME
//		int[] intArr = { 1, 1, 1, 1 };
//		System.out.println("Is Palindrome: " + isPalindrome(intArr));
		// MIN MAX AVERAGE
//		int[] intArr = { 4, 6, 2, 1, 7, 9, 10, 15, 0 };
//		int min = intArr[0];
//		int max = intArr[0];
//		double average = 0;
//		for (int i = 0; i < intArr.length; i++) {
//			if (intArr[i] > max)
//				max = intArr[i];
//			if (intArr[i] < min)
//				min = intArr[i];
//			average += intArr[i];
//		}
//		System.out.println("Min is: " + min);
//		System.out.println("Max is: " + max);
//		System.out.println("Average is: " + Math.ceil(average * 100.00 / intArr.length) / 100.00);

		// GRADE
//		Scanner scanner = new Scanner(System.in);
//		System.out.println("Please enter your average point of Maths: ");
//		Double mathsPoint = scanner.nextDouble();
//		System.out.println("Your Maths Grade is: " + getGrade(mathsPoint));
//		System.out.println("Please enter your average point of English: ");
//		Double englishPoint = scanner.nextDouble();
//		System.out.println("Your English Grade is: " + getGrade(englishPoint));
//		System.out.println("Please enter your average point of Literature: ");
//		Double literaturePoint = scanner.nextDouble();
//		System.out.println("Your Literature Grade is: " + getGrade(literaturePoint));
//
//		Double averagePoint = Math.ceil((mathsPoint + englishPoint + literaturePoint) * 100.00 / 3) / 100.00;
//		System.out.println("Your Average Point is: " + averagePoint);
//
//		Double minPoint = (mathsPoint > englishPoint) ? englishPoint : mathsPoint;
//		minPoint = (minPoint > literaturePoint) ? literaturePoint : minPoint;
//		char grade;
//		if (minPoint < 5) {
//			grade = 'F';
//		} else if (averagePoint - minPoint > 1) {
//			grade = getGrade(minPoint + 1);
//			System.out.println("Your Grade is: " + grade);
//
//		} else {
//			grade = getGrade(averagePoint);
//			System.out.println("Your Grade is: " + grade);
//		}
//		switch (grade) {
//		case 'S':
//			System.out.println("Excellent Student");
//			break;
//		case 'A':
//			System.out.println("Good Student");
//			break;
//		case 'B':
//			System.out.println("Normal Student");
//			break;
//		case 'C':
//			System.out.println("Average Student");
//			break;
//		case 'D':
//			System.out.println("Not Bad Student");
//			break;
//		case 'F':
//			System.out.println("Fail Student");
//			break;
//		}
//		scanner.close();
	}

	public static char getGrade(double point) {
		if (point >= 9)
			return 'S';
		else if (point >= 8)
			return 'A';
		else if (point >= 7)
			return 'B';
		else if (point >= 6)
			return 'C';
		else if (point >= 5)
			return 'D';
		else
			return 'F';
	}

	public static boolean isPalindrome(int[] numbers) {
		if (numbers.length == 0)
			return false;
		else if (numbers.length == 1)
			return true;
		else {
			for (int i = 0; i < numbers.length / 2; i++) {
				if (numbers[i] != numbers[numbers.length - 1 - i])
					return false;
			}
			return true;
		}
	}

	// upgraded. Chi can chay toi 1 + number/2 la dc roi
	public static boolean isPrimeNumber(int number) {
		if (number <= 0)
			return false;
		else if (number <= 2)
			return true;
		else {
			for (int i = 2; i < 1 + number / 2; i++) {
				if (number % i == 0)
					return false;
			}
			return true;
		}
	}

	public static void mergeSort(int[] nums) {
		// chia doi nums thanh nums1 va nums2
		int endIndex = nums.length - 1;
		int middleIndex = nums.length / 2;
		int firstHalfArrSize = middleIndex;
		int secondHalArrSize = endIndex - middleIndex + 1;
		int[] firstHalfArr = new int[firstHalfArrSize];
		int[] secondHalfArr = new int[secondHalArrSize];
		// copy qua 2 sub array
		for (int i = 0; i < firstHalfArrSize; i++) {
			firstHalfArr[i] = nums[i];
		}
		for (int i = 0; i < secondHalArrSize; i++) {
			secondHalfArr[i] = nums[i + firstHalfArrSize];
		}
		// tiep tuc goi recursive cho toi khi nums.length = 1 moi bat dau swap
		// vay tu nums.length de chia xuong con 1 thi se co' log2(nums.length) lan chia
		// lan chia dau tien ton 1 effort
		// lan chia thu 2 ton 2 effort
		// lan chia thu 3 ton 4 effort
		// lan chia thu log2(nums.length) ton 2^(log2(nums.length) - 1) effort
		// vay tong cong ton 2^0 + 2^1 + 2^2 +..+ 2^(log2(nums.length)-1) effort de goi
		// recursive
		if (firstHalfArrSize > 1)
			mergeSort(firstHalfArr);
		if (secondHalArrSize > 1)
			mergeSort(secondHalfArr);
		// merge 2 sorted subarray
		int firstArrCurrentIndex = 0;
		int secondArrCurrentIndex = 0;
		int currentNumsArrIndex = 0;
		// loop qua 2 sub array de compare va copy qua nums cho toi khi finish 1 trong 2
		// cai array
		// moi recursive se loop qua firstHalf va secondHalf, tuc la nums.length effort
		// co log2(nums.length) level, vay tong cong ton log2(nums.length) * nums.length
		// effort
		while ((firstArrCurrentIndex < firstHalfArrSize) && (secondArrCurrentIndex < secondHalArrSize)) {
			if (firstHalfArr[firstArrCurrentIndex] <= secondHalfArr[secondArrCurrentIndex]) {
				nums[currentNumsArrIndex++] = firstHalfArr[firstArrCurrentIndex++];
			} else {
				nums[currentNumsArrIndex++] = secondHalfArr[secondArrCurrentIndex++];
			}
		}
		// copy phan con lai cua 1 trong 2 cai array qua nums
		if (firstArrCurrentIndex < firstHalfArrSize) {
			nums[currentNumsArrIndex++] = firstHalfArr[firstArrCurrentIndex++];
		} else if (secondArrCurrentIndex < secondHalArrSize) {
			nums[currentNumsArrIndex++] = secondHalfArr[secondArrCurrentIndex++];
		}
		// vay tong cong se ton 2^0 + 2^1 + ... + 2^(log2(nums.length)-1) +
		// log2(nums.length) * nums.length effort
	}

	public static int findSingleNumber(int[] nums) {
		// vi array da sort nen worst cua findSingleNumber la 1 + nums.length / 2
		// vay tong cong effot de tim so single la 2^0 + 2^1 + ... +
		// 2^(log2(nums.length)-1) + log2(nums.length) * nums.length + 1 + nums.length /
		// 2
		int singleNumber = nums[0];
		if (nums.length == 1)
			return singleNumber;
		for (int i = 1; i < nums.length; i++) {
			if (singleNumber == nums[i])
				singleNumber = nums[++i];
			else
				return singleNumber;
		}
		return singleNumber;
	}

	public static int singleNumber(int[] nums) {
		int singleNumber = nums[0];
		int count = 0;
		for (int i = 0; i < nums.length; i++) {
			if (nums[i] == nums.length)
				continue;
			boolean pairFound = false;
			for (int j = i + 1; j < nums.length; j++) {
				System.out.println(Arrays.toString(nums));
				count++;
				if (nums[i] == nums[j]) {
					pairFound = true;
					nums[j] = nums.length;
					break;
				}
			}
			if (!pairFound) {
				singleNumber = nums[i];
				break;
			}
		}
		System.out.println("N: " + nums.length + " - loop: " + count);
		return singleNumber;
	}

	public static int findSingle(int[] nums) {
		int[] firstHalf = new int[1 + nums.length / 2];
		int[] secondHalf = new int[1 + nums.length / 2];
		int firstHalfIndex = 0;
		int secondHalfIndex = 0;
		for (int num : nums) {
			if (num % 2 == 0) 
				firstHalf[firstHalfIndex++] = num;
			else
				secondHalf[secondHalfIndex++] = num;
		}
		if(firstHalfIndex > secondHalfIndex) {
			
		}else {
			
		}
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-10-10 02:57:40.099
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-10-10 02:57:40.100
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-10 02:57:40.994
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.Scanner;

public class MainDay3 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

		// SINGLE NUMBER
		int[] nums1 = { 2, 2, 1 };
		int[] nums2 = { 4, 1, 2, 1, 2 };
		int[] nums3 = { 1 };
		int[] nums4 = { 6, 3, 1, 7, 2, 5, 8, 4 };
		int[] nums5 = { 1, 2, 3, 4, 5, 6, 5, 6, 4, 3, 2, 1, 7 };
		1 3 5 5 3 1 7 a b c b c a d 2a+2b+2c+d
		2 4 6 6 4 2
		
		System.out.println("Average: " + findSingle(nums5));
//		mergeSort(nums5);
//		System.out.println("Sorted array: " + Arrays.toString(nums5));
//		System.out.println("Single number: " + findSingleNumber(nums5));
//		 PRIME NUMBER
//		int[] numbers = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };
//		for (int num : numbers) {
//			System.out.println("Is " + num + " a Prime number? " + isPrimeNumber(num));
//		}
		// PALINDROME
//		int[] intArr = { 1, 1, 1, 1 };
//		System.out.println("Is Palindrome: " + isPalindrome(intArr));
		// MIN MAX AVERAGE
//		int[] intArr = { 4, 6, 2, 1, 7, 9, 10, 15, 0 };
//		int min = intArr[0];
//		int max = intArr[0];
//		double average = 0;
//		for (int i = 0; i < intArr.length; i++) {
//			if (intArr[i] > max)
//				max = intArr[i];
//			if (intArr[i] < min)
//				min = intArr[i];
//			average += intArr[i];
//		}
//		System.out.println("Min is: " + min);
//		System.out.println("Max is: " + max);
//		System.out.println("Average is: " + Math.ceil(average * 100.00 / intArr.length) / 100.00);

		// GRADE
//		Scanner scanner = new Scanner(System.in);
//		System.out.println("Please enter your average point of Maths: ");
//		Double mathsPoint = scanner.nextDouble();
//		System.out.println("Your Maths Grade is: " + getGrade(mathsPoint));
//		System.out.println("Please enter your average point of English: ");
//		Double englishPoint = scanner.nextDouble();
//		System.out.println("Your English Grade is: " + getGrade(englishPoint));
//		System.out.println("Please enter your average point of Literature: ");
//		Double literaturePoint = scanner.nextDouble();
//		System.out.println("Your Literature Grade is: " + getGrade(literaturePoint));
//
//		Double averagePoint = Math.ceil((mathsPoint + englishPoint + literaturePoint) * 100.00 / 3) / 100.00;
//		System.out.println("Your Average Point is: " + averagePoint);
//
//		Double minPoint = (mathsPoint > englishPoint) ? englishPoint : mathsPoint;
//		minPoint = (minPoint > literaturePoint) ? literaturePoint : minPoint;
//		char grade;
//		if (minPoint < 5) {
//			grade = 'F';
//		} else if (averagePoint - minPoint > 1) {
//			grade = getGrade(minPoint + 1);
//			System.out.println("Your Grade is: " + grade);
//
//		} else {
//			grade = getGrade(averagePoint);
//			System.out.println("Your Grade is: " + grade);
//		}
//		switch (grade) {
//		case 'S':
//			System.out.println("Excellent Student");
//			break;
//		case 'A':
//			System.out.println("Good Student");
//			break;
//		case 'B':
//			System.out.println("Normal Student");
//			break;
//		case 'C':
//			System.out.println("Average Student");
//			break;
//		case 'D':
//			System.out.println("Not Bad Student");
//			break;
//		case 'F':
//			System.out.println("Fail Student");
//			break;
//		}
//		scanner.close();
	}

	public static char getGrade(double point) {
		if (point >= 9)
			return 'S';
		else if (point >= 8)
			return 'A';
		else if (point >= 7)
			return 'B';
		else if (point >= 6)
			return 'C';
		else if (point >= 5)
			return 'D';
		else
			return 'F';
	}

	public static boolean isPalindrome(int[] numbers) {
		if (numbers.length == 0)
			return false;
		else if (numbers.length == 1)
			return true;
		else {
			for (int i = 0; i < numbers.length / 2; i++) {
				if (numbers[i] != numbers[numbers.length - 1 - i])
					return false;
			}
			return true;
		}
	}

	// upgraded. Chi can chay toi 1 + number/2 la dc roi
	public static boolean isPrimeNumber(int number) {
		if (number <= 0)
			return false;
		else if (number <= 2)
			return true;
		else {
			for (int i = 2; i < 1 + number / 2; i++) {
				if (number % i == 0)
					return false;
			}
			return true;
		}
	}

	public static void mergeSort(int[] nums) {
		// chia doi nums thanh nums1 va nums2
		int endIndex = nums.length - 1;
		int middleIndex = nums.length / 2;
		int firstHalfArrSize = middleIndex;
		int secondHalArrSize = endIndex - middleIndex + 1;
		int[] firstHalfArr = new int[firstHalfArrSize];
		int[] secondHalfArr = new int[secondHalArrSize];
		// copy qua 2 sub array
		for (int i = 0; i < firstHalfArrSize; i++) {
			firstHalfArr[i] = nums[i];
		}
		for (int i = 0; i < secondHalArrSize; i++) {
			secondHalfArr[i] = nums[i + firstHalfArrSize];
		}
		// tiep tuc goi recursive cho toi khi nums.length = 1 moi bat dau swap
		// vay tu nums.length de chia xuong con 1 thi se co' log2(nums.length) lan chia
		// lan chia dau tien ton 1 effort
		// lan chia thu 2 ton 2 effort
		// lan chia thu 3 ton 4 effort
		// lan chia thu log2(nums.length) ton 2^(log2(nums.length) - 1) effort
		// vay tong cong ton 2^0 + 2^1 + 2^2 +..+ 2^(log2(nums.length)-1) effort de goi
		// recursive
		if (firstHalfArrSize > 1)
			mergeSort(firstHalfArr);
		if (secondHalArrSize > 1)
			mergeSort(secondHalfArr);
		// merge 2 sorted subarray
		int firstArrCurrentIndex = 0;
		int secondArrCurrentIndex = 0;
		int currentNumsArrIndex = 0;
		// loop qua 2 sub array de compare va copy qua nums cho toi khi finish 1 trong 2
		// cai array
		// moi recursive se loop qua firstHalf va secondHalf, tuc la nums.length effort
		// co log2(nums.length) level, vay tong cong ton log2(nums.length) * nums.length
		// effort
		while ((firstArrCurrentIndex < firstHalfArrSize) && (secondArrCurrentIndex < secondHalArrSize)) {
			if (firstHalfArr[firstArrCurrentIndex] <= secondHalfArr[secondArrCurrentIndex]) {
				nums[currentNumsArrIndex++] = firstHalfArr[firstArrCurrentIndex++];
			} else {
				nums[currentNumsArrIndex++] = secondHalfArr[secondArrCurrentIndex++];
			}
		}
		// copy phan con lai cua 1 trong 2 cai array qua nums
		if (firstArrCurrentIndex < firstHalfArrSize) {
			nums[currentNumsArrIndex++] = firstHalfArr[firstArrCurrentIndex++];
		} else if (secondArrCurrentIndex < secondHalArrSize) {
			nums[currentNumsArrIndex++] = secondHalfArr[secondArrCurrentIndex++];
		}
		// vay tong cong se ton 2^0 + 2^1 + ... + 2^(log2(nums.length)-1) +
		// log2(nums.length) * nums.length effort
	}

	public static int findSingleNumber(int[] nums) {
		// vi array da sort nen worst cua findSingleNumber la 1 + nums.length / 2
		// vay tong cong effot de tim so single la 2^0 + 2^1 + ... +
		// 2^(log2(nums.length)-1) + log2(nums.length) * nums.length + 1 + nums.length /
		// 2
		int singleNumber = nums[0];
		if (nums.length == 1)
			return singleNumber;
		for (int i = 1; i < nums.length; i++) {
			if (singleNumber == nums[i])
				singleNumber = nums[++i];
			else
				return singleNumber;
		}
		return singleNumber;
	}

	public static int singleNumber(int[] nums) {
		int singleNumber = nums[0];
		int count = 0;
		for (int i = 0; i < nums.length; i++) {
			if (nums[i] == nums.length)
				continue;
			boolean pairFound = false;
			for (int j = i + 1; j < nums.length; j++) {
				System.out.println(Arrays.toString(nums));
				count++;
				if (nums[i] == nums[j]) {
					pairFound = true;
					nums[j] = nums.length;
					break;
				}
			}
			if (!pairFound) {
				singleNumber = nums[i];
				break;
			}
		}
		System.out.println("N: " + nums.length + " - loop: " + count);
		return singleNumber;
	}

	public static int findSingle(int[] nums) {
		int[] firstHalf = new int[1 + nums.length / 2];
		int[] secondHalf = new int[1 + nums.length / 2];
		int firstHalfIndex = 0;
		int secondHalfIndex = 0;
		for (int num : nums) {
			if (num % 2 == 0) 
				firstHalf[firstHalfIndex++] = num;
			else
				secondHalf[secondHalfIndex++] = num;
		}
		if(firstHalfIndex > secondHalfIndex) {
			
		}else {
			
		}
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2022-10-10 02:57:40.995
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2022-10-10 02:57:40.995
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-10 02:57:41.130
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.Scanner;

public class MainDay3 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

		// SINGLE NUMBER
		int[] nums1 = { 2, 2, 1 };
		int[] nums2 = { 4, 1, 2, 1, 2 };
		int[] nums3 = { 1 };
		int[] nums4 = { 6, 3, 1, 7, 2, 5, 8, 4 };
		int[] nums5 = { 1, 2, 3, 4, 5, 6, 5, 6, 4, 3, 2, 1, 7 };
		1 3 5 5 3 1 7 a b c b c a d 2a+2b+2c+d
		2 4 6 6 4 2
		
		System.out.println("Average: " + findSingle(nums5));
//		mergeSort(nums5);
//		System.out.println("Sorted array: " + Arrays.toString(nums5));
//		System.out.println("Single number: " + findSingleNumber(nums5));
//		 PRIME NUMBER
//		int[] numbers = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };
//		for (int num : numbers) {
//			System.out.println("Is " + num + " a Prime number? " + isPrimeNumber(num));
//		}
		// PALINDROME
//		int[] intArr = { 1, 1, 1, 1 };
//		System.out.println("Is Palindrome: " + isPalindrome(intArr));
		// MIN MAX AVERAGE
//		int[] intArr = { 4, 6, 2, 1, 7, 9, 10, 15, 0 };
//		int min = intArr[0];
//		int max = intArr[0];
//		double average = 0;
//		for (int i = 0; i < intArr.length; i++) {
//			if (intArr[i] > max)
//				max = intArr[i];
//			if (intArr[i] < min)
//				min = intArr[i];
//			average += intArr[i];
//		}
//		System.out.println("Min is: " + min);
//		System.out.println("Max is: " + max);
//		System.out.println("Average is: " + Math.ceil(average * 100.00 / intArr.length) / 100.00);

		// GRADE
//		Scanner scanner = new Scanner(System.in);
//		System.out.println("Please enter your average point of Maths: ");
//		Double mathsPoint = scanner.nextDouble();
//		System.out.println("Your Maths Grade is: " + getGrade(mathsPoint));
//		System.out.println("Please enter your average point of English: ");
//		Double englishPoint = scanner.nextDouble();
//		System.out.println("Your English Grade is: " + getGrade(englishPoint));
//		System.out.println("Please enter your average point of Literature: ");
//		Double literaturePoint = scanner.nextDouble();
//		System.out.println("Your Literature Grade is: " + getGrade(literaturePoint));
//
//		Double averagePoint = Math.ceil((mathsPoint + englishPoint + literaturePoint) * 100.00 / 3) / 100.00;
//		System.out.println("Your Average Point is: " + averagePoint);
//
//		Double minPoint = (mathsPoint > englishPoint) ? englishPoint : mathsPoint;
//		minPoint = (minPoint > literaturePoint) ? literaturePoint : minPoint;
//		char grade;
//		if (minPoint < 5) {
//			grade = 'F';
//		} else if (averagePoint - minPoint > 1) {
//			grade = getGrade(minPoint + 1);
//			System.out.println("Your Grade is: " + grade);
//
//		} else {
//			grade = getGrade(averagePoint);
//			System.out.println("Your Grade is: " + grade);
//		}
//		switch (grade) {
//		case 'S':
//			System.out.println("Excellent Student");
//			break;
//		case 'A':
//			System.out.println("Good Student");
//			break;
//		case 'B':
//			System.out.println("Normal Student");
//			break;
//		case 'C':
//			System.out.println("Average Student");
//			break;
//		case 'D':
//			System.out.println("Not Bad Student");
//			break;
//		case 'F':
//			System.out.println("Fail Student");
//			break;
//		}
//		scanner.close();
	}

	public static char getGrade(double point) {
		if (point >= 9)
			return 'S';
		else if (point >= 8)
			return 'A';
		else if (point >= 7)
			return 'B';
		else if (point >= 6)
			return 'C';
		else if (point >= 5)
			return 'D';
		else
			return 'F';
	}

	public static boolean isPalindrome(int[] numbers) {
		if (numbers.length == 0)
			return false;
		else if (numbers.length == 1)
			return true;
		else {
			for (int i = 0; i < numbers.length / 2; i++) {
				if (numbers[i] != numbers[numbers.length - 1 - i])
					return false;
			}
			return true;
		}
	}

	// upgraded. Chi can chay toi 1 + number/2 la dc roi
	public static boolean isPrimeNumber(int number) {
		if (number <= 0)
			return false;
		else if (number <= 2)
			return true;
		else {
			for (int i = 2; i < 1 + number / 2; i++) {
				if (number % i == 0)
					return false;
			}
			return true;
		}
	}

	public static void mergeSort(int[] nums) {
		// chia doi nums thanh nums1 va nums2
		int endIndex = nums.length - 1;
		int middleIndex = nums.length / 2;
		int firstHalfArrSize = middleIndex;
		int secondHalArrSize = endIndex - middleIndex + 1;
		int[] firstHalfArr = new int[firstHalfArrSize];
		int[] secondHalfArr = new int[secondHalArrSize];
		// copy qua 2 sub array
		for (int i = 0; i < firstHalfArrSize; i++) {
			firstHalfArr[i] = nums[i];
		}
		for (int i = 0; i < secondHalArrSize; i++) {
			secondHalfArr[i] = nums[i + firstHalfArrSize];
		}
		// tiep tuc goi recursive cho toi khi nums.length = 1 moi bat dau swap
		// vay tu nums.length de chia xuong con 1 thi se co' log2(nums.length) lan chia
		// lan chia dau tien ton 1 effort
		// lan chia thu 2 ton 2 effort
		// lan chia thu 3 ton 4 effort
		// lan chia thu log2(nums.length) ton 2^(log2(nums.length) - 1) effort
		// vay tong cong ton 2^0 + 2^1 + 2^2 +..+ 2^(log2(nums.length)-1) effort de goi
		// recursive
		if (firstHalfArrSize > 1)
			mergeSort(firstHalfArr);
		if (secondHalArrSize > 1)
			mergeSort(secondHalfArr);
		// merge 2 sorted subarray
		int firstArrCurrentIndex = 0;
		int secondArrCurrentIndex = 0;
		int currentNumsArrIndex = 0;
		// loop qua 2 sub array de compare va copy qua nums cho toi khi finish 1 trong 2
		// cai array
		// moi recursive se loop qua firstHalf va secondHalf, tuc la nums.length effort
		// co log2(nums.length) level, vay tong cong ton log2(nums.length) * nums.length
		// effort
		while ((firstArrCurrentIndex < firstHalfArrSize) && (secondArrCurrentIndex < secondHalArrSize)) {
			if (firstHalfArr[firstArrCurrentIndex] <= secondHalfArr[secondArrCurrentIndex]) {
				nums[currentNumsArrIndex++] = firstHalfArr[firstArrCurrentIndex++];
			} else {
				nums[currentNumsArrIndex++] = secondHalfArr[secondArrCurrentIndex++];
			}
		}
		// copy phan con lai cua 1 trong 2 cai array qua nums
		if (firstArrCurrentIndex < firstHalfArrSize) {
			nums[currentNumsArrIndex++] = firstHalfArr[firstArrCurrentIndex++];
		} else if (secondArrCurrentIndex < secondHalArrSize) {
			nums[currentNumsArrIndex++] = secondHalfArr[secondArrCurrentIndex++];
		}
		// vay tong cong se ton 2^0 + 2^1 + ... + 2^(log2(nums.length)-1) +
		// log2(nums.length) * nums.length effort
	}

	public static int findSingleNumber(int[] nums) {
		// vi array da sort nen worst cua findSingleNumber la 1 + nums.length / 2
		// vay tong cong effot de tim so single la 2^0 + 2^1 + ... +
		// 2^(log2(nums.length)-1) + log2(nums.length) * nums.length + 1 + nums.length /
		// 2
		int singleNumber = nums[0];
		if (nums.length == 1)
			return singleNumber;
		for (int i = 1; i < nums.length; i++) {
			if (singleNumber == nums[i])
				singleNumber = nums[++i];
			else
				return singleNumber;
		}
		return singleNumber;
	}

	public static int singleNumber(int[] nums) {
		int singleNumber = nums[0];
		int count = 0;
		for (int i = 0; i < nums.length; i++) {
			if (nums[i] == nums.length)
				continue;
			boolean pairFound = false;
			for (int j = i + 1; j < nums.length; j++) {
				System.out.println(Arrays.toString(nums));
				count++;
				if (nums[i] == nums[j]) {
					pairFound = true;
					nums[j] = nums.length;
					break;
				}
			}
			if (!pairFound) {
				singleNumber = nums[i];
				break;
			}
		}
		System.out.println("N: " + nums.length + " - loop: " + count);
		return singleNumber;
	}

	public static int findSingle(int[] nums) {
		int[] firstHalf = new int[1 + nums.length / 2];
		int[] secondHalf = new int[1 + nums.length / 2];
		int firstHalfIndex = 0;
		int secondHalfIndex = 0;
		for (int num : nums) {
			if (num % 2 == 0) 
				firstHalf[firstHalfIndex++] = num;
			else
				secondHalf[secondHalfIndex++] = num;
		}
		if(firstHalfIndex > secondHalfIndex) {
			
		}else {
			
		}
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-10-10 02:57:41.131
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-10-10 02:57:41.131
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-10 02:57:42.580
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.Scanner;

public class MainDay3 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

		// SINGLE NUMBER
		int[] nums1 = { 2, 2, 1 };
		int[] nums2 = { 4, 1, 2, 1, 2 };
		int[] nums3 = { 1 };
		int[] nums4 = { 6, 3, 1, 7, 2, 5, 8, 4 };
		int[] nums5 = { 1, 2, 3, 4, 5, 6, 5, 6, 4, 3, 2, 1, 7 };
		1 3 5 5 3 1 7 a b c b c a d 2a+2b+2c+d =
		2 4 6 6 4 2
		
		System.out.println("Average: " + findSingle(nums5));
//		mergeSort(nums5);
//		System.out.println("Sorted array: " + Arrays.toString(nums5));
//		System.out.println("Single number: " + findSingleNumber(nums5));
//		 PRIME NUMBER
//		int[] numbers = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };
//		for (int num : numbers) {
//			System.out.println("Is " + num + " a Prime number? " + isPrimeNumber(num));
//		}
		// PALINDROME
//		int[] intArr = { 1, 1, 1, 1 };
//		System.out.println("Is Palindrome: " + isPalindrome(intArr));
		// MIN MAX AVERAGE
//		int[] intArr = { 4, 6, 2, 1, 7, 9, 10, 15, 0 };
//		int min = intArr[0];
//		int max = intArr[0];
//		double average = 0;
//		for (int i = 0; i < intArr.length; i++) {
//			if (intArr[i] > max)
//				max = intArr[i];
//			if (intArr[i] < min)
//				min = intArr[i];
//			average += intArr[i];
//		}
//		System.out.println("Min is: " + min);
//		System.out.println("Max is: " + max);
//		System.out.println("Average is: " + Math.ceil(average * 100.00 / intArr.length) / 100.00);

		// GRADE
//		Scanner scanner = new Scanner(System.in);
//		System.out.println("Please enter your average point of Maths: ");
//		Double mathsPoint = scanner.nextDouble();
//		System.out.println("Your Maths Grade is: " + getGrade(mathsPoint));
//		System.out.println("Please enter your average point of English: ");
//		Double englishPoint = scanner.nextDouble();
//		System.out.println("Your English Grade is: " + getGrade(englishPoint));
//		System.out.println("Please enter your average point of Literature: ");
//		Double literaturePoint = scanner.nextDouble();
//		System.out.println("Your Literature Grade is: " + getGrade(literaturePoint));
//
//		Double averagePoint = Math.ceil((mathsPoint + englishPoint + literaturePoint) * 100.00 / 3) / 100.00;
//		System.out.println("Your Average Point is: " + averagePoint);
//
//		Double minPoint = (mathsPoint > englishPoint) ? englishPoint : mathsPoint;
//		minPoint = (minPoint > literaturePoint) ? literaturePoint : minPoint;
//		char grade;
//		if (minPoint < 5) {
//			grade = 'F';
//		} else if (averagePoint - minPoint > 1) {
//			grade = getGrade(minPoint + 1);
//			System.out.println("Your Grade is: " + grade);
//
//		} else {
//			grade = getGrade(averagePoint);
//			System.out.println("Your Grade is: " + grade);
//		}
//		switch (grade) {
//		case 'S':
//			System.out.println("Excellent Student");
//			break;
//		case 'A':
//			System.out.println("Good Student");
//			break;
//		case 'B':
//			System.out.println("Normal Student");
//			break;
//		case 'C':
//			System.out.println("Average Student");
//			break;
//		case 'D':
//			System.out.println("Not Bad Student");
//			break;
//		case 'F':
//			System.out.println("Fail Student");
//			break;
//		}
//		scanner.close();
	}

	public static char getGrade(double point) {
		if (point >= 9)
			return 'S';
		else if (point >= 8)
			return 'A';
		else if (point >= 7)
			return 'B';
		else if (point >= 6)
			return 'C';
		else if (point >= 5)
			return 'D';
		else
			return 'F';
	}

	public static boolean isPalindrome(int[] numbers) {
		if (numbers.length == 0)
			return false;
		else if (numbers.length == 1)
			return true;
		else {
			for (int i = 0; i < numbers.length / 2; i++) {
				if (numbers[i] != numbers[numbers.length - 1 - i])
					return false;
			}
			return true;
		}
	}

	// upgraded. Chi can chay toi 1 + number/2 la dc roi
	public static boolean isPrimeNumber(int number) {
		if (number <= 0)
			return false;
		else if (number <= 2)
			return true;
		else {
			for (int i = 2; i < 1 + number / 2; i++) {
				if (number % i == 0)
					return false;
			}
			return true;
		}
	}

	public static void mergeSort(int[] nums) {
		// chia doi nums thanh nums1 va nums2
		int endIndex = nums.length - 1;
		int middleIndex = nums.length / 2;
		int firstHalfArrSize = middleIndex;
		int secondHalArrSize = endIndex - middleIndex + 1;
		int[] firstHalfArr = new int[firstHalfArrSize];
		int[] secondHalfArr = new int[secondHalArrSize];
		// copy qua 2 sub array
		for (int i = 0; i < firstHalfArrSize; i++) {
			firstHalfArr[i] = nums[i];
		}
		for (int i = 0; i < secondHalArrSize; i++) {
			secondHalfArr[i] = nums[i + firstHalfArrSize];
		}
		// tiep tuc goi recursive cho toi khi nums.length = 1 moi bat dau swap
		// vay tu nums.length de chia xuong con 1 thi se co' log2(nums.length) lan chia
		// lan chia dau tien ton 1 effort
		// lan chia thu 2 ton 2 effort
		// lan chia thu 3 ton 4 effort
		// lan chia thu log2(nums.length) ton 2^(log2(nums.length) - 1) effort
		// vay tong cong ton 2^0 + 2^1 + 2^2 +..+ 2^(log2(nums.length)-1) effort de goi
		// recursive
		if (firstHalfArrSize > 1)
			mergeSort(firstHalfArr);
		if (secondHalArrSize > 1)
			mergeSort(secondHalfArr);
		// merge 2 sorted subarray
		int firstArrCurrentIndex = 0;
		int secondArrCurrentIndex = 0;
		int currentNumsArrIndex = 0;
		// loop qua 2 sub array de compare va copy qua nums cho toi khi finish 1 trong 2
		// cai array
		// moi recursive se loop qua firstHalf va secondHalf, tuc la nums.length effort
		// co log2(nums.length) level, vay tong cong ton log2(nums.length) * nums.length
		// effort
		while ((firstArrCurrentIndex < firstHalfArrSize) && (secondArrCurrentIndex < secondHalArrSize)) {
			if (firstHalfArr[firstArrCurrentIndex] <= secondHalfArr[secondArrCurrentIndex]) {
				nums[currentNumsArrIndex++] = firstHalfArr[firstArrCurrentIndex++];
			} else {
				nums[currentNumsArrIndex++] = secondHalfArr[secondArrCurrentIndex++];
			}
		}
		// copy phan con lai cua 1 trong 2 cai array qua nums
		if (firstArrCurrentIndex < firstHalfArrSize) {
			nums[currentNumsArrIndex++] = firstHalfArr[firstArrCurrentIndex++];
		} else if (secondArrCurrentIndex < secondHalArrSize) {
			nums[currentNumsArrIndex++] = secondHalfArr[secondArrCurrentIndex++];
		}
		// vay tong cong se ton 2^0 + 2^1 + ... + 2^(log2(nums.length)-1) +
		// log2(nums.length) * nums.length effort
	}

	public static int findSingleNumber(int[] nums) {
		// vi array da sort nen worst cua findSingleNumber la 1 + nums.length / 2
		// vay tong cong effot de tim so single la 2^0 + 2^1 + ... +
		// 2^(log2(nums.length)-1) + log2(nums.length) * nums.length + 1 + nums.length /
		// 2
		int singleNumber = nums[0];
		if (nums.length == 1)
			return singleNumber;
		for (int i = 1; i < nums.length; i++) {
			if (singleNumber == nums[i])
				singleNumber = nums[++i];
			else
				return singleNumber;
		}
		return singleNumber;
	}

	public static int singleNumber(int[] nums) {
		int singleNumber = nums[0];
		int count = 0;
		for (int i = 0; i < nums.length; i++) {
			if (nums[i] == nums.length)
				continue;
			boolean pairFound = false;
			for (int j = i + 1; j < nums.length; j++) {
				System.out.println(Arrays.toString(nums));
				count++;
				if (nums[i] == nums[j]) {
					pairFound = true;
					nums[j] = nums.length;
					break;
				}
			}
			if (!pairFound) {
				singleNumber = nums[i];
				break;
			}
		}
		System.out.println("N: " + nums.length + " - loop: " + count);
		return singleNumber;
	}

	public static int findSingle(int[] nums) {
		int[] firstHalf = new int[1 + nums.length / 2];
		int[] secondHalf = new int[1 + nums.length / 2];
		int firstHalfIndex = 0;
		int secondHalfIndex = 0;
		for (int num : nums) {
			if (num % 2 == 0) 
				firstHalf[firstHalfIndex++] = num;
			else
				secondHalf[secondHalfIndex++] = num;
		}
		if(firstHalfIndex > secondHalfIndex) {
			
		}else {
			
		}
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2022-10-10 02:57:42.580
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2022-10-10 02:57:42.581
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-10 02:57:42.663
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.Scanner;

public class MainDay3 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

		// SINGLE NUMBER
		int[] nums1 = { 2, 2, 1 };
		int[] nums2 = { 4, 1, 2, 1, 2 };
		int[] nums3 = { 1 };
		int[] nums4 = { 6, 3, 1, 7, 2, 5, 8, 4 };
		int[] nums5 = { 1, 2, 3, 4, 5, 6, 5, 6, 4, 3, 2, 1, 7 };
		1 3 5 5 3 1 7 a b c b c a d 2a+2b+2c+d =
		2 4 6 6 4 2
		
		System.out.println("Average: " + findSingle(nums5));
//		mergeSort(nums5);
//		System.out.println("Sorted array: " + Arrays.toString(nums5));
//		System.out.println("Single number: " + findSingleNumber(nums5));
//		 PRIME NUMBER
//		int[] numbers = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };
//		for (int num : numbers) {
//			System.out.println("Is " + num + " a Prime number? " + isPrimeNumber(num));
//		}
		// PALINDROME
//		int[] intArr = { 1, 1, 1, 1 };
//		System.out.println("Is Palindrome: " + isPalindrome(intArr));
		// MIN MAX AVERAGE
//		int[] intArr = { 4, 6, 2, 1, 7, 9, 10, 15, 0 };
//		int min = intArr[0];
//		int max = intArr[0];
//		double average = 0;
//		for (int i = 0; i < intArr.length; i++) {
//			if (intArr[i] > max)
//				max = intArr[i];
//			if (intArr[i] < min)
//				min = intArr[i];
//			average += intArr[i];
//		}
//		System.out.println("Min is: " + min);
//		System.out.println("Max is: " + max);
//		System.out.println("Average is: " + Math.ceil(average * 100.00 / intArr.length) / 100.00);

		// GRADE
//		Scanner scanner = new Scanner(System.in);
//		System.out.println("Please enter your average point of Maths: ");
//		Double mathsPoint = scanner.nextDouble();
//		System.out.println("Your Maths Grade is: " + getGrade(mathsPoint));
//		System.out.println("Please enter your average point of English: ");
//		Double englishPoint = scanner.nextDouble();
//		System.out.println("Your English Grade is: " + getGrade(englishPoint));
//		System.out.println("Please enter your average point of Literature: ");
//		Double literaturePoint = scanner.nextDouble();
//		System.out.println("Your Literature Grade is: " + getGrade(literaturePoint));
//
//		Double averagePoint = Math.ceil((mathsPoint + englishPoint + literaturePoint) * 100.00 / 3) / 100.00;
//		System.out.println("Your Average Point is: " + averagePoint);
//
//		Double minPoint = (mathsPoint > englishPoint) ? englishPoint : mathsPoint;
//		minPoint = (minPoint > literaturePoint) ? literaturePoint : minPoint;
//		char grade;
//		if (minPoint < 5) {
//			grade = 'F';
//		} else if (averagePoint - minPoint > 1) {
//			grade = getGrade(minPoint + 1);
//			System.out.println("Your Grade is: " + grade);
//
//		} else {
//			grade = getGrade(averagePoint);
//			System.out.println("Your Grade is: " + grade);
//		}
//		switch (grade) {
//		case 'S':
//			System.out.println("Excellent Student");
//			break;
//		case 'A':
//			System.out.println("Good Student");
//			break;
//		case 'B':
//			System.out.println("Normal Student");
//			break;
//		case 'C':
//			System.out.println("Average Student");
//			break;
//		case 'D':
//			System.out.println("Not Bad Student");
//			break;
//		case 'F':
//			System.out.println("Fail Student");
//			break;
//		}
//		scanner.close();
	}

	public static char getGrade(double point) {
		if (point >= 9)
			return 'S';
		else if (point >= 8)
			return 'A';
		else if (point >= 7)
			return 'B';
		else if (point >= 6)
			return 'C';
		else if (point >= 5)
			return 'D';
		else
			return 'F';
	}

	public static boolean isPalindrome(int[] numbers) {
		if (numbers.length == 0)
			return false;
		else if (numbers.length == 1)
			return true;
		else {
			for (int i = 0; i < numbers.length / 2; i++) {
				if (numbers[i] != numbers[numbers.length - 1 - i])
					return false;
			}
			return true;
		}
	}

	// upgraded. Chi can chay toi 1 + number/2 la dc roi
	public static boolean isPrimeNumber(int number) {
		if (number <= 0)
			return false;
		else if (number <= 2)
			return true;
		else {
			for (int i = 2; i < 1 + number / 2; i++) {
				if (number % i == 0)
					return false;
			}
			return true;
		}
	}

	public static void mergeSort(int[] nums) {
		// chia doi nums thanh nums1 va nums2
		int endIndex = nums.length - 1;
		int middleIndex = nums.length / 2;
		int firstHalfArrSize = middleIndex;
		int secondHalArrSize = endIndex - middleIndex + 1;
		int[] firstHalfArr = new int[firstHalfArrSize];
		int[] secondHalfArr = new int[secondHalArrSize];
		// copy qua 2 sub array
		for (int i = 0; i < firstHalfArrSize; i++) {
			firstHalfArr[i] = nums[i];
		}
		for (int i = 0; i < secondHalArrSize; i++) {
			secondHalfArr[i] = nums[i + firstHalfArrSize];
		}
		// tiep tuc goi recursive cho toi khi nums.length = 1 moi bat dau swap
		// vay tu nums.length de chia xuong con 1 thi se co' log2(nums.length) lan chia
		// lan chia dau tien ton 1 effort
		// lan chia thu 2 ton 2 effort
		// lan chia thu 3 ton 4 effort
		// lan chia thu log2(nums.length) ton 2^(log2(nums.length) - 1) effort
		// vay tong cong ton 2^0 + 2^1 + 2^2 +..+ 2^(log2(nums.length)-1) effort de goi
		// recursive
		if (firstHalfArrSize > 1)
			mergeSort(firstHalfArr);
		if (secondHalArrSize > 1)
			mergeSort(secondHalfArr);
		// merge 2 sorted subarray
		int firstArrCurrentIndex = 0;
		int secondArrCurrentIndex = 0;
		int currentNumsArrIndex = 0;
		// loop qua 2 sub array de compare va copy qua nums cho toi khi finish 1 trong 2
		// cai array
		// moi recursive se loop qua firstHalf va secondHalf, tuc la nums.length effort
		// co log2(nums.length) level, vay tong cong ton log2(nums.length) * nums.length
		// effort
		while ((firstArrCurrentIndex < firstHalfArrSize) && (secondArrCurrentIndex < secondHalArrSize)) {
			if (firstHalfArr[firstArrCurrentIndex] <= secondHalfArr[secondArrCurrentIndex]) {
				nums[currentNumsArrIndex++] = firstHalfArr[firstArrCurrentIndex++];
			} else {
				nums[currentNumsArrIndex++] = secondHalfArr[secondArrCurrentIndex++];
			}
		}
		// copy phan con lai cua 1 trong 2 cai array qua nums
		if (firstArrCurrentIndex < firstHalfArrSize) {
			nums[currentNumsArrIndex++] = firstHalfArr[firstArrCurrentIndex++];
		} else if (secondArrCurrentIndex < secondHalArrSize) {
			nums[currentNumsArrIndex++] = secondHalfArr[secondArrCurrentIndex++];
		}
		// vay tong cong se ton 2^0 + 2^1 + ... + 2^(log2(nums.length)-1) +
		// log2(nums.length) * nums.length effort
	}

	public static int findSingleNumber(int[] nums) {
		// vi array da sort nen worst cua findSingleNumber la 1 + nums.length / 2
		// vay tong cong effot de tim so single la 2^0 + 2^1 + ... +
		// 2^(log2(nums.length)-1) + log2(nums.length) * nums.length + 1 + nums.length /
		// 2
		int singleNumber = nums[0];
		if (nums.length == 1)
			return singleNumber;
		for (int i = 1; i < nums.length; i++) {
			if (singleNumber == nums[i])
				singleNumber = nums[++i];
			else
				return singleNumber;
		}
		return singleNumber;
	}

	public static int singleNumber(int[] nums) {
		int singleNumber = nums[0];
		int count = 0;
		for (int i = 0; i < nums.length; i++) {
			if (nums[i] == nums.length)
				continue;
			boolean pairFound = false;
			for (int j = i + 1; j < nums.length; j++) {
				System.out.println(Arrays.toString(nums));
				count++;
				if (nums[i] == nums[j]) {
					pairFound = true;
					nums[j] = nums.length;
					break;
				}
			}
			if (!pairFound) {
				singleNumber = nums[i];
				break;
			}
		}
		System.out.println("N: " + nums.length + " - loop: " + count);
		return singleNumber;
	}

	public static int findSingle(int[] nums) {
		int[] firstHalf = new int[1 + nums.length / 2];
		int[] secondHalf = new int[1 + nums.length / 2];
		int firstHalfIndex = 0;
		int secondHalfIndex = 0;
		for (int num : nums) {
			if (num % 2 == 0) 
				firstHalf[firstHalfIndex++] = num;
			else
				secondHalf[secondHalfIndex++] = num;
		}
		if(firstHalfIndex > secondHalfIndex) {
			
		}else {
			
		}
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-10-10 02:57:42.664
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-10-10 02:57:42.665
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-10 02:57:44.946
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.Scanner;

public class MainDay3 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

		// SINGLE NUMBER
		int[] nums1 = { 2, 2, 1 };
		int[] nums2 = { 4, 1, 2, 1, 2 };
		int[] nums3 = { 1 };
		int[] nums4 = { 6, 3, 1, 7, 2, 5, 8, 4 };
		int[] nums5 = { 1, 2, 3, 4, 5, 6, 5, 6, 4, 3, 2, 1, 7 };
		1 3 5 5 3 1 7 a b c b c a d 
		2a+2b+2c+d =
		2 4 6 6 4 2
		
		System.out.println("Average: " + findSingle(nums5));
//		mergeSort(nums5);
//		System.out.println("Sorted array: " + Arrays.toString(nums5));
//		System.out.println("Single number: " + findSingleNumber(nums5));
//		 PRIME NUMBER
//		int[] numbers = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };
//		for (int num : numbers) {
//			System.out.println("Is " + num + " a Prime number? " + isPrimeNumber(num));
//		}
		// PALINDROME
//		int[] intArr = { 1, 1, 1, 1 };
//		System.out.println("Is Palindrome: " + isPalindrome(intArr));
		// MIN MAX AVERAGE
//		int[] intArr = { 4, 6, 2, 1, 7, 9, 10, 15, 0 };
//		int min = intArr[0];
//		int max = intArr[0];
//		double average = 0;
//		for (int i = 0; i < intArr.length; i++) {
//			if (intArr[i] > max)
//				max = intArr[i];
//			if (intArr[i] < min)
//				min = intArr[i];
//			average += intArr[i];
//		}
//		System.out.println("Min is: " + min);
//		System.out.println("Max is: " + max);
//		System.out.println("Average is: " + Math.ceil(average * 100.00 / intArr.length) / 100.00);

		// GRADE
//		Scanner scanner = new Scanner(System.in);
//		System.out.println("Please enter your average point of Maths: ");
//		Double mathsPoint = scanner.nextDouble();
//		System.out.println("Your Maths Grade is: " + getGrade(mathsPoint));
//		System.out.println("Please enter your average point of English: ");
//		Double englishPoint = scanner.nextDouble();
//		System.out.println("Your English Grade is: " + getGrade(englishPoint));
//		System.out.println("Please enter your average point of Literature: ");
//		Double literaturePoint = scanner.nextDouble();
//		System.out.println("Your Literature Grade is: " + getGrade(literaturePoint));
//
//		Double averagePoint = Math.ceil((mathsPoint + englishPoint + literaturePoint) * 100.00 / 3) / 100.00;
//		System.out.println("Your Average Point is: " + averagePoint);
//
//		Double minPoint = (mathsPoint > englishPoint) ? englishPoint : mathsPoint;
//		minPoint = (minPoint > literaturePoint) ? literaturePoint : minPoint;
//		char grade;
//		if (minPoint < 5) {
//			grade = 'F';
//		} else if (averagePoint - minPoint > 1) {
//			grade = getGrade(minPoint + 1);
//			System.out.println("Your Grade is: " + grade);
//
//		} else {
//			grade = getGrade(averagePoint);
//			System.out.println("Your Grade is: " + grade);
//		}
//		switch (grade) {
//		case 'S':
//			System.out.println("Excellent Student");
//			break;
//		case 'A':
//			System.out.println("Good Student");
//			break;
//		case 'B':
//			System.out.println("Normal Student");
//			break;
//		case 'C':
//			System.out.println("Average Student");
//			break;
//		case 'D':
//			System.out.println("Not Bad Student");
//			break;
//		case 'F':
//			System.out.println("Fail Student");
//			break;
//		}
//		scanner.close();
	}

	public static char getGrade(double point) {
		if (point >= 9)
			return 'S';
		else if (point >= 8)
			return 'A';
		else if (point >= 7)
			return 'B';
		else if (point >= 6)
			return 'C';
		else if (point >= 5)
			return 'D';
		else
			return 'F';
	}

	public static boolean isPalindrome(int[] numbers) {
		if (numbers.length == 0)
			return false;
		else if (numbers.length == 1)
			return true;
		else {
			for (int i = 0; i < numbers.length / 2; i++) {
				if (numbers[i] != numbers[numbers.length - 1 - i])
					return false;
			}
			return true;
		}
	}

	// upgraded. Chi can chay toi 1 + number/2 la dc roi
	public static boolean isPrimeNumber(int number) {
		if (number <= 0)
			return false;
		else if (number <= 2)
			return true;
		else {
			for (int i = 2; i < 1 + number / 2; i++) {
				if (number % i == 0)
					return false;
			}
			return true;
		}
	}

	public static void mergeSort(int[] nums) {
		// chia doi nums thanh nums1 va nums2
		int endIndex = nums.length - 1;
		int middleIndex = nums.length / 2;
		int firstHalfArrSize = middleIndex;
		int secondHalArrSize = endIndex - middleIndex + 1;
		int[] firstHalfArr = new int[firstHalfArrSize];
		int[] secondHalfArr = new int[secondHalArrSize];
		// copy qua 2 sub array
		for (int i = 0; i < firstHalfArrSize; i++) {
			firstHalfArr[i] = nums[i];
		}
		for (int i = 0; i < secondHalArrSize; i++) {
			secondHalfArr[i] = nums[i + firstHalfArrSize];
		}
		// tiep tuc goi recursive cho toi khi nums.length = 1 moi bat dau swap
		// vay tu nums.length de chia xuong con 1 thi se co' log2(nums.length) lan chia
		// lan chia dau tien ton 1 effort
		// lan chia thu 2 ton 2 effort
		// lan chia thu 3 ton 4 effort
		// lan chia thu log2(nums.length) ton 2^(log2(nums.length) - 1) effort
		// vay tong cong ton 2^0 + 2^1 + 2^2 +..+ 2^(log2(nums.length)-1) effort de goi
		// recursive
		if (firstHalfArrSize > 1)
			mergeSort(firstHalfArr);
		if (secondHalArrSize > 1)
			mergeSort(secondHalfArr);
		// merge 2 sorted subarray
		int firstArrCurrentIndex = 0;
		int secondArrCurrentIndex = 0;
		int currentNumsArrIndex = 0;
		// loop qua 2 sub array de compare va copy qua nums cho toi khi finish 1 trong 2
		// cai array
		// moi recursive se loop qua firstHalf va secondHalf, tuc la nums.length effort
		// co log2(nums.length) level, vay tong cong ton log2(nums.length) * nums.length
		// effort
		while ((firstArrCurrentIndex < firstHalfArrSize) && (secondArrCurrentIndex < secondHalArrSize)) {
			if (firstHalfArr[firstArrCurrentIndex] <= secondHalfArr[secondArrCurrentIndex]) {
				nums[currentNumsArrIndex++] = firstHalfArr[firstArrCurrentIndex++];
			} else {
				nums[currentNumsArrIndex++] = secondHalfArr[secondArrCurrentIndex++];
			}
		}
		// copy phan con lai cua 1 trong 2 cai array qua nums
		if (firstArrCurrentIndex < firstHalfArrSize) {
			nums[currentNumsArrIndex++] = firstHalfArr[firstArrCurrentIndex++];
		} else if (secondArrCurrentIndex < secondHalArrSize) {
			nums[currentNumsArrIndex++] = secondHalfArr[secondArrCurrentIndex++];
		}
		// vay tong cong se ton 2^0 + 2^1 + ... + 2^(log2(nums.length)-1) +
		// log2(nums.length) * nums.length effort
	}

	public static int findSingleNumber(int[] nums) {
		// vi array da sort nen worst cua findSingleNumber la 1 + nums.length / 2
		// vay tong cong effot de tim so single la 2^0 + 2^1 + ... +
		// 2^(log2(nums.length)-1) + log2(nums.length) * nums.length + 1 + nums.length /
		// 2
		int singleNumber = nums[0];
		if (nums.length == 1)
			return singleNumber;
		for (int i = 1; i < nums.length; i++) {
			if (singleNumber == nums[i])
				singleNumber = nums[++i];
			else
				return singleNumber;
		}
		return singleNumber;
	}

	public static int singleNumber(int[] nums) {
		int singleNumber = nums[0];
		int count = 0;
		for (int i = 0; i < nums.length; i++) {
			if (nums[i] == nums.length)
				continue;
			boolean pairFound = false;
			for (int j = i + 1; j < nums.length; j++) {
				System.out.println(Arrays.toString(nums));
				count++;
				if (nums[i] == nums[j]) {
					pairFound = true;
					nums[j] = nums.length;
					break;
				}
			}
			if (!pairFound) {
				singleNumber = nums[i];
				break;
			}
		}
		System.out.println("N: " + nums.length + " - loop: " + count);
		return singleNumber;
	}

	public static int findSingle(int[] nums) {
		int[] firstHalf = new int[1 + nums.length / 2];
		int[] secondHalf = new int[1 + nums.length / 2];
		int firstHalfIndex = 0;
		int secondHalfIndex = 0;
		for (int num : nums) {
			if (num % 2 == 0) 
				firstHalf[firstHalfIndex++] = num;
			else
				secondHalf[secondHalfIndex++] = num;
		}
		if(firstHalfIndex > secondHalfIndex) {
			
		}else {
			
		}
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2022-10-10 02:57:44.946
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2022-10-10 02:57:44.947
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-10 02:57:44.953
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.Scanner;

public class MainDay3 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

		// SINGLE NUMBER
		int[] nums1 = { 2, 2, 1 };
		int[] nums2 = { 4, 1, 2, 1, 2 };
		int[] nums3 = { 1 };
		int[] nums4 = { 6, 3, 1, 7, 2, 5, 8, 4 };
		int[] nums5 = { 1, 2, 3, 4, 5, 6, 5, 6, 4, 3, 2, 1, 7 };
		1 3 5 5 3 1 7 a b c b c a d 
		2a+2b+2c+d =
		2 4 6 6 4 2
		
		System.out.println("Average: " + findSingle(nums5));
//		mergeSort(nums5);
//		System.out.println("Sorted array: " + Arrays.toString(nums5));
//		System.out.println("Single number: " + findSingleNumber(nums5));
//		 PRIME NUMBER
//		int[] numbers = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };
//		for (int num : numbers) {
//			System.out.println("Is " + num + " a Prime number? " + isPrimeNumber(num));
//		}
		// PALINDROME
//		int[] intArr = { 1, 1, 1, 1 };
//		System.out.println("Is Palindrome: " + isPalindrome(intArr));
		// MIN MAX AVERAGE
//		int[] intArr = { 4, 6, 2, 1, 7, 9, 10, 15, 0 };
//		int min = intArr[0];
//		int max = intArr[0];
//		double average = 0;
//		for (int i = 0; i < intArr.length; i++) {
//			if (intArr[i] > max)
//				max = intArr[i];
//			if (intArr[i] < min)
//				min = intArr[i];
//			average += intArr[i];
//		}
//		System.out.println("Min is: " + min);
//		System.out.println("Max is: " + max);
//		System.out.println("Average is: " + Math.ceil(average * 100.00 / intArr.length) / 100.00);

		// GRADE
//		Scanner scanner = new Scanner(System.in);
//		System.out.println("Please enter your average point of Maths: ");
//		Double mathsPoint = scanner.nextDouble();
//		System.out.println("Your Maths Grade is: " + getGrade(mathsPoint));
//		System.out.println("Please enter your average point of English: ");
//		Double englishPoint = scanner.nextDouble();
//		System.out.println("Your English Grade is: " + getGrade(englishPoint));
//		System.out.println("Please enter your average point of Literature: ");
//		Double literaturePoint = scanner.nextDouble();
//		System.out.println("Your Literature Grade is: " + getGrade(literaturePoint));
//
//		Double averagePoint = Math.ceil((mathsPoint + englishPoint + literaturePoint) * 100.00 / 3) / 100.00;
//		System.out.println("Your Average Point is: " + averagePoint);
//
//		Double minPoint = (mathsPoint > englishPoint) ? englishPoint : mathsPoint;
//		minPoint = (minPoint > literaturePoint) ? literaturePoint : minPoint;
//		char grade;
//		if (minPoint < 5) {
//			grade = 'F';
//		} else if (averagePoint - minPoint > 1) {
//			grade = getGrade(minPoint + 1);
//			System.out.println("Your Grade is: " + grade);
//
//		} else {
//			grade = getGrade(averagePoint);
//			System.out.println("Your Grade is: " + grade);
//		}
//		switch (grade) {
//		case 'S':
//			System.out.println("Excellent Student");
//			break;
//		case 'A':
//			System.out.println("Good Student");
//			break;
//		case 'B':
//			System.out.println("Normal Student");
//			break;
//		case 'C':
//			System.out.println("Average Student");
//			break;
//		case 'D':
//			System.out.println("Not Bad Student");
//			break;
//		case 'F':
//			System.out.println("Fail Student");
//			break;
//		}
//		scanner.close();
	}

	public static char getGrade(double point) {
		if (point >= 9)
			return 'S';
		else if (point >= 8)
			return 'A';
		else if (point >= 7)
			return 'B';
		else if (point >= 6)
			return 'C';
		else if (point >= 5)
			return 'D';
		else
			return 'F';
	}

	public static boolean isPalindrome(int[] numbers) {
		if (numbers.length == 0)
			return false;
		else if (numbers.length == 1)
			return true;
		else {
			for (int i = 0; i < numbers.length / 2; i++) {
				if (numbers[i] != numbers[numbers.length - 1 - i])
					return false;
			}
			return true;
		}
	}

	// upgraded. Chi can chay toi 1 + number/2 la dc roi
	public static boolean isPrimeNumber(int number) {
		if (number <= 0)
			return false;
		else if (number <= 2)
			return true;
		else {
			for (int i = 2; i < 1 + number / 2; i++) {
				if (number % i == 0)
					return false;
			}
			return true;
		}
	}

	public static void mergeSort(int[] nums) {
		// chia doi nums thanh nums1 va nums2
		int endIndex = nums.length - 1;
		int middleIndex = nums.length / 2;
		int firstHalfArrSize = middleIndex;
		int secondHalArrSize = endIndex - middleIndex + 1;
		int[] firstHalfArr = new int[firstHalfArrSize];
		int[] secondHalfArr = new int[secondHalArrSize];
		// copy qua 2 sub array
		for (int i = 0; i < firstHalfArrSize; i++) {
			firstHalfArr[i] = nums[i];
		}
		for (int i = 0; i < secondHalArrSize; i++) {
			secondHalfArr[i] = nums[i + firstHalfArrSize];
		}
		// tiep tuc goi recursive cho toi khi nums.length = 1 moi bat dau swap
		// vay tu nums.length de chia xuong con 1 thi se co' log2(nums.length) lan chia
		// lan chia dau tien ton 1 effort
		// lan chia thu 2 ton 2 effort
		// lan chia thu 3 ton 4 effort
		// lan chia thu log2(nums.length) ton 2^(log2(nums.length) - 1) effort
		// vay tong cong ton 2^0 + 2^1 + 2^2 +..+ 2^(log2(nums.length)-1) effort de goi
		// recursive
		if (firstHalfArrSize > 1)
			mergeSort(firstHalfArr);
		if (secondHalArrSize > 1)
			mergeSort(secondHalfArr);
		// merge 2 sorted subarray
		int firstArrCurrentIndex = 0;
		int secondArrCurrentIndex = 0;
		int currentNumsArrIndex = 0;
		// loop qua 2 sub array de compare va copy qua nums cho toi khi finish 1 trong 2
		// cai array
		// moi recursive se loop qua firstHalf va secondHalf, tuc la nums.length effort
		// co log2(nums.length) level, vay tong cong ton log2(nums.length) * nums.length
		// effort
		while ((firstArrCurrentIndex < firstHalfArrSize) && (secondArrCurrentIndex < secondHalArrSize)) {
			if (firstHalfArr[firstArrCurrentIndex] <= secondHalfArr[secondArrCurrentIndex]) {
				nums[currentNumsArrIndex++] = firstHalfArr[firstArrCurrentIndex++];
			} else {
				nums[currentNumsArrIndex++] = secondHalfArr[secondArrCurrentIndex++];
			}
		}
		// copy phan con lai cua 1 trong 2 cai array qua nums
		if (firstArrCurrentIndex < firstHalfArrSize) {
			nums[currentNumsArrIndex++] = firstHalfArr[firstArrCurrentIndex++];
		} else if (secondArrCurrentIndex < secondHalArrSize) {
			nums[currentNumsArrIndex++] = secondHalfArr[secondArrCurrentIndex++];
		}
		// vay tong cong se ton 2^0 + 2^1 + ... + 2^(log2(nums.length)-1) +
		// log2(nums.length) * nums.length effort
	}

	public static int findSingleNumber(int[] nums) {
		// vi array da sort nen worst cua findSingleNumber la 1 + nums.length / 2
		// vay tong cong effot de tim so single la 2^0 + 2^1 + ... +
		// 2^(log2(nums.length)-1) + log2(nums.length) * nums.length + 1 + nums.length /
		// 2
		int singleNumber = nums[0];
		if (nums.length == 1)
			return singleNumber;
		for (int i = 1; i < nums.length; i++) {
			if (singleNumber == nums[i])
				singleNumber = nums[++i];
			else
				return singleNumber;
		}
		return singleNumber;
	}

	public static int singleNumber(int[] nums) {
		int singleNumber = nums[0];
		int count = 0;
		for (int i = 0; i < nums.length; i++) {
			if (nums[i] == nums.length)
				continue;
			boolean pairFound = false;
			for (int j = i + 1; j < nums.length; j++) {
				System.out.println(Arrays.toString(nums));
				count++;
				if (nums[i] == nums[j]) {
					pairFound = true;
					nums[j] = nums.length;
					break;
				}
			}
			if (!pairFound) {
				singleNumber = nums[i];
				break;
			}
		}
		System.out.println("N: " + nums.length + " - loop: " + count);
		return singleNumber;
	}

	public static int findSingle(int[] nums) {
		int[] firstHalf = new int[1 + nums.length / 2];
		int[] secondHalf = new int[1 + nums.length / 2];
		int firstHalfIndex = 0;
		int secondHalfIndex = 0;
		for (int num : nums) {
			if (num % 2 == 0) 
				firstHalf[firstHalfIndex++] = num;
			else
				secondHalf[secondHalfIndex++] = num;
		}
		if(firstHalfIndex > secondHalfIndex) {
			
		}else {
			
		}
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-10-10 02:57:44.954
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-10-10 02:57:44.955
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-10 02:57:47.075
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.Scanner;

public class MainDay3 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

		// SINGLE NUMBER
		int[] nums1 = { 2, 2, 1 };
		int[] nums2 = { 4, 1, 2, 1, 2 };
		int[] nums3 = { 1 };
		int[] nums4 = { 6, 3, 1, 7, 2, 5, 8, 4 };
		int[] nums5 = { 1, 2, 3, 4, 5, 6, 5, 6, 4, 3, 2, 1, 7 };
		1 3 5 5 3 1 7 a b c b c a d 
		2a+2b+2c+d =
		
		2 4 6 6 4 2
		
		System.out.println("Average: " + findSingle(nums5));
//		mergeSort(nums5);
//		System.out.println("Sorted array: " + Arrays.toString(nums5));
//		System.out.println("Single number: " + findSingleNumber(nums5));
//		 PRIME NUMBER
//		int[] numbers = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };
//		for (int num : numbers) {
//			System.out.println("Is " + num + " a Prime number? " + isPrimeNumber(num));
//		}
		// PALINDROME
//		int[] intArr = { 1, 1, 1, 1 };
//		System.out.println("Is Palindrome: " + isPalindrome(intArr));
		// MIN MAX AVERAGE
//		int[] intArr = { 4, 6, 2, 1, 7, 9, 10, 15, 0 };
//		int min = intArr[0];
//		int max = intArr[0];
//		double average = 0;
//		for (int i = 0; i < intArr.length; i++) {
//			if (intArr[i] > max)
//				max = intArr[i];
//			if (intArr[i] < min)
//				min = intArr[i];
//			average += intArr[i];
//		}
//		System.out.println("Min is: " + min);
//		System.out.println("Max is: " + max);
//		System.out.println("Average is: " + Math.ceil(average * 100.00 / intArr.length) / 100.00);

		// GRADE
//		Scanner scanner = new Scanner(System.in);
//		System.out.println("Please enter your average point of Maths: ");
//		Double mathsPoint = scanner.nextDouble();
//		System.out.println("Your Maths Grade is: " + getGrade(mathsPoint));
//		System.out.println("Please enter your average point of English: ");
//		Double englishPoint = scanner.nextDouble();
//		System.out.println("Your English Grade is: " + getGrade(englishPoint));
//		System.out.println("Please enter your average point of Literature: ");
//		Double literaturePoint = scanner.nextDouble();
//		System.out.println("Your Literature Grade is: " + getGrade(literaturePoint));
//
//		Double averagePoint = Math.ceil((mathsPoint + englishPoint + literaturePoint) * 100.00 / 3) / 100.00;
//		System.out.println("Your Average Point is: " + averagePoint);
//
//		Double minPoint = (mathsPoint > englishPoint) ? englishPoint : mathsPoint;
//		minPoint = (minPoint > literaturePoint) ? literaturePoint : minPoint;
//		char grade;
//		if (minPoint < 5) {
//			grade = 'F';
//		} else if (averagePoint - minPoint > 1) {
//			grade = getGrade(minPoint + 1);
//			System.out.println("Your Grade is: " + grade);
//
//		} else {
//			grade = getGrade(averagePoint);
//			System.out.println("Your Grade is: " + grade);
//		}
//		switch (grade) {
//		case 'S':
//			System.out.println("Excellent Student");
//			break;
//		case 'A':
//			System.out.println("Good Student");
//			break;
//		case 'B':
//			System.out.println("Normal Student");
//			break;
//		case 'C':
//			System.out.println("Average Student");
//			break;
//		case 'D':
//			System.out.println("Not Bad Student");
//			break;
//		case 'F':
//			System.out.println("Fail Student");
//			break;
//		}
//		scanner.close();
	}

	public static char getGrade(double point) {
		if (point >= 9)
			return 'S';
		else if (point >= 8)
			return 'A';
		else if (point >= 7)
			return 'B';
		else if (point >= 6)
			return 'C';
		else if (point >= 5)
			return 'D';
		else
			return 'F';
	}

	public static boolean isPalindrome(int[] numbers) {
		if (numbers.length == 0)
			return false;
		else if (numbers.length == 1)
			return true;
		else {
			for (int i = 0; i < numbers.length / 2; i++) {
				if (numbers[i] != numbers[numbers.length - 1 - i])
					return false;
			}
			return true;
		}
	}

	// upgraded. Chi can chay toi 1 + number/2 la dc roi
	public static boolean isPrimeNumber(int number) {
		if (number <= 0)
			return false;
		else if (number <= 2)
			return true;
		else {
			for (int i = 2; i < 1 + number / 2; i++) {
				if (number % i == 0)
					return false;
			}
			return true;
		}
	}

	public static void mergeSort(int[] nums) {
		// chia doi nums thanh nums1 va nums2
		int endIndex = nums.length - 1;
		int middleIndex = nums.length / 2;
		int firstHalfArrSize = middleIndex;
		int secondHalArrSize = endIndex - middleIndex + 1;
		int[] firstHalfArr = new int[firstHalfArrSize];
		int[] secondHalfArr = new int[secondHalArrSize];
		// copy qua 2 sub array
		for (int i = 0; i < firstHalfArrSize; i++) {
			firstHalfArr[i] = nums[i];
		}
		for (int i = 0; i < secondHalArrSize; i++) {
			secondHalfArr[i] = nums[i + firstHalfArrSize];
		}
		// tiep tuc goi recursive cho toi khi nums.length = 1 moi bat dau swap
		// vay tu nums.length de chia xuong con 1 thi se co' log2(nums.length) lan chia
		// lan chia dau tien ton 1 effort
		// lan chia thu 2 ton 2 effort
		// lan chia thu 3 ton 4 effort
		// lan chia thu log2(nums.length) ton 2^(log2(nums.length) - 1) effort
		// vay tong cong ton 2^0 + 2^1 + 2^2 +..+ 2^(log2(nums.length)-1) effort de goi
		// recursive
		if (firstHalfArrSize > 1)
			mergeSort(firstHalfArr);
		if (secondHalArrSize > 1)
			mergeSort(secondHalfArr);
		// merge 2 sorted subarray
		int firstArrCurrentIndex = 0;
		int secondArrCurrentIndex = 0;
		int currentNumsArrIndex = 0;
		// loop qua 2 sub array de compare va copy qua nums cho toi khi finish 1 trong 2
		// cai array
		// moi recursive se loop qua firstHalf va secondHalf, tuc la nums.length effort
		// co log2(nums.length) level, vay tong cong ton log2(nums.length) * nums.length
		// effort
		while ((firstArrCurrentIndex < firstHalfArrSize) && (secondArrCurrentIndex < secondHalArrSize)) {
			if (firstHalfArr[firstArrCurrentIndex] <= secondHalfArr[secondArrCurrentIndex]) {
				nums[currentNumsArrIndex++] = firstHalfArr[firstArrCurrentIndex++];
			} else {
				nums[currentNumsArrIndex++] = secondHalfArr[secondArrCurrentIndex++];
			}
		}
		// copy phan con lai cua 1 trong 2 cai array qua nums
		if (firstArrCurrentIndex < firstHalfArrSize) {
			nums[currentNumsArrIndex++] = firstHalfArr[firstArrCurrentIndex++];
		} else if (secondArrCurrentIndex < secondHalArrSize) {
			nums[currentNumsArrIndex++] = secondHalfArr[secondArrCurrentIndex++];
		}
		// vay tong cong se ton 2^0 + 2^1 + ... + 2^(log2(nums.length)-1) +
		// log2(nums.length) * nums.length effort
	}

	public static int findSingleNumber(int[] nums) {
		// vi array da sort nen worst cua findSingleNumber la 1 + nums.length / 2
		// vay tong cong effot de tim so single la 2^0 + 2^1 + ... +
		// 2^(log2(nums.length)-1) + log2(nums.length) * nums.length + 1 + nums.length /
		// 2
		int singleNumber = nums[0];
		if (nums.length == 1)
			return singleNumber;
		for (int i = 1; i < nums.length; i++) {
			if (singleNumber == nums[i])
				singleNumber = nums[++i];
			else
				return singleNumber;
		}
		return singleNumber;
	}

	public static int singleNumber(int[] nums) {
		int singleNumber = nums[0];
		int count = 0;
		for (int i = 0; i < nums.length; i++) {
			if (nums[i] == nums.length)
				continue;
			boolean pairFound = false;
			for (int j = i + 1; j < nums.length; j++) {
				System.out.println(Arrays.toString(nums));
				count++;
				if (nums[i] == nums[j]) {
					pairFound = true;
					nums[j] = nums.length;
					break;
				}
			}
			if (!pairFound) {
				singleNumber = nums[i];
				break;
			}
		}
		System.out.println("N: " + nums.length + " - loop: " + count);
		return singleNumber;
	}

	public static int findSingle(int[] nums) {
		int[] firstHalf = new int[1 + nums.length / 2];
		int[] secondHalf = new int[1 + nums.length / 2];
		int firstHalfIndex = 0;
		int secondHalfIndex = 0;
		for (int num : nums) {
			if (num % 2 == 0) 
				firstHalf[firstHalfIndex++] = num;
			else
				secondHalf[secondHalfIndex++] = num;
		}
		if(firstHalfIndex > secondHalfIndex) {
			
		}else {
			
		}
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2022-10-10 02:57:47.076
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2022-10-10 02:57:47.076
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-10 02:57:47.146
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.Scanner;

public class MainDay3 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

		// SINGLE NUMBER
		int[] nums1 = { 2, 2, 1 };
		int[] nums2 = { 4, 1, 2, 1, 2 };
		int[] nums3 = { 1 };
		int[] nums4 = { 6, 3, 1, 7, 2, 5, 8, 4 };
		int[] nums5 = { 1, 2, 3, 4, 5, 6, 5, 6, 4, 3, 2, 1, 7 };
		1 3 5 5 3 1 7 a b c b c a d 
		2a+2b+2c+d =
		
		2 4 6 6 4 2
		
		System.out.println("Average: " + findSingle(nums5));
//		mergeSort(nums5);
//		System.out.println("Sorted array: " + Arrays.toString(nums5));
//		System.out.println("Single number: " + findSingleNumber(nums5));
//		 PRIME NUMBER
//		int[] numbers = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };
//		for (int num : numbers) {
//			System.out.println("Is " + num + " a Prime number? " + isPrimeNumber(num));
//		}
		// PALINDROME
//		int[] intArr = { 1, 1, 1, 1 };
//		System.out.println("Is Palindrome: " + isPalindrome(intArr));
		// MIN MAX AVERAGE
//		int[] intArr = { 4, 6, 2, 1, 7, 9, 10, 15, 0 };
//		int min = intArr[0];
//		int max = intArr[0];
//		double average = 0;
//		for (int i = 0; i < intArr.length; i++) {
//			if (intArr[i] > max)
//				max = intArr[i];
//			if (intArr[i] < min)
//				min = intArr[i];
//			average += intArr[i];
//		}
//		System.out.println("Min is: " + min);
//		System.out.println("Max is: " + max);
//		System.out.println("Average is: " + Math.ceil(average * 100.00 / intArr.length) / 100.00);

		// GRADE
//		Scanner scanner = new Scanner(System.in);
//		System.out.println("Please enter your average point of Maths: ");
//		Double mathsPoint = scanner.nextDouble();
//		System.out.println("Your Maths Grade is: " + getGrade(mathsPoint));
//		System.out.println("Please enter your average point of English: ");
//		Double englishPoint = scanner.nextDouble();
//		System.out.println("Your English Grade is: " + getGrade(englishPoint));
//		System.out.println("Please enter your average point of Literature: ");
//		Double literaturePoint = scanner.nextDouble();
//		System.out.println("Your Literature Grade is: " + getGrade(literaturePoint));
//
//		Double averagePoint = Math.ceil((mathsPoint + englishPoint + literaturePoint) * 100.00 / 3) / 100.00;
//		System.out.println("Your Average Point is: " + averagePoint);
//
//		Double minPoint = (mathsPoint > englishPoint) ? englishPoint : mathsPoint;
//		minPoint = (minPoint > literaturePoint) ? literaturePoint : minPoint;
//		char grade;
//		if (minPoint < 5) {
//			grade = 'F';
//		} else if (averagePoint - minPoint > 1) {
//			grade = getGrade(minPoint + 1);
//			System.out.println("Your Grade is: " + grade);
//
//		} else {
//			grade = getGrade(averagePoint);
//			System.out.println("Your Grade is: " + grade);
//		}
//		switch (grade) {
//		case 'S':
//			System.out.println("Excellent Student");
//			break;
//		case 'A':
//			System.out.println("Good Student");
//			break;
//		case 'B':
//			System.out.println("Normal Student");
//			break;
//		case 'C':
//			System.out.println("Average Student");
//			break;
//		case 'D':
//			System.out.println("Not Bad Student");
//			break;
//		case 'F':
//			System.out.println("Fail Student");
//			break;
//		}
//		scanner.close();
	}

	public static char getGrade(double point) {
		if (point >= 9)
			return 'S';
		else if (point >= 8)
			return 'A';
		else if (point >= 7)
			return 'B';
		else if (point >= 6)
			return 'C';
		else if (point >= 5)
			return 'D';
		else
			return 'F';
	}

	public static boolean isPalindrome(int[] numbers) {
		if (numbers.length == 0)
			return false;
		else if (numbers.length == 1)
			return true;
		else {
			for (int i = 0; i < numbers.length / 2; i++) {
				if (numbers[i] != numbers[numbers.length - 1 - i])
					return false;
			}
			return true;
		}
	}

	// upgraded. Chi can chay toi 1 + number/2 la dc roi
	public static boolean isPrimeNumber(int number) {
		if (number <= 0)
			return false;
		else if (number <= 2)
			return true;
		else {
			for (int i = 2; i < 1 + number / 2; i++) {
				if (number % i == 0)
					return false;
			}
			return true;
		}
	}

	public static void mergeSort(int[] nums) {
		// chia doi nums thanh nums1 va nums2
		int endIndex = nums.length - 1;
		int middleIndex = nums.length / 2;
		int firstHalfArrSize = middleIndex;
		int secondHalArrSize = endIndex - middleIndex + 1;
		int[] firstHalfArr = new int[firstHalfArrSize];
		int[] secondHalfArr = new int[secondHalArrSize];
		// copy qua 2 sub array
		for (int i = 0; i < firstHalfArrSize; i++) {
			firstHalfArr[i] = nums[i];
		}
		for (int i = 0; i < secondHalArrSize; i++) {
			secondHalfArr[i] = nums[i + firstHalfArrSize];
		}
		// tiep tuc goi recursive cho toi khi nums.length = 1 moi bat dau swap
		// vay tu nums.length de chia xuong con 1 thi se co' log2(nums.length) lan chia
		// lan chia dau tien ton 1 effort
		// lan chia thu 2 ton 2 effort
		// lan chia thu 3 ton 4 effort
		// lan chia thu log2(nums.length) ton 2^(log2(nums.length) - 1) effort
		// vay tong cong ton 2^0 + 2^1 + 2^2 +..+ 2^(log2(nums.length)-1) effort de goi
		// recursive
		if (firstHalfArrSize > 1)
			mergeSort(firstHalfArr);
		if (secondHalArrSize > 1)
			mergeSort(secondHalfArr);
		// merge 2 sorted subarray
		int firstArrCurrentIndex = 0;
		int secondArrCurrentIndex = 0;
		int currentNumsArrIndex = 0;
		// loop qua 2 sub array de compare va copy qua nums cho toi khi finish 1 trong 2
		// cai array
		// moi recursive se loop qua firstHalf va secondHalf, tuc la nums.length effort
		// co log2(nums.length) level, vay tong cong ton log2(nums.length) * nums.length
		// effort
		while ((firstArrCurrentIndex < firstHalfArrSize) && (secondArrCurrentIndex < secondHalArrSize)) {
			if (firstHalfArr[firstArrCurrentIndex] <= secondHalfArr[secondArrCurrentIndex]) {
				nums[currentNumsArrIndex++] = firstHalfArr[firstArrCurrentIndex++];
			} else {
				nums[currentNumsArrIndex++] = secondHalfArr[secondArrCurrentIndex++];
			}
		}
		// copy phan con lai cua 1 trong 2 cai array qua nums
		if (firstArrCurrentIndex < firstHalfArrSize) {
			nums[currentNumsArrIndex++] = firstHalfArr[firstArrCurrentIndex++];
		} else if (secondArrCurrentIndex < secondHalArrSize) {
			nums[currentNumsArrIndex++] = secondHalfArr[secondArrCurrentIndex++];
		}
		// vay tong cong se ton 2^0 + 2^1 + ... + 2^(log2(nums.length)-1) +
		// log2(nums.length) * nums.length effort
	}

	public static int findSingleNumber(int[] nums) {
		// vi array da sort nen worst cua findSingleNumber la 1 + nums.length / 2
		// vay tong cong effot de tim so single la 2^0 + 2^1 + ... +
		// 2^(log2(nums.length)-1) + log2(nums.length) * nums.length + 1 + nums.length /
		// 2
		int singleNumber = nums[0];
		if (nums.length == 1)
			return singleNumber;
		for (int i = 1; i < nums.length; i++) {
			if (singleNumber == nums[i])
				singleNumber = nums[++i];
			else
				return singleNumber;
		}
		return singleNumber;
	}

	public static int singleNumber(int[] nums) {
		int singleNumber = nums[0];
		int count = 0;
		for (int i = 0; i < nums.length; i++) {
			if (nums[i] == nums.length)
				continue;
			boolean pairFound = false;
			for (int j = i + 1; j < nums.length; j++) {
				System.out.println(Arrays.toString(nums));
				count++;
				if (nums[i] == nums[j]) {
					pairFound = true;
					nums[j] = nums.length;
					break;
				}
			}
			if (!pairFound) {
				singleNumber = nums[i];
				break;
			}
		}
		System.out.println("N: " + nums.length + " - loop: " + count);
		return singleNumber;
	}

	public static int findSingle(int[] nums) {
		int[] firstHalf = new int[1 + nums.length / 2];
		int[] secondHalf = new int[1 + nums.length / 2];
		int firstHalfIndex = 0;
		int secondHalfIndex = 0;
		for (int num : nums) {
			if (num % 2 == 0) 
				firstHalf[firstHalfIndex++] = num;
			else
				secondHalf[secondHalfIndex++] = num;
		}
		if(firstHalfIndex > secondHalfIndex) {
			
		}else {
			
		}
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-10-10 02:57:47.147
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-10-10 02:57:47.147
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-10 02:58:00.716
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.Scanner;

public class MainDay3 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

		// SINGLE NUMBER
		int[] nums1 = { 2, 2, 1 };
		int[] nums2 = { 4, 1, 2, 1, 2 };
		int[] nums3 = { 1 };
		int[] nums4 = { 6, 3, 1, 7, 2, 5, 8, 4 };
		int[] nums5 = { 1, 2, 3, 4, 5, 6, 5, 6, 4, 3, 2, 1, 7 };
		1 3 5 5 3 1 7 a b c b c a d 
		2a+2b+2c+d =
		2
		2 4 6 6 4 2
		
		System.out.println("Average: " + findSingle(nums5));
//		mergeSort(nums5);
//		System.out.println("Sorted array: " + Arrays.toString(nums5));
//		System.out.println("Single number: " + findSingleNumber(nums5));
//		 PRIME NUMBER
//		int[] numbers = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };
//		for (int num : numbers) {
//			System.out.println("Is " + num + " a Prime number? " + isPrimeNumber(num));
//		}
		// PALINDROME
//		int[] intArr = { 1, 1, 1, 1 };
//		System.out.println("Is Palindrome: " + isPalindrome(intArr));
		// MIN MAX AVERAGE
//		int[] intArr = { 4, 6, 2, 1, 7, 9, 10, 15, 0 };
//		int min = intArr[0];
//		int max = intArr[0];
//		double average = 0;
//		for (int i = 0; i < intArr.length; i++) {
//			if (intArr[i] > max)
//				max = intArr[i];
//			if (intArr[i] < min)
//				min = intArr[i];
//			average += intArr[i];
//		}
//		System.out.println("Min is: " + min);
//		System.out.println("Max is: " + max);
//		System.out.println("Average is: " + Math.ceil(average * 100.00 / intArr.length) / 100.00);

		// GRADE
//		Scanner scanner = new Scanner(System.in);
//		System.out.println("Please enter your average point of Maths: ");
//		Double mathsPoint = scanner.nextDouble();
//		System.out.println("Your Maths Grade is: " + getGrade(mathsPoint));
//		System.out.println("Please enter your average point of English: ");
//		Double englishPoint = scanner.nextDouble();
//		System.out.println("Your English Grade is: " + getGrade(englishPoint));
//		System.out.println("Please enter your average point of Literature: ");
//		Double literaturePoint = scanner.nextDouble();
//		System.out.println("Your Literature Grade is: " + getGrade(literaturePoint));
//
//		Double averagePoint = Math.ceil((mathsPoint + englishPoint + literaturePoint) * 100.00 / 3) / 100.00;
//		System.out.println("Your Average Point is: " + averagePoint);
//
//		Double minPoint = (mathsPoint > englishPoint) ? englishPoint : mathsPoint;
//		minPoint = (minPoint > literaturePoint) ? literaturePoint : minPoint;
//		char grade;
//		if (minPoint < 5) {
//			grade = 'F';
//		} else if (averagePoint - minPoint > 1) {
//			grade = getGrade(minPoint + 1);
//			System.out.println("Your Grade is: " + grade);
//
//		} else {
//			grade = getGrade(averagePoint);
//			System.out.println("Your Grade is: " + grade);
//		}
//		switch (grade) {
//		case 'S':
//			System.out.println("Excellent Student");
//			break;
//		case 'A':
//			System.out.println("Good Student");
//			break;
//		case 'B':
//			System.out.println("Normal Student");
//			break;
//		case 'C':
//			System.out.println("Average Student");
//			break;
//		case 'D':
//			System.out.println("Not Bad Student");
//			break;
//		case 'F':
//			System.out.println("Fail Student");
//			break;
//		}
//		scanner.close();
	}

	public static char getGrade(double point) {
		if (point >= 9)
			return 'S';
		else if (point >= 8)
			return 'A';
		else if (point >= 7)
			return 'B';
		else if (point >= 6)
			return 'C';
		else if (point >= 5)
			return 'D';
		else
			return 'F';
	}

	public static boolean isPalindrome(int[] numbers) {
		if (numbers.length == 0)
			return false;
		else if (numbers.length == 1)
			return true;
		else {
			for (int i = 0; i < numbers.length / 2; i++) {
				if (numbers[i] != numbers[numbers.length - 1 - i])
					return false;
			}
			return true;
		}
	}

	// upgraded. Chi can chay toi 1 + number/2 la dc roi
	public static boolean isPrimeNumber(int number) {
		if (number <= 0)
			return false;
		else if (number <= 2)
			return true;
		else {
			for (int i = 2; i < 1 + number / 2; i++) {
				if (number % i == 0)
					return false;
			}
			return true;
		}
	}

	public static void mergeSort(int[] nums) {
		// chia doi nums thanh nums1 va nums2
		int endIndex = nums.length - 1;
		int middleIndex = nums.length / 2;
		int firstHalfArrSize = middleIndex;
		int secondHalArrSize = endIndex - middleIndex + 1;
		int[] firstHalfArr = new int[firstHalfArrSize];
		int[] secondHalfArr = new int[secondHalArrSize];
		// copy qua 2 sub array
		for (int i = 0; i < firstHalfArrSize; i++) {
			firstHalfArr[i] = nums[i];
		}
		for (int i = 0; i < secondHalArrSize; i++) {
			secondHalfArr[i] = nums[i + firstHalfArrSize];
		}
		// tiep tuc goi recursive cho toi khi nums.length = 1 moi bat dau swap
		// vay tu nums.length de chia xuong con 1 thi se co' log2(nums.length) lan chia
		// lan chia dau tien ton 1 effort
		// lan chia thu 2 ton 2 effort
		// lan chia thu 3 ton 4 effort
		// lan chia thu log2(nums.length) ton 2^(log2(nums.length) - 1) effort
		// vay tong cong ton 2^0 + 2^1 + 2^2 +..+ 2^(log2(nums.length)-1) effort de goi
		// recursive
		if (firstHalfArrSize > 1)
			mergeSort(firstHalfArr);
		if (secondHalArrSize > 1)
			mergeSort(secondHalfArr);
		// merge 2 sorted subarray
		int firstArrCurrentIndex = 0;
		int secondArrCurrentIndex = 0;
		int currentNumsArrIndex = 0;
		// loop qua 2 sub array de compare va copy qua nums cho toi khi finish 1 trong 2
		// cai array
		// moi recursive se loop qua firstHalf va secondHalf, tuc la nums.length effort
		// co log2(nums.length) level, vay tong cong ton log2(nums.length) * nums.length
		// effort
		while ((firstArrCurrentIndex < firstHalfArrSize) && (secondArrCurrentIndex < secondHalArrSize)) {
			if (firstHalfArr[firstArrCurrentIndex] <= secondHalfArr[secondArrCurrentIndex]) {
				nums[currentNumsArrIndex++] = firstHalfArr[firstArrCurrentIndex++];
			} else {
				nums[currentNumsArrIndex++] = secondHalfArr[secondArrCurrentIndex++];
			}
		}
		// copy phan con lai cua 1 trong 2 cai array qua nums
		if (firstArrCurrentIndex < firstHalfArrSize) {
			nums[currentNumsArrIndex++] = firstHalfArr[firstArrCurrentIndex++];
		} else if (secondArrCurrentIndex < secondHalArrSize) {
			nums[currentNumsArrIndex++] = secondHalfArr[secondArrCurrentIndex++];
		}
		// vay tong cong se ton 2^0 + 2^1 + ... + 2^(log2(nums.length)-1) +
		// log2(nums.length) * nums.length effort
	}

	public static int findSingleNumber(int[] nums) {
		// vi array da sort nen worst cua findSingleNumber la 1 + nums.length / 2
		// vay tong cong effot de tim so single la 2^0 + 2^1 + ... +
		// 2^(log2(nums.length)-1) + log2(nums.length) * nums.length + 1 + nums.length /
		// 2
		int singleNumber = nums[0];
		if (nums.length == 1)
			return singleNumber;
		for (int i = 1; i < nums.length; i++) {
			if (singleNumber == nums[i])
				singleNumber = nums[++i];
			else
				return singleNumber;
		}
		return singleNumber;
	}

	public static int singleNumber(int[] nums) {
		int singleNumber = nums[0];
		int count = 0;
		for (int i = 0; i < nums.length; i++) {
			if (nums[i] == nums.length)
				continue;
			boolean pairFound = false;
			for (int j = i + 1; j < nums.length; j++) {
				System.out.println(Arrays.toString(nums));
				count++;
				if (nums[i] == nums[j]) {
					pairFound = true;
					nums[j] = nums.length;
					break;
				}
			}
			if (!pairFound) {
				singleNumber = nums[i];
				break;
			}
		}
		System.out.println("N: " + nums.length + " - loop: " + count);
		return singleNumber;
	}

	public static int findSingle(int[] nums) {
		int[] firstHalf = new int[1 + nums.length / 2];
		int[] secondHalf = new int[1 + nums.length / 2];
		int firstHalfIndex = 0;
		int secondHalfIndex = 0;
		for (int num : nums) {
			if (num % 2 == 0) 
				firstHalf[firstHalfIndex++] = num;
			else
				secondHalf[secondHalfIndex++] = num;
		}
		if(firstHalfIndex > secondHalfIndex) {
			
		}else {
			
		}
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2022-10-10 02:58:00.716
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2022-10-10 02:58:00.717
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-10 02:58:01.487
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.Scanner;

public class MainDay3 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

		// SINGLE NUMBER
		int[] nums1 = { 2, 2, 1 };
		int[] nums2 = { 4, 1, 2, 1, 2 };
		int[] nums3 = { 1 };
		int[] nums4 = { 6, 3, 1, 7, 2, 5, 8, 4 };
		int[] nums5 = { 1, 2, 3, 4, 5, 6, 5, 6, 4, 3, 2, 1, 7 };
		1 3 5 5 3 1 7 a b c b c a d 
		2a+2b+2c+d =
		2(a)
		2 4 6 6 4 2
		
		System.out.println("Average: " + findSingle(nums5));
//		mergeSort(nums5);
//		System.out.println("Sorted array: " + Arrays.toString(nums5));
//		System.out.println("Single number: " + findSingleNumber(nums5));
//		 PRIME NUMBER
//		int[] numbers = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };
//		for (int num : numbers) {
//			System.out.println("Is " + num + " a Prime number? " + isPrimeNumber(num));
//		}
		// PALINDROME
//		int[] intArr = { 1, 1, 1, 1 };
//		System.out.println("Is Palindrome: " + isPalindrome(intArr));
		// MIN MAX AVERAGE
//		int[] intArr = { 4, 6, 2, 1, 7, 9, 10, 15, 0 };
//		int min = intArr[0];
//		int max = intArr[0];
//		double average = 0;
//		for (int i = 0; i < intArr.length; i++) {
//			if (intArr[i] > max)
//				max = intArr[i];
//			if (intArr[i] < min)
//				min = intArr[i];
//			average += intArr[i];
//		}
//		System.out.println("Min is: " + min);
//		System.out.println("Max is: " + max);
//		System.out.println("Average is: " + Math.ceil(average * 100.00 / intArr.length) / 100.00);

		// GRADE
//		Scanner scanner = new Scanner(System.in);
//		System.out.println("Please enter your average point of Maths: ");
//		Double mathsPoint = scanner.nextDouble();
//		System.out.println("Your Maths Grade is: " + getGrade(mathsPoint));
//		System.out.println("Please enter your average point of English: ");
//		Double englishPoint = scanner.nextDouble();
//		System.out.println("Your English Grade is: " + getGrade(englishPoint));
//		System.out.println("Please enter your average point of Literature: ");
//		Double literaturePoint = scanner.nextDouble();
//		System.out.println("Your Literature Grade is: " + getGrade(literaturePoint));
//
//		Double averagePoint = Math.ceil((mathsPoint + englishPoint + literaturePoint) * 100.00 / 3) / 100.00;
//		System.out.println("Your Average Point is: " + averagePoint);
//
//		Double minPoint = (mathsPoint > englishPoint) ? englishPoint : mathsPoint;
//		minPoint = (minPoint > literaturePoint) ? literaturePoint : minPoint;
//		char grade;
//		if (minPoint < 5) {
//			grade = 'F';
//		} else if (averagePoint - minPoint > 1) {
//			grade = getGrade(minPoint + 1);
//			System.out.println("Your Grade is: " + grade);
//
//		} else {
//			grade = getGrade(averagePoint);
//			System.out.println("Your Grade is: " + grade);
//		}
//		switch (grade) {
//		case 'S':
//			System.out.println("Excellent Student");
//			break;
//		case 'A':
//			System.out.println("Good Student");
//			break;
//		case 'B':
//			System.out.println("Normal Student");
//			break;
//		case 'C':
//			System.out.println("Average Student");
//			break;
//		case 'D':
//			System.out.println("Not Bad Student");
//			break;
//		case 'F':
//			System.out.println("Fail Student");
//			break;
//		}
//		scanner.close();
	}

	public static char getGrade(double point) {
		if (point >= 9)
			return 'S';
		else if (point >= 8)
			return 'A';
		else if (point >= 7)
			return 'B';
		else if (point >= 6)
			return 'C';
		else if (point >= 5)
			return 'D';
		else
			return 'F';
	}

	public static boolean isPalindrome(int[] numbers) {
		if (numbers.length == 0)
			return false;
		else if (numbers.length == 1)
			return true;
		else {
			for (int i = 0; i < numbers.length / 2; i++) {
				if (numbers[i] != numbers[numbers.length - 1 - i])
					return false;
			}
			return true;
		}
	}

	// upgraded. Chi can chay toi 1 + number/2 la dc roi
	public static boolean isPrimeNumber(int number) {
		if (number <= 0)
			return false;
		else if (number <= 2)
			return true;
		else {
			for (int i = 2; i < 1 + number / 2; i++) {
				if (number % i == 0)
					return false;
			}
			return true;
		}
	}

	public static void mergeSort(int[] nums) {
		// chia doi nums thanh nums1 va nums2
		int endIndex = nums.length - 1;
		int middleIndex = nums.length / 2;
		int firstHalfArrSize = middleIndex;
		int secondHalArrSize = endIndex - middleIndex + 1;
		int[] firstHalfArr = new int[firstHalfArrSize];
		int[] secondHalfArr = new int[secondHalArrSize];
		// copy qua 2 sub array
		for (int i = 0; i < firstHalfArrSize; i++) {
			firstHalfArr[i] = nums[i];
		}
		for (int i = 0; i < secondHalArrSize; i++) {
			secondHalfArr[i] = nums[i + firstHalfArrSize];
		}
		// tiep tuc goi recursive cho toi khi nums.length = 1 moi bat dau swap
		// vay tu nums.length de chia xuong con 1 thi se co' log2(nums.length) lan chia
		// lan chia dau tien ton 1 effort
		// lan chia thu 2 ton 2 effort
		// lan chia thu 3 ton 4 effort
		// lan chia thu log2(nums.length) ton 2^(log2(nums.length) - 1) effort
		// vay tong cong ton 2^0 + 2^1 + 2^2 +..+ 2^(log2(nums.length)-1) effort de goi
		// recursive
		if (firstHalfArrSize > 1)
			mergeSort(firstHalfArr);
		if (secondHalArrSize > 1)
			mergeSort(secondHalfArr);
		// merge 2 sorted subarray
		int firstArrCurrentIndex = 0;
		int secondArrCurrentIndex = 0;
		int currentNumsArrIndex = 0;
		// loop qua 2 sub array de compare va copy qua nums cho toi khi finish 1 trong 2
		// cai array
		// moi recursive se loop qua firstHalf va secondHalf, tuc la nums.length effort
		// co log2(nums.length) level, vay tong cong ton log2(nums.length) * nums.length
		// effort
		while ((firstArrCurrentIndex < firstHalfArrSize) && (secondArrCurrentIndex < secondHalArrSize)) {
			if (firstHalfArr[firstArrCurrentIndex] <= secondHalfArr[secondArrCurrentIndex]) {
				nums[currentNumsArrIndex++] = firstHalfArr[firstArrCurrentIndex++];
			} else {
				nums[currentNumsArrIndex++] = secondHalfArr[secondArrCurrentIndex++];
			}
		}
		// copy phan con lai cua 1 trong 2 cai array qua nums
		if (firstArrCurrentIndex < firstHalfArrSize) {
			nums[currentNumsArrIndex++] = firstHalfArr[firstArrCurrentIndex++];
		} else if (secondArrCurrentIndex < secondHalArrSize) {
			nums[currentNumsArrIndex++] = secondHalfArr[secondArrCurrentIndex++];
		}
		// vay tong cong se ton 2^0 + 2^1 + ... + 2^(log2(nums.length)-1) +
		// log2(nums.length) * nums.length effort
	}

	public static int findSingleNumber(int[] nums) {
		// vi array da sort nen worst cua findSingleNumber la 1 + nums.length / 2
		// vay tong cong effot de tim so single la 2^0 + 2^1 + ... +
		// 2^(log2(nums.length)-1) + log2(nums.length) * nums.length + 1 + nums.length /
		// 2
		int singleNumber = nums[0];
		if (nums.length == 1)
			return singleNumber;
		for (int i = 1; i < nums.length; i++) {
			if (singleNumber == nums[i])
				singleNumber = nums[++i];
			else
				return singleNumber;
		}
		return singleNumber;
	}

	public static int singleNumber(int[] nums) {
		int singleNumber = nums[0];
		int count = 0;
		for (int i = 0; i < nums.length; i++) {
			if (nums[i] == nums.length)
				continue;
			boolean pairFound = false;
			for (int j = i + 1; j < nums.length; j++) {
				System.out.println(Arrays.toString(nums));
				count++;
				if (nums[i] == nums[j]) {
					pairFound = true;
					nums[j] = nums.length;
					break;
				}
			}
			if (!pairFound) {
				singleNumber = nums[i];
				break;
			}
		}
		System.out.println("N: " + nums.length + " - loop: " + count);
		return singleNumber;
	}

	public static int findSingle(int[] nums) {
		int[] firstHalf = new int[1 + nums.length / 2];
		int[] secondHalf = new int[1 + nums.length / 2];
		int firstHalfIndex = 0;
		int secondHalfIndex = 0;
		for (int num : nums) {
			if (num % 2 == 0) 
				firstHalf[firstHalfIndex++] = num;
			else
				secondHalf[secondHalfIndex++] = num;
		}
		if(firstHalfIndex > secondHalfIndex) {
			
		}else {
			
		}
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2022-10-10 02:58:01.488
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2022-10-10 02:58:01.488
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-10 02:58:01.679
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.Scanner;

public class MainDay3 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

		// SINGLE NUMBER
		int[] nums1 = { 2, 2, 1 };
		int[] nums2 = { 4, 1, 2, 1, 2 };
		int[] nums3 = { 1 };
		int[] nums4 = { 6, 3, 1, 7, 2, 5, 8, 4 };
		int[] nums5 = { 1, 2, 3, 4, 5, 6, 5, 6, 4, 3, 2, 1, 7 };
		1 3 5 5 3 1 7 a b c b c a d 
		2a+2b+2c+d =
		2(a+)
		2 4 6 6 4 2
		
		System.out.println("Average: " + findSingle(nums5));
//		mergeSort(nums5);
//		System.out.println("Sorted array: " + Arrays.toString(nums5));
//		System.out.println("Single number: " + findSingleNumber(nums5));
//		 PRIME NUMBER
//		int[] numbers = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };
//		for (int num : numbers) {
//			System.out.println("Is " + num + " a Prime number? " + isPrimeNumber(num));
//		}
		// PALINDROME
//		int[] intArr = { 1, 1, 1, 1 };
//		System.out.println("Is Palindrome: " + isPalindrome(intArr));
		// MIN MAX AVERAGE
//		int[] intArr = { 4, 6, 2, 1, 7, 9, 10, 15, 0 };
//		int min = intArr[0];
//		int max = intArr[0];
//		double average = 0;
//		for (int i = 0; i < intArr.length; i++) {
//			if (intArr[i] > max)
//				max = intArr[i];
//			if (intArr[i] < min)
//				min = intArr[i];
//			average += intArr[i];
//		}
//		System.out.println("Min is: " + min);
//		System.out.println("Max is: " + max);
//		System.out.println("Average is: " + Math.ceil(average * 100.00 / intArr.length) / 100.00);

		// GRADE
//		Scanner scanner = new Scanner(System.in);
//		System.out.println("Please enter your average point of Maths: ");
//		Double mathsPoint = scanner.nextDouble();
//		System.out.println("Your Maths Grade is: " + getGrade(mathsPoint));
//		System.out.println("Please enter your average point of English: ");
//		Double englishPoint = scanner.nextDouble();
//		System.out.println("Your English Grade is: " + getGrade(englishPoint));
//		System.out.println("Please enter your average point of Literature: ");
//		Double literaturePoint = scanner.nextDouble();
//		System.out.println("Your Literature Grade is: " + getGrade(literaturePoint));
//
//		Double averagePoint = Math.ceil((mathsPoint + englishPoint + literaturePoint) * 100.00 / 3) / 100.00;
//		System.out.println("Your Average Point is: " + averagePoint);
//
//		Double minPoint = (mathsPoint > englishPoint) ? englishPoint : mathsPoint;
//		minPoint = (minPoint > literaturePoint) ? literaturePoint : minPoint;
//		char grade;
//		if (minPoint < 5) {
//			grade = 'F';
//		} else if (averagePoint - minPoint > 1) {
//			grade = getGrade(minPoint + 1);
//			System.out.println("Your Grade is: " + grade);
//
//		} else {
//			grade = getGrade(averagePoint);
//			System.out.println("Your Grade is: " + grade);
//		}
//		switch (grade) {
//		case 'S':
//			System.out.println("Excellent Student");
//			break;
//		case 'A':
//			System.out.println("Good Student");
//			break;
//		case 'B':
//			System.out.println("Normal Student");
//			break;
//		case 'C':
//			System.out.println("Average Student");
//			break;
//		case 'D':
//			System.out.println("Not Bad Student");
//			break;
//		case 'F':
//			System.out.println("Fail Student");
//			break;
//		}
//		scanner.close();
	}

	public static char getGrade(double point) {
		if (point >= 9)
			return 'S';
		else if (point >= 8)
			return 'A';
		else if (point >= 7)
			return 'B';
		else if (point >= 6)
			return 'C';
		else if (point >= 5)
			return 'D';
		else
			return 'F';
	}

	public static boolean isPalindrome(int[] numbers) {
		if (numbers.length == 0)
			return false;
		else if (numbers.length == 1)
			return true;
		else {
			for (int i = 0; i < numbers.length / 2; i++) {
				if (numbers[i] != numbers[numbers.length - 1 - i])
					return false;
			}
			return true;
		}
	}

	// upgraded. Chi can chay toi 1 + number/2 la dc roi
	public static boolean isPrimeNumber(int number) {
		if (number <= 0)
			return false;
		else if (number <= 2)
			return true;
		else {
			for (int i = 2; i < 1 + number / 2; i++) {
				if (number % i == 0)
					return false;
			}
			return true;
		}
	}

	public static void mergeSort(int[] nums) {
		// chia doi nums thanh nums1 va nums2
		int endIndex = nums.length - 1;
		int middleIndex = nums.length / 2;
		int firstHalfArrSize = middleIndex;
		int secondHalArrSize = endIndex - middleIndex + 1;
		int[] firstHalfArr = new int[firstHalfArrSize];
		int[] secondHalfArr = new int[secondHalArrSize];
		// copy qua 2 sub array
		for (int i = 0; i < firstHalfArrSize; i++) {
			firstHalfArr[i] = nums[i];
		}
		for (int i = 0; i < secondHalArrSize; i++) {
			secondHalfArr[i] = nums[i + firstHalfArrSize];
		}
		// tiep tuc goi recursive cho toi khi nums.length = 1 moi bat dau swap
		// vay tu nums.length de chia xuong con 1 thi se co' log2(nums.length) lan chia
		// lan chia dau tien ton 1 effort
		// lan chia thu 2 ton 2 effort
		// lan chia thu 3 ton 4 effort
		// lan chia thu log2(nums.length) ton 2^(log2(nums.length) - 1) effort
		// vay tong cong ton 2^0 + 2^1 + 2^2 +..+ 2^(log2(nums.length)-1) effort de goi
		// recursive
		if (firstHalfArrSize > 1)
			mergeSort(firstHalfArr);
		if (secondHalArrSize > 1)
			mergeSort(secondHalfArr);
		// merge 2 sorted subarray
		int firstArrCurrentIndex = 0;
		int secondArrCurrentIndex = 0;
		int currentNumsArrIndex = 0;
		// loop qua 2 sub array de compare va copy qua nums cho toi khi finish 1 trong 2
		// cai array
		// moi recursive se loop qua firstHalf va secondHalf, tuc la nums.length effort
		// co log2(nums.length) level, vay tong cong ton log2(nums.length) * nums.length
		// effort
		while ((firstArrCurrentIndex < firstHalfArrSize) && (secondArrCurrentIndex < secondHalArrSize)) {
			if (firstHalfArr[firstArrCurrentIndex] <= secondHalfArr[secondArrCurrentIndex]) {
				nums[currentNumsArrIndex++] = firstHalfArr[firstArrCurrentIndex++];
			} else {
				nums[currentNumsArrIndex++] = secondHalfArr[secondArrCurrentIndex++];
			}
		}
		// copy phan con lai cua 1 trong 2 cai array qua nums
		if (firstArrCurrentIndex < firstHalfArrSize) {
			nums[currentNumsArrIndex++] = firstHalfArr[firstArrCurrentIndex++];
		} else if (secondArrCurrentIndex < secondHalArrSize) {
			nums[currentNumsArrIndex++] = secondHalfArr[secondArrCurrentIndex++];
		}
		// vay tong cong se ton 2^0 + 2^1 + ... + 2^(log2(nums.length)-1) +
		// log2(nums.length) * nums.length effort
	}

	public static int findSingleNumber(int[] nums) {
		// vi array da sort nen worst cua findSingleNumber la 1 + nums.length / 2
		// vay tong cong effot de tim so single la 2^0 + 2^1 + ... +
		// 2^(log2(nums.length)-1) + log2(nums.length) * nums.length + 1 + nums.length /
		// 2
		int singleNumber = nums[0];
		if (nums.length == 1)
			return singleNumber;
		for (int i = 1; i < nums.length; i++) {
			if (singleNumber == nums[i])
				singleNumber = nums[++i];
			else
				return singleNumber;
		}
		return singleNumber;
	}

	public static int singleNumber(int[] nums) {
		int singleNumber = nums[0];
		int count = 0;
		for (int i = 0; i < nums.length; i++) {
			if (nums[i] == nums.length)
				continue;
			boolean pairFound = false;
			for (int j = i + 1; j < nums.length; j++) {
				System.out.println(Arrays.toString(nums));
				count++;
				if (nums[i] == nums[j]) {
					pairFound = true;
					nums[j] = nums.length;
					break;
				}
			}
			if (!pairFound) {
				singleNumber = nums[i];
				break;
			}
		}
		System.out.println("N: " + nums.length + " - loop: " + count);
		return singleNumber;
	}

	public static int findSingle(int[] nums) {
		int[] firstHalf = new int[1 + nums.length / 2];
		int[] secondHalf = new int[1 + nums.length / 2];
		int firstHalfIndex = 0;
		int secondHalfIndex = 0;
		for (int num : nums) {
			if (num % 2 == 0) 
				firstHalf[firstHalfIndex++] = num;
			else
				secondHalf[secondHalfIndex++] = num;
		}
		if(firstHalfIndex > secondHalfIndex) {
			
		}else {
			
		}
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2022-10-10 02:58:01.680
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2022-10-10 02:58:01.680
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-10 02:58:01.686
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.Scanner;

public class MainDay3 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

		// SINGLE NUMBER
		int[] nums1 = { 2, 2, 1 };
		int[] nums2 = { 4, 1, 2, 1, 2 };
		int[] nums3 = { 1 };
		int[] nums4 = { 6, 3, 1, 7, 2, 5, 8, 4 };
		int[] nums5 = { 1, 2, 3, 4, 5, 6, 5, 6, 4, 3, 2, 1, 7 };
		1 3 5 5 3 1 7 a b c b c a d 
		2a+2b+2c+d =
		2(a+)
		2 4 6 6 4 2
		
		System.out.println("Average: " + findSingle(nums5));
//		mergeSort(nums5);
//		System.out.println("Sorted array: " + Arrays.toString(nums5));
//		System.out.println("Single number: " + findSingleNumber(nums5));
//		 PRIME NUMBER
//		int[] numbers = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };
//		for (int num : numbers) {
//			System.out.println("Is " + num + " a Prime number? " + isPrimeNumber(num));
//		}
		// PALINDROME
//		int[] intArr = { 1, 1, 1, 1 };
//		System.out.println("Is Palindrome: " + isPalindrome(intArr));
		// MIN MAX AVERAGE
//		int[] intArr = { 4, 6, 2, 1, 7, 9, 10, 15, 0 };
//		int min = intArr[0];
//		int max = intArr[0];
//		double average = 0;
//		for (int i = 0; i < intArr.length; i++) {
//			if (intArr[i] > max)
//				max = intArr[i];
//			if (intArr[i] < min)
//				min = intArr[i];
//			average += intArr[i];
//		}
//		System.out.println("Min is: " + min);
//		System.out.println("Max is: " + max);
//		System.out.println("Average is: " + Math.ceil(average * 100.00 / intArr.length) / 100.00);

		// GRADE
//		Scanner scanner = new Scanner(System.in);
//		System.out.println("Please enter your average point of Maths: ");
//		Double mathsPoint = scanner.nextDouble();
//		System.out.println("Your Maths Grade is: " + getGrade(mathsPoint));
//		System.out.println("Please enter your average point of English: ");
//		Double englishPoint = scanner.nextDouble();
//		System.out.println("Your English Grade is: " + getGrade(englishPoint));
//		System.out.println("Please enter your average point of Literature: ");
//		Double literaturePoint = scanner.nextDouble();
//		System.out.println("Your Literature Grade is: " + getGrade(literaturePoint));
//
//		Double averagePoint = Math.ceil((mathsPoint + englishPoint + literaturePoint) * 100.00 / 3) / 100.00;
//		System.out.println("Your Average Point is: " + averagePoint);
//
//		Double minPoint = (mathsPoint > englishPoint) ? englishPoint : mathsPoint;
//		minPoint = (minPoint > literaturePoint) ? literaturePoint : minPoint;
//		char grade;
//		if (minPoint < 5) {
//			grade = 'F';
//		} else if (averagePoint - minPoint > 1) {
//			grade = getGrade(minPoint + 1);
//			System.out.println("Your Grade is: " + grade);
//
//		} else {
//			grade = getGrade(averagePoint);
//			System.out.println("Your Grade is: " + grade);
//		}
//		switch (grade) {
//		case 'S':
//			System.out.println("Excellent Student");
//			break;
//		case 'A':
//			System.out.println("Good Student");
//			break;
//		case 'B':
//			System.out.println("Normal Student");
//			break;
//		case 'C':
//			System.out.println("Average Student");
//			break;
//		case 'D':
//			System.out.println("Not Bad Student");
//			break;
//		case 'F':
//			System.out.println("Fail Student");
//			break;
//		}
//		scanner.close();
	}

	public static char getGrade(double point) {
		if (point >= 9)
			return 'S';
		else if (point >= 8)
			return 'A';
		else if (point >= 7)
			return 'B';
		else if (point >= 6)
			return 'C';
		else if (point >= 5)
			return 'D';
		else
			return 'F';
	}

	public static boolean isPalindrome(int[] numbers) {
		if (numbers.length == 0)
			return false;
		else if (numbers.length == 1)
			return true;
		else {
			for (int i = 0; i < numbers.length / 2; i++) {
				if (numbers[i] != numbers[numbers.length - 1 - i])
					return false;
			}
			return true;
		}
	}

	// upgraded. Chi can chay toi 1 + number/2 la dc roi
	public static boolean isPrimeNumber(int number) {
		if (number <= 0)
			return false;
		else if (number <= 2)
			return true;
		else {
			for (int i = 2; i < 1 + number / 2; i++) {
				if (number % i == 0)
					return false;
			}
			return true;
		}
	}

	public static void mergeSort(int[] nums) {
		// chia doi nums thanh nums1 va nums2
		int endIndex = nums.length - 1;
		int middleIndex = nums.length / 2;
		int firstHalfArrSize = middleIndex;
		int secondHalArrSize = endIndex - middleIndex + 1;
		int[] firstHalfArr = new int[firstHalfArrSize];
		int[] secondHalfArr = new int[secondHalArrSize];
		// copy qua 2 sub array
		for (int i = 0; i < firstHalfArrSize; i++) {
			firstHalfArr[i] = nums[i];
		}
		for (int i = 0; i < secondHalArrSize; i++) {
			secondHalfArr[i] = nums[i + firstHalfArrSize];
		}
		// tiep tuc goi recursive cho toi khi nums.length = 1 moi bat dau swap
		// vay tu nums.length de chia xuong con 1 thi se co' log2(nums.length) lan chia
		// lan chia dau tien ton 1 effort
		// lan chia thu 2 ton 2 effort
		// lan chia thu 3 ton 4 effort
		// lan chia thu log2(nums.length) ton 2^(log2(nums.length) - 1) effort
		// vay tong cong ton 2^0 + 2^1 + 2^2 +..+ 2^(log2(nums.length)-1) effort de goi
		// recursive
		if (firstHalfArrSize > 1)
			mergeSort(firstHalfArr);
		if (secondHalArrSize > 1)
			mergeSort(secondHalfArr);
		// merge 2 sorted subarray
		int firstArrCurrentIndex = 0;
		int secondArrCurrentIndex = 0;
		int currentNumsArrIndex = 0;
		// loop qua 2 sub array de compare va copy qua nums cho toi khi finish 1 trong 2
		// cai array
		// moi recursive se loop qua firstHalf va secondHalf, tuc la nums.length effort
		// co log2(nums.length) level, vay tong cong ton log2(nums.length) * nums.length
		// effort
		while ((firstArrCurrentIndex < firstHalfArrSize) && (secondArrCurrentIndex < secondHalArrSize)) {
			if (firstHalfArr[firstArrCurrentIndex] <= secondHalfArr[secondArrCurrentIndex]) {
				nums[currentNumsArrIndex++] = firstHalfArr[firstArrCurrentIndex++];
			} else {
				nums[currentNumsArrIndex++] = secondHalfArr[secondArrCurrentIndex++];
			}
		}
		// copy phan con lai cua 1 trong 2 cai array qua nums
		if (firstArrCurrentIndex < firstHalfArrSize) {
			nums[currentNumsArrIndex++] = firstHalfArr[firstArrCurrentIndex++];
		} else if (secondArrCurrentIndex < secondHalArrSize) {
			nums[currentNumsArrIndex++] = secondHalfArr[secondArrCurrentIndex++];
		}
		// vay tong cong se ton 2^0 + 2^1 + ... + 2^(log2(nums.length)-1) +
		// log2(nums.length) * nums.length effort
	}

	public static int findSingleNumber(int[] nums) {
		// vi array da sort nen worst cua findSingleNumber la 1 + nums.length / 2
		// vay tong cong effot de tim so single la 2^0 + 2^1 + ... +
		// 2^(log2(nums.length)-1) + log2(nums.length) * nums.length + 1 + nums.length /
		// 2
		int singleNumber = nums[0];
		if (nums.length == 1)
			return singleNumber;
		for (int i = 1; i < nums.length; i++) {
			if (singleNumber == nums[i])
				singleNumber = nums[++i];
			else
				return singleNumber;
		}
		return singleNumber;
	}

	public static int singleNumber(int[] nums) {
		int singleNumber = nums[0];
		int count = 0;
		for (int i = 0; i < nums.length; i++) {
			if (nums[i] == nums.length)
				continue;
			boolean pairFound = false;
			for (int j = i + 1; j < nums.length; j++) {
				System.out.println(Arrays.toString(nums));
				count++;
				if (nums[i] == nums[j]) {
					pairFound = true;
					nums[j] = nums.length;
					break;
				}
			}
			if (!pairFound) {
				singleNumber = nums[i];
				break;
			}
		}
		System.out.println("N: " + nums.length + " - loop: " + count);
		return singleNumber;
	}

	public static int findSingle(int[] nums) {
		int[] firstHalf = new int[1 + nums.length / 2];
		int[] secondHalf = new int[1 + nums.length / 2];
		int firstHalfIndex = 0;
		int secondHalfIndex = 0;
		for (int num : nums) {
			if (num % 2 == 0) 
				firstHalf[firstHalfIndex++] = num;
			else
				secondHalf[secondHalfIndex++] = num;
		}
		if(firstHalfIndex > secondHalfIndex) {
			
		}else {
			
		}
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-10-10 02:58:01.687
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-10-10 02:58:01.687
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-10 02:58:02.968
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.Scanner;

public class MainDay3 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

		// SINGLE NUMBER
		int[] nums1 = { 2, 2, 1 };
		int[] nums2 = { 4, 1, 2, 1, 2 };
		int[] nums3 = { 1 };
		int[] nums4 = { 6, 3, 1, 7, 2, 5, 8, 4 };
		int[] nums5 = { 1, 2, 3, 4, 5, 6, 5, 6, 4, 3, 2, 1, 7 };
		1 3 5 5 3 1 7 a b c b c a d 
		2a+2b+2c+d =
		2(a+b+C)
		2 4 6 6 4 2
		
		System.out.println("Average: " + findSingle(nums5));
//		mergeSort(nums5);
//		System.out.println("Sorted array: " + Arrays.toString(nums5));
//		System.out.println("Single number: " + findSingleNumber(nums5));
//		 PRIME NUMBER
//		int[] numbers = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };
//		for (int num : numbers) {
//			System.out.println("Is " + num + " a Prime number? " + isPrimeNumber(num));
//		}
		// PALINDROME
//		int[] intArr = { 1, 1, 1, 1 };
//		System.out.println("Is Palindrome: " + isPalindrome(intArr));
		// MIN MAX AVERAGE
//		int[] intArr = { 4, 6, 2, 1, 7, 9, 10, 15, 0 };
//		int min = intArr[0];
//		int max = intArr[0];
//		double average = 0;
//		for (int i = 0; i < intArr.length; i++) {
//			if (intArr[i] > max)
//				max = intArr[i];
//			if (intArr[i] < min)
//				min = intArr[i];
//			average += intArr[i];
//		}
//		System.out.println("Min is: " + min);
//		System.out.println("Max is: " + max);
//		System.out.println("Average is: " + Math.ceil(average * 100.00 / intArr.length) / 100.00);

		// GRADE
//		Scanner scanner = new Scanner(System.in);
//		System.out.println("Please enter your average point of Maths: ");
//		Double mathsPoint = scanner.nextDouble();
//		System.out.println("Your Maths Grade is: " + getGrade(mathsPoint));
//		System.out.println("Please enter your average point of English: ");
//		Double englishPoint = scanner.nextDouble();
//		System.out.println("Your English Grade is: " + getGrade(englishPoint));
//		System.out.println("Please enter your average point of Literature: ");
//		Double literaturePoint = scanner.nextDouble();
//		System.out.println("Your Literature Grade is: " + getGrade(literaturePoint));
//
//		Double averagePoint = Math.ceil((mathsPoint + englishPoint + literaturePoint) * 100.00 / 3) / 100.00;
//		System.out.println("Your Average Point is: " + averagePoint);
//
//		Double minPoint = (mathsPoint > englishPoint) ? englishPoint : mathsPoint;
//		minPoint = (minPoint > literaturePoint) ? literaturePoint : minPoint;
//		char grade;
//		if (minPoint < 5) {
//			grade = 'F';
//		} else if (averagePoint - minPoint > 1) {
//			grade = getGrade(minPoint + 1);
//			System.out.println("Your Grade is: " + grade);
//
//		} else {
//			grade = getGrade(averagePoint);
//			System.out.println("Your Grade is: " + grade);
//		}
//		switch (grade) {
//		case 'S':
//			System.out.println("Excellent Student");
//			break;
//		case 'A':
//			System.out.println("Good Student");
//			break;
//		case 'B':
//			System.out.println("Normal Student");
//			break;
//		case 'C':
//			System.out.println("Average Student");
//			break;
//		case 'D':
//			System.out.println("Not Bad Student");
//			break;
//		case 'F':
//			System.out.println("Fail Student");
//			break;
//		}
//		scanner.close();
	}

	public static char getGrade(double point) {
		if (point >= 9)
			return 'S';
		else if (point >= 8)
			return 'A';
		else if (point >= 7)
			return 'B';
		else if (point >= 6)
			return 'C';
		else if (point >= 5)
			return 'D';
		else
			return 'F';
	}

	public static boolean isPalindrome(int[] numbers) {
		if (numbers.length == 0)
			return false;
		else if (numbers.length == 1)
			return true;
		else {
			for (int i = 0; i < numbers.length / 2; i++) {
				if (numbers[i] != numbers[numbers.length - 1 - i])
					return false;
			}
			return true;
		}
	}

	// upgraded. Chi can chay toi 1 + number/2 la dc roi
	public static boolean isPrimeNumber(int number) {
		if (number <= 0)
			return false;
		else if (number <= 2)
			return true;
		else {
			for (int i = 2; i < 1 + number / 2; i++) {
				if (number % i == 0)
					return false;
			}
			return true;
		}
	}

	public static void mergeSort(int[] nums) {
		// chia doi nums thanh nums1 va nums2
		int endIndex = nums.length - 1;
		int middleIndex = nums.length / 2;
		int firstHalfArrSize = middleIndex;
		int secondHalArrSize = endIndex - middleIndex + 1;
		int[] firstHalfArr = new int[firstHalfArrSize];
		int[] secondHalfArr = new int[secondHalArrSize];
		// copy qua 2 sub array
		for (int i = 0; i < firstHalfArrSize; i++) {
			firstHalfArr[i] = nums[i];
		}
		for (int i = 0; i < secondHalArrSize; i++) {
			secondHalfArr[i] = nums[i + firstHalfArrSize];
		}
		// tiep tuc goi recursive cho toi khi nums.length = 1 moi bat dau swap
		// vay tu nums.length de chia xuong con 1 thi se co' log2(nums.length) lan chia
		// lan chia dau tien ton 1 effort
		// lan chia thu 2 ton 2 effort
		// lan chia thu 3 ton 4 effort
		// lan chia thu log2(nums.length) ton 2^(log2(nums.length) - 1) effort
		// vay tong cong ton 2^0 + 2^1 + 2^2 +..+ 2^(log2(nums.length)-1) effort de goi
		// recursive
		if (firstHalfArrSize > 1)
			mergeSort(firstHalfArr);
		if (secondHalArrSize > 1)
			mergeSort(secondHalfArr);
		// merge 2 sorted subarray
		int firstArrCurrentIndex = 0;
		int secondArrCurrentIndex = 0;
		int currentNumsArrIndex = 0;
		// loop qua 2 sub array de compare va copy qua nums cho toi khi finish 1 trong 2
		// cai array
		// moi recursive se loop qua firstHalf va secondHalf, tuc la nums.length effort
		// co log2(nums.length) level, vay tong cong ton log2(nums.length) * nums.length
		// effort
		while ((firstArrCurrentIndex < firstHalfArrSize) && (secondArrCurrentIndex < secondHalArrSize)) {
			if (firstHalfArr[firstArrCurrentIndex] <= secondHalfArr[secondArrCurrentIndex]) {
				nums[currentNumsArrIndex++] = firstHalfArr[firstArrCurrentIndex++];
			} else {
				nums[currentNumsArrIndex++] = secondHalfArr[secondArrCurrentIndex++];
			}
		}
		// copy phan con lai cua 1 trong 2 cai array qua nums
		if (firstArrCurrentIndex < firstHalfArrSize) {
			nums[currentNumsArrIndex++] = firstHalfArr[firstArrCurrentIndex++];
		} else if (secondArrCurrentIndex < secondHalArrSize) {
			nums[currentNumsArrIndex++] = secondHalfArr[secondArrCurrentIndex++];
		}
		// vay tong cong se ton 2^0 + 2^1 + ... + 2^(log2(nums.length)-1) +
		// log2(nums.length) * nums.length effort
	}

	public static int findSingleNumber(int[] nums) {
		// vi array da sort nen worst cua findSingleNumber la 1 + nums.length / 2
		// vay tong cong effot de tim so single la 2^0 + 2^1 + ... +
		// 2^(log2(nums.length)-1) + log2(nums.length) * nums.length + 1 + nums.length /
		// 2
		int singleNumber = nums[0];
		if (nums.length == 1)
			return singleNumber;
		for (int i = 1; i < nums.length; i++) {
			if (singleNumber == nums[i])
				singleNumber = nums[++i];
			else
				return singleNumber;
		}
		return singleNumber;
	}

	public static int singleNumber(int[] nums) {
		int singleNumber = nums[0];
		int count = 0;
		for (int i = 0; i < nums.length; i++) {
			if (nums[i] == nums.length)
				continue;
			boolean pairFound = false;
			for (int j = i + 1; j < nums.length; j++) {
				System.out.println(Arrays.toString(nums));
				count++;
				if (nums[i] == nums[j]) {
					pairFound = true;
					nums[j] = nums.length;
					break;
				}
			}
			if (!pairFound) {
				singleNumber = nums[i];
				break;
			}
		}
		System.out.println("N: " + nums.length + " - loop: " + count);
		return singleNumber;
	}

	public static int findSingle(int[] nums) {
		int[] firstHalf = new int[1 + nums.length / 2];
		int[] secondHalf = new int[1 + nums.length / 2];
		int firstHalfIndex = 0;
		int secondHalfIndex = 0;
		for (int num : nums) {
			if (num % 2 == 0) 
				firstHalf[firstHalfIndex++] = num;
			else
				secondHalf[secondHalfIndex++] = num;
		}
		if(firstHalfIndex > secondHalfIndex) {
			
		}else {
			
		}
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2022-10-10 02:58:02.968
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2022-10-10 02:58:02.969
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-10 02:58:04.409
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.Scanner;

public class MainDay3 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

		// SINGLE NUMBER
		int[] nums1 = { 2, 2, 1 };
		int[] nums2 = { 4, 1, 2, 1, 2 };
		int[] nums3 = { 1 };
		int[] nums4 = { 6, 3, 1, 7, 2, 5, 8, 4 };
		int[] nums5 = { 1, 2, 3, 4, 5, 6, 5, 6, 4, 3, 2, 1, 7 };
		1 3 5 5 3 1 7 a b c b c a d 
		2a+2b+2c+d =
		2(a+b+C) + d
		2 4 6 6 4 2
		
		System.out.println("Average: " + findSingle(nums5));
//		mergeSort(nums5);
//		System.out.println("Sorted array: " + Arrays.toString(nums5));
//		System.out.println("Single number: " + findSingleNumber(nums5));
//		 PRIME NUMBER
//		int[] numbers = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };
//		for (int num : numbers) {
//			System.out.println("Is " + num + " a Prime number? " + isPrimeNumber(num));
//		}
		// PALINDROME
//		int[] intArr = { 1, 1, 1, 1 };
//		System.out.println("Is Palindrome: " + isPalindrome(intArr));
		// MIN MAX AVERAGE
//		int[] intArr = { 4, 6, 2, 1, 7, 9, 10, 15, 0 };
//		int min = intArr[0];
//		int max = intArr[0];
//		double average = 0;
//		for (int i = 0; i < intArr.length; i++) {
//			if (intArr[i] > max)
//				max = intArr[i];
//			if (intArr[i] < min)
//				min = intArr[i];
//			average += intArr[i];
//		}
//		System.out.println("Min is: " + min);
//		System.out.println("Max is: " + max);
//		System.out.println("Average is: " + Math.ceil(average * 100.00 / intArr.length) / 100.00);

		// GRADE
//		Scanner scanner = new Scanner(System.in);
//		System.out.println("Please enter your average point of Maths: ");
//		Double mathsPoint = scanner.nextDouble();
//		System.out.println("Your Maths Grade is: " + getGrade(mathsPoint));
//		System.out.println("Please enter your average point of English: ");
//		Double englishPoint = scanner.nextDouble();
//		System.out.println("Your English Grade is: " + getGrade(englishPoint));
//		System.out.println("Please enter your average point of Literature: ");
//		Double literaturePoint = scanner.nextDouble();
//		System.out.println("Your Literature Grade is: " + getGrade(literaturePoint));
//
//		Double averagePoint = Math.ceil((mathsPoint + englishPoint + literaturePoint) * 100.00 / 3) / 100.00;
//		System.out.println("Your Average Point is: " + averagePoint);
//
//		Double minPoint = (mathsPoint > englishPoint) ? englishPoint : mathsPoint;
//		minPoint = (minPoint > literaturePoint) ? literaturePoint : minPoint;
//		char grade;
//		if (minPoint < 5) {
//			grade = 'F';
//		} else if (averagePoint - minPoint > 1) {
//			grade = getGrade(minPoint + 1);
//			System.out.println("Your Grade is: " + grade);
//
//		} else {
//			grade = getGrade(averagePoint);
//			System.out.println("Your Grade is: " + grade);
//		}
//		switch (grade) {
//		case 'S':
//			System.out.println("Excellent Student");
//			break;
//		case 'A':
//			System.out.println("Good Student");
//			break;
//		case 'B':
//			System.out.println("Normal Student");
//			break;
//		case 'C':
//			System.out.println("Average Student");
//			break;
//		case 'D':
//			System.out.println("Not Bad Student");
//			break;
//		case 'F':
//			System.out.println("Fail Student");
//			break;
//		}
//		scanner.close();
	}

	public static char getGrade(double point) {
		if (point >= 9)
			return 'S';
		else if (point >= 8)
			return 'A';
		else if (point >= 7)
			return 'B';
		else if (point >= 6)
			return 'C';
		else if (point >= 5)
			return 'D';
		else
			return 'F';
	}

	public static boolean isPalindrome(int[] numbers) {
		if (numbers.length == 0)
			return false;
		else if (numbers.length == 1)
			return true;
		else {
			for (int i = 0; i < numbers.length / 2; i++) {
				if (numbers[i] != numbers[numbers.length - 1 - i])
					return false;
			}
			return true;
		}
	}

	// upgraded. Chi can chay toi 1 + number/2 la dc roi
	public static boolean isPrimeNumber(int number) {
		if (number <= 0)
			return false;
		else if (number <= 2)
			return true;
		else {
			for (int i = 2; i < 1 + number / 2; i++) {
				if (number % i == 0)
					return false;
			}
			return true;
		}
	}

	public static void mergeSort(int[] nums) {
		// chia doi nums thanh nums1 va nums2
		int endIndex = nums.length - 1;
		int middleIndex = nums.length / 2;
		int firstHalfArrSize = middleIndex;
		int secondHalArrSize = endIndex - middleIndex + 1;
		int[] firstHalfArr = new int[firstHalfArrSize];
		int[] secondHalfArr = new int[secondHalArrSize];
		// copy qua 2 sub array
		for (int i = 0; i < firstHalfArrSize; i++) {
			firstHalfArr[i] = nums[i];
		}
		for (int i = 0; i < secondHalArrSize; i++) {
			secondHalfArr[i] = nums[i + firstHalfArrSize];
		}
		// tiep tuc goi recursive cho toi khi nums.length = 1 moi bat dau swap
		// vay tu nums.length de chia xuong con 1 thi se co' log2(nums.length) lan chia
		// lan chia dau tien ton 1 effort
		// lan chia thu 2 ton 2 effort
		// lan chia thu 3 ton 4 effort
		// lan chia thu log2(nums.length) ton 2^(log2(nums.length) - 1) effort
		// vay tong cong ton 2^0 + 2^1 + 2^2 +..+ 2^(log2(nums.length)-1) effort de goi
		// recursive
		if (firstHalfArrSize > 1)
			mergeSort(firstHalfArr);
		if (secondHalArrSize > 1)
			mergeSort(secondHalfArr);
		// merge 2 sorted subarray
		int firstArrCurrentIndex = 0;
		int secondArrCurrentIndex = 0;
		int currentNumsArrIndex = 0;
		// loop qua 2 sub array de compare va copy qua nums cho toi khi finish 1 trong 2
		// cai array
		// moi recursive se loop qua firstHalf va secondHalf, tuc la nums.length effort
		// co log2(nums.length) level, vay tong cong ton log2(nums.length) * nums.length
		// effort
		while ((firstArrCurrentIndex < firstHalfArrSize) && (secondArrCurrentIndex < secondHalArrSize)) {
			if (firstHalfArr[firstArrCurrentIndex] <= secondHalfArr[secondArrCurrentIndex]) {
				nums[currentNumsArrIndex++] = firstHalfArr[firstArrCurrentIndex++];
			} else {
				nums[currentNumsArrIndex++] = secondHalfArr[secondArrCurrentIndex++];
			}
		}
		// copy phan con lai cua 1 trong 2 cai array qua nums
		if (firstArrCurrentIndex < firstHalfArrSize) {
			nums[currentNumsArrIndex++] = firstHalfArr[firstArrCurrentIndex++];
		} else if (secondArrCurrentIndex < secondHalArrSize) {
			nums[currentNumsArrIndex++] = secondHalfArr[secondArrCurrentIndex++];
		}
		// vay tong cong se ton 2^0 + 2^1 + ... + 2^(log2(nums.length)-1) +
		// log2(nums.length) * nums.length effort
	}

	public static int findSingleNumber(int[] nums) {
		// vi array da sort nen worst cua findSingleNumber la 1 + nums.length / 2
		// vay tong cong effot de tim so single la 2^0 + 2^1 + ... +
		// 2^(log2(nums.length)-1) + log2(nums.length) * nums.length + 1 + nums.length /
		// 2
		int singleNumber = nums[0];
		if (nums.length == 1)
			return singleNumber;
		for (int i = 1; i < nums.length; i++) {
			if (singleNumber == nums[i])
				singleNumber = nums[++i];
			else
				return singleNumber;
		}
		return singleNumber;
	}

	public static int singleNumber(int[] nums) {
		int singleNumber = nums[0];
		int count = 0;
		for (int i = 0; i < nums.length; i++) {
			if (nums[i] == nums.length)
				continue;
			boolean pairFound = false;
			for (int j = i + 1; j < nums.length; j++) {
				System.out.println(Arrays.toString(nums));
				count++;
				if (nums[i] == nums[j]) {
					pairFound = true;
					nums[j] = nums.length;
					break;
				}
			}
			if (!pairFound) {
				singleNumber = nums[i];
				break;
			}
		}
		System.out.println("N: " + nums.length + " - loop: " + count);
		return singleNumber;
	}

	public static int findSingle(int[] nums) {
		int[] firstHalf = new int[1 + nums.length / 2];
		int[] secondHalf = new int[1 + nums.length / 2];
		int firstHalfIndex = 0;
		int secondHalfIndex = 0;
		for (int num : nums) {
			if (num % 2 == 0) 
				firstHalf[firstHalfIndex++] = num;
			else
				secondHalf[secondHalfIndex++] = num;
		}
		if(firstHalfIndex > secondHalfIndex) {
			
		}else {
			
		}
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2022-10-10 02:58:04.409
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2022-10-10 02:58:04.410
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-10 02:58:04.542
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.Scanner;

public class MainDay3 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

		// SINGLE NUMBER
		int[] nums1 = { 2, 2, 1 };
		int[] nums2 = { 4, 1, 2, 1, 2 };
		int[] nums3 = { 1 };
		int[] nums4 = { 6, 3, 1, 7, 2, 5, 8, 4 };
		int[] nums5 = { 1, 2, 3, 4, 5, 6, 5, 6, 4, 3, 2, 1, 7 };
		1 3 5 5 3 1 7 a b c b c a d 
		2a+2b+2c+d =
		2(a+b+C) + d 
		2 4 6 6 4 2
		
		System.out.println("Average: " + findSingle(nums5));
//		mergeSort(nums5);
//		System.out.println("Sorted array: " + Arrays.toString(nums5));
//		System.out.println("Single number: " + findSingleNumber(nums5));
//		 PRIME NUMBER
//		int[] numbers = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };
//		for (int num : numbers) {
//			System.out.println("Is " + num + " a Prime number? " + isPrimeNumber(num));
//		}
		// PALINDROME
//		int[] intArr = { 1, 1, 1, 1 };
//		System.out.println("Is Palindrome: " + isPalindrome(intArr));
		// MIN MAX AVERAGE
//		int[] intArr = { 4, 6, 2, 1, 7, 9, 10, 15, 0 };
//		int min = intArr[0];
//		int max = intArr[0];
//		double average = 0;
//		for (int i = 0; i < intArr.length; i++) {
//			if (intArr[i] > max)
//				max = intArr[i];
//			if (intArr[i] < min)
//				min = intArr[i];
//			average += intArr[i];
//		}
//		System.out.println("Min is: " + min);
//		System.out.println("Max is: " + max);
//		System.out.println("Average is: " + Math.ceil(average * 100.00 / intArr.length) / 100.00);

		// GRADE
//		Scanner scanner = new Scanner(System.in);
//		System.out.println("Please enter your average point of Maths: ");
//		Double mathsPoint = scanner.nextDouble();
//		System.out.println("Your Maths Grade is: " + getGrade(mathsPoint));
//		System.out.println("Please enter your average point of English: ");
//		Double englishPoint = scanner.nextDouble();
//		System.out.println("Your English Grade is: " + getGrade(englishPoint));
//		System.out.println("Please enter your average point of Literature: ");
//		Double literaturePoint = scanner.nextDouble();
//		System.out.println("Your Literature Grade is: " + getGrade(literaturePoint));
//
//		Double averagePoint = Math.ceil((mathsPoint + englishPoint + literaturePoint) * 100.00 / 3) / 100.00;
//		System.out.println("Your Average Point is: " + averagePoint);
//
//		Double minPoint = (mathsPoint > englishPoint) ? englishPoint : mathsPoint;
//		minPoint = (minPoint > literaturePoint) ? literaturePoint : minPoint;
//		char grade;
//		if (minPoint < 5) {
//			grade = 'F';
//		} else if (averagePoint - minPoint > 1) {
//			grade = getGrade(minPoint + 1);
//			System.out.println("Your Grade is: " + grade);
//
//		} else {
//			grade = getGrade(averagePoint);
//			System.out.println("Your Grade is: " + grade);
//		}
//		switch (grade) {
//		case 'S':
//			System.out.println("Excellent Student");
//			break;
//		case 'A':
//			System.out.println("Good Student");
//			break;
//		case 'B':
//			System.out.println("Normal Student");
//			break;
//		case 'C':
//			System.out.println("Average Student");
//			break;
//		case 'D':
//			System.out.println("Not Bad Student");
//			break;
//		case 'F':
//			System.out.println("Fail Student");
//			break;
//		}
//		scanner.close();
	}

	public static char getGrade(double point) {
		if (point >= 9)
			return 'S';
		else if (point >= 8)
			return 'A';
		else if (point >= 7)
			return 'B';
		else if (point >= 6)
			return 'C';
		else if (point >= 5)
			return 'D';
		else
			return 'F';
	}

	public static boolean isPalindrome(int[] numbers) {
		if (numbers.length == 0)
			return false;
		else if (numbers.length == 1)
			return true;
		else {
			for (int i = 0; i < numbers.length / 2; i++) {
				if (numbers[i] != numbers[numbers.length - 1 - i])
					return false;
			}
			return true;
		}
	}

	// upgraded. Chi can chay toi 1 + number/2 la dc roi
	public static boolean isPrimeNumber(int number) {
		if (number <= 0)
			return false;
		else if (number <= 2)
			return true;
		else {
			for (int i = 2; i < 1 + number / 2; i++) {
				if (number % i == 0)
					return false;
			}
			return true;
		}
	}

	public static void mergeSort(int[] nums) {
		// chia doi nums thanh nums1 va nums2
		int endIndex = nums.length - 1;
		int middleIndex = nums.length / 2;
		int firstHalfArrSize = middleIndex;
		int secondHalArrSize = endIndex - middleIndex + 1;
		int[] firstHalfArr = new int[firstHalfArrSize];
		int[] secondHalfArr = new int[secondHalArrSize];
		// copy qua 2 sub array
		for (int i = 0; i < firstHalfArrSize; i++) {
			firstHalfArr[i] = nums[i];
		}
		for (int i = 0; i < secondHalArrSize; i++) {
			secondHalfArr[i] = nums[i + firstHalfArrSize];
		}
		// tiep tuc goi recursive cho toi khi nums.length = 1 moi bat dau swap
		// vay tu nums.length de chia xuong con 1 thi se co' log2(nums.length) lan chia
		// lan chia dau tien ton 1 effort
		// lan chia thu 2 ton 2 effort
		// lan chia thu 3 ton 4 effort
		// lan chia thu log2(nums.length) ton 2^(log2(nums.length) - 1) effort
		// vay tong cong ton 2^0 + 2^1 + 2^2 +..+ 2^(log2(nums.length)-1) effort de goi
		// recursive
		if (firstHalfArrSize > 1)
			mergeSort(firstHalfArr);
		if (secondHalArrSize > 1)
			mergeSort(secondHalfArr);
		// merge 2 sorted subarray
		int firstArrCurrentIndex = 0;
		int secondArrCurrentIndex = 0;
		int currentNumsArrIndex = 0;
		// loop qua 2 sub array de compare va copy qua nums cho toi khi finish 1 trong 2
		// cai array
		// moi recursive se loop qua firstHalf va secondHalf, tuc la nums.length effort
		// co log2(nums.length) level, vay tong cong ton log2(nums.length) * nums.length
		// effort
		while ((firstArrCurrentIndex < firstHalfArrSize) && (secondArrCurrentIndex < secondHalArrSize)) {
			if (firstHalfArr[firstArrCurrentIndex] <= secondHalfArr[secondArrCurrentIndex]) {
				nums[currentNumsArrIndex++] = firstHalfArr[firstArrCurrentIndex++];
			} else {
				nums[currentNumsArrIndex++] = secondHalfArr[secondArrCurrentIndex++];
			}
		}
		// copy phan con lai cua 1 trong 2 cai array qua nums
		if (firstArrCurrentIndex < firstHalfArrSize) {
			nums[currentNumsArrIndex++] = firstHalfArr[firstArrCurrentIndex++];
		} else if (secondArrCurrentIndex < secondHalArrSize) {
			nums[currentNumsArrIndex++] = secondHalfArr[secondArrCurrentIndex++];
		}
		// vay tong cong se ton 2^0 + 2^1 + ... + 2^(log2(nums.length)-1) +
		// log2(nums.length) * nums.length effort
	}

	public static int findSingleNumber(int[] nums) {
		// vi array da sort nen worst cua findSingleNumber la 1 + nums.length / 2
		// vay tong cong effot de tim so single la 2^0 + 2^1 + ... +
		// 2^(log2(nums.length)-1) + log2(nums.length) * nums.length + 1 + nums.length /
		// 2
		int singleNumber = nums[0];
		if (nums.length == 1)
			return singleNumber;
		for (int i = 1; i < nums.length; i++) {
			if (singleNumber == nums[i])
				singleNumber = nums[++i];
			else
				return singleNumber;
		}
		return singleNumber;
	}

	public static int singleNumber(int[] nums) {
		int singleNumber = nums[0];
		int count = 0;
		for (int i = 0; i < nums.length; i++) {
			if (nums[i] == nums.length)
				continue;
			boolean pairFound = false;
			for (int j = i + 1; j < nums.length; j++) {
				System.out.println(Arrays.toString(nums));
				count++;
				if (nums[i] == nums[j]) {
					pairFound = true;
					nums[j] = nums.length;
					break;
				}
			}
			if (!pairFound) {
				singleNumber = nums[i];
				break;
			}
		}
		System.out.println("N: " + nums.length + " - loop: " + count);
		return singleNumber;
	}

	public static int findSingle(int[] nums) {
		int[] firstHalf = new int[1 + nums.length / 2];
		int[] secondHalf = new int[1 + nums.length / 2];
		int firstHalfIndex = 0;
		int secondHalfIndex = 0;
		for (int num : nums) {
			if (num % 2 == 0) 
				firstHalf[firstHalfIndex++] = num;
			else
				secondHalf[secondHalfIndex++] = num;
		}
		if(firstHalfIndex > secondHalfIndex) {
			
		}else {
			
		}
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2022-10-10 02:58:04.542
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2022-10-10 02:58:04.543
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-10 02:58:04.550
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.Scanner;

public class MainDay3 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

		// SINGLE NUMBER
		int[] nums1 = { 2, 2, 1 };
		int[] nums2 = { 4, 1, 2, 1, 2 };
		int[] nums3 = { 1 };
		int[] nums4 = { 6, 3, 1, 7, 2, 5, 8, 4 };
		int[] nums5 = { 1, 2, 3, 4, 5, 6, 5, 6, 4, 3, 2, 1, 7 };
		1 3 5 5 3 1 7 a b c b c a d 
		2a+2b+2c+d =
		2(a+b+C) + d 
		2 4 6 6 4 2
		
		System.out.println("Average: " + findSingle(nums5));
//		mergeSort(nums5);
//		System.out.println("Sorted array: " + Arrays.toString(nums5));
//		System.out.println("Single number: " + findSingleNumber(nums5));
//		 PRIME NUMBER
//		int[] numbers = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };
//		for (int num : numbers) {
//			System.out.println("Is " + num + " a Prime number? " + isPrimeNumber(num));
//		}
		// PALINDROME
//		int[] intArr = { 1, 1, 1, 1 };
//		System.out.println("Is Palindrome: " + isPalindrome(intArr));
		// MIN MAX AVERAGE
//		int[] intArr = { 4, 6, 2, 1, 7, 9, 10, 15, 0 };
//		int min = intArr[0];
//		int max = intArr[0];
//		double average = 0;
//		for (int i = 0; i < intArr.length; i++) {
//			if (intArr[i] > max)
//				max = intArr[i];
//			if (intArr[i] < min)
//				min = intArr[i];
//			average += intArr[i];
//		}
//		System.out.println("Min is: " + min);
//		System.out.println("Max is: " + max);
//		System.out.println("Average is: " + Math.ceil(average * 100.00 / intArr.length) / 100.00);

		// GRADE
//		Scanner scanner = new Scanner(System.in);
//		System.out.println("Please enter your average point of Maths: ");
//		Double mathsPoint = scanner.nextDouble();
//		System.out.println("Your Maths Grade is: " + getGrade(mathsPoint));
//		System.out.println("Please enter your average point of English: ");
//		Double englishPoint = scanner.nextDouble();
//		System.out.println("Your English Grade is: " + getGrade(englishPoint));
//		System.out.println("Please enter your average point of Literature: ");
//		Double literaturePoint = scanner.nextDouble();
//		System.out.println("Your Literature Grade is: " + getGrade(literaturePoint));
//
//		Double averagePoint = Math.ceil((mathsPoint + englishPoint + literaturePoint) * 100.00 / 3) / 100.00;
//		System.out.println("Your Average Point is: " + averagePoint);
//
//		Double minPoint = (mathsPoint > englishPoint) ? englishPoint : mathsPoint;
//		minPoint = (minPoint > literaturePoint) ? literaturePoint : minPoint;
//		char grade;
//		if (minPoint < 5) {
//			grade = 'F';
//		} else if (averagePoint - minPoint > 1) {
//			grade = getGrade(minPoint + 1);
//			System.out.println("Your Grade is: " + grade);
//
//		} else {
//			grade = getGrade(averagePoint);
//			System.out.println("Your Grade is: " + grade);
//		}
//		switch (grade) {
//		case 'S':
//			System.out.println("Excellent Student");
//			break;
//		case 'A':
//			System.out.println("Good Student");
//			break;
//		case 'B':
//			System.out.println("Normal Student");
//			break;
//		case 'C':
//			System.out.println("Average Student");
//			break;
//		case 'D':
//			System.out.println("Not Bad Student");
//			break;
//		case 'F':
//			System.out.println("Fail Student");
//			break;
//		}
//		scanner.close();
	}

	public static char getGrade(double point) {
		if (point >= 9)
			return 'S';
		else if (point >= 8)
			return 'A';
		else if (point >= 7)
			return 'B';
		else if (point >= 6)
			return 'C';
		else if (point >= 5)
			return 'D';
		else
			return 'F';
	}

	public static boolean isPalindrome(int[] numbers) {
		if (numbers.length == 0)
			return false;
		else if (numbers.length == 1)
			return true;
		else {
			for (int i = 0; i < numbers.length / 2; i++) {
				if (numbers[i] != numbers[numbers.length - 1 - i])
					return false;
			}
			return true;
		}
	}

	// upgraded. Chi can chay toi 1 + number/2 la dc roi
	public static boolean isPrimeNumber(int number) {
		if (number <= 0)
			return false;
		else if (number <= 2)
			return true;
		else {
			for (int i = 2; i < 1 + number / 2; i++) {
				if (number % i == 0)
					return false;
			}
			return true;
		}
	}

	public static void mergeSort(int[] nums) {
		// chia doi nums thanh nums1 va nums2
		int endIndex = nums.length - 1;
		int middleIndex = nums.length / 2;
		int firstHalfArrSize = middleIndex;
		int secondHalArrSize = endIndex - middleIndex + 1;
		int[] firstHalfArr = new int[firstHalfArrSize];
		int[] secondHalfArr = new int[secondHalArrSize];
		// copy qua 2 sub array
		for (int i = 0; i < firstHalfArrSize; i++) {
			firstHalfArr[i] = nums[i];
		}
		for (int i = 0; i < secondHalArrSize; i++) {
			secondHalfArr[i] = nums[i + firstHalfArrSize];
		}
		// tiep tuc goi recursive cho toi khi nums.length = 1 moi bat dau swap
		// vay tu nums.length de chia xuong con 1 thi se co' log2(nums.length) lan chia
		// lan chia dau tien ton 1 effort
		// lan chia thu 2 ton 2 effort
		// lan chia thu 3 ton 4 effort
		// lan chia thu log2(nums.length) ton 2^(log2(nums.length) - 1) effort
		// vay tong cong ton 2^0 + 2^1 + 2^2 +..+ 2^(log2(nums.length)-1) effort de goi
		// recursive
		if (firstHalfArrSize > 1)
			mergeSort(firstHalfArr);
		if (secondHalArrSize > 1)
			mergeSort(secondHalfArr);
		// merge 2 sorted subarray
		int firstArrCurrentIndex = 0;
		int secondArrCurrentIndex = 0;
		int currentNumsArrIndex = 0;
		// loop qua 2 sub array de compare va copy qua nums cho toi khi finish 1 trong 2
		// cai array
		// moi recursive se loop qua firstHalf va secondHalf, tuc la nums.length effort
		// co log2(nums.length) level, vay tong cong ton log2(nums.length) * nums.length
		// effort
		while ((firstArrCurrentIndex < firstHalfArrSize) && (secondArrCurrentIndex < secondHalArrSize)) {
			if (firstHalfArr[firstArrCurrentIndex] <= secondHalfArr[secondArrCurrentIndex]) {
				nums[currentNumsArrIndex++] = firstHalfArr[firstArrCurrentIndex++];
			} else {
				nums[currentNumsArrIndex++] = secondHalfArr[secondArrCurrentIndex++];
			}
		}
		// copy phan con lai cua 1 trong 2 cai array qua nums
		if (firstArrCurrentIndex < firstHalfArrSize) {
			nums[currentNumsArrIndex++] = firstHalfArr[firstArrCurrentIndex++];
		} else if (secondArrCurrentIndex < secondHalArrSize) {
			nums[currentNumsArrIndex++] = secondHalfArr[secondArrCurrentIndex++];
		}
		// vay tong cong se ton 2^0 + 2^1 + ... + 2^(log2(nums.length)-1) +
		// log2(nums.length) * nums.length effort
	}

	public static int findSingleNumber(int[] nums) {
		// vi array da sort nen worst cua findSingleNumber la 1 + nums.length / 2
		// vay tong cong effot de tim so single la 2^0 + 2^1 + ... +
		// 2^(log2(nums.length)-1) + log2(nums.length) * nums.length + 1 + nums.length /
		// 2
		int singleNumber = nums[0];
		if (nums.length == 1)
			return singleNumber;
		for (int i = 1; i < nums.length; i++) {
			if (singleNumber == nums[i])
				singleNumber = nums[++i];
			else
				return singleNumber;
		}
		return singleNumber;
	}

	public static int singleNumber(int[] nums) {
		int singleNumber = nums[0];
		int count = 0;
		for (int i = 0; i < nums.length; i++) {
			if (nums[i] == nums.length)
				continue;
			boolean pairFound = false;
			for (int j = i + 1; j < nums.length; j++) {
				System.out.println(Arrays.toString(nums));
				count++;
				if (nums[i] == nums[j]) {
					pairFound = true;
					nums[j] = nums.length;
					break;
				}
			}
			if (!pairFound) {
				singleNumber = nums[i];
				break;
			}
		}
		System.out.println("N: " + nums.length + " - loop: " + count);
		return singleNumber;
	}

	public static int findSingle(int[] nums) {
		int[] firstHalf = new int[1 + nums.length / 2];
		int[] secondHalf = new int[1 + nums.length / 2];
		int firstHalfIndex = 0;
		int secondHalfIndex = 0;
		for (int num : nums) {
			if (num % 2 == 0) 
				firstHalf[firstHalfIndex++] = num;
			else
				secondHalf[secondHalfIndex++] = num;
		}
		if(firstHalfIndex > secondHalfIndex) {
			
		}else {
			
		}
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-10-10 02:58:04.551
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-10-10 02:58:04.551
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-10 02:58:05.148
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.Scanner;

public class MainDay3 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

		// SINGLE NUMBER
		int[] nums1 = { 2, 2, 1 };
		int[] nums2 = { 4, 1, 2, 1, 2 };
		int[] nums3 = { 1 };
		int[] nums4 = { 6, 3, 1, 7, 2, 5, 8, 4 };
		int[] nums5 = { 1, 2, 3, 4, 5, 6, 5, 6, 4, 3, 2, 1, 7 };
		1 3 5 5 3 1 7 a b c b c a d 
		2a+2b+2c+d =
		2(a+b+C) + d =
		2 4 6 6 4 2
		
		System.out.println("Average: " + findSingle(nums5));
//		mergeSort(nums5);
//		System.out.println("Sorted array: " + Arrays.toString(nums5));
//		System.out.println("Single number: " + findSingleNumber(nums5));
//		 PRIME NUMBER
//		int[] numbers = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };
//		for (int num : numbers) {
//			System.out.println("Is " + num + " a Prime number? " + isPrimeNumber(num));
//		}
		// PALINDROME
//		int[] intArr = { 1, 1, 1, 1 };
//		System.out.println("Is Palindrome: " + isPalindrome(intArr));
		// MIN MAX AVERAGE
//		int[] intArr = { 4, 6, 2, 1, 7, 9, 10, 15, 0 };
//		int min = intArr[0];
//		int max = intArr[0];
//		double average = 0;
//		for (int i = 0; i < intArr.length; i++) {
//			if (intArr[i] > max)
//				max = intArr[i];
//			if (intArr[i] < min)
//				min = intArr[i];
//			average += intArr[i];
//		}
//		System.out.println("Min is: " + min);
//		System.out.println("Max is: " + max);
//		System.out.println("Average is: " + Math.ceil(average * 100.00 / intArr.length) / 100.00);

		// GRADE
//		Scanner scanner = new Scanner(System.in);
//		System.out.println("Please enter your average point of Maths: ");
//		Double mathsPoint = scanner.nextDouble();
//		System.out.println("Your Maths Grade is: " + getGrade(mathsPoint));
//		System.out.println("Please enter your average point of English: ");
//		Double englishPoint = scanner.nextDouble();
//		System.out.println("Your English Grade is: " + getGrade(englishPoint));
//		System.out.println("Please enter your average point of Literature: ");
//		Double literaturePoint = scanner.nextDouble();
//		System.out.println("Your Literature Grade is: " + getGrade(literaturePoint));
//
//		Double averagePoint = Math.ceil((mathsPoint + englishPoint + literaturePoint) * 100.00 / 3) / 100.00;
//		System.out.println("Your Average Point is: " + averagePoint);
//
//		Double minPoint = (mathsPoint > englishPoint) ? englishPoint : mathsPoint;
//		minPoint = (minPoint > literaturePoint) ? literaturePoint : minPoint;
//		char grade;
//		if (minPoint < 5) {
//			grade = 'F';
//		} else if (averagePoint - minPoint > 1) {
//			grade = getGrade(minPoint + 1);
//			System.out.println("Your Grade is: " + grade);
//
//		} else {
//			grade = getGrade(averagePoint);
//			System.out.println("Your Grade is: " + grade);
//		}
//		switch (grade) {
//		case 'S':
//			System.out.println("Excellent Student");
//			break;
//		case 'A':
//			System.out.println("Good Student");
//			break;
//		case 'B':
//			System.out.println("Normal Student");
//			break;
//		case 'C':
//			System.out.println("Average Student");
//			break;
//		case 'D':
//			System.out.println("Not Bad Student");
//			break;
//		case 'F':
//			System.out.println("Fail Student");
//			break;
//		}
//		scanner.close();
	}

	public static char getGrade(double point) {
		if (point >= 9)
			return 'S';
		else if (point >= 8)
			return 'A';
		else if (point >= 7)
			return 'B';
		else if (point >= 6)
			return 'C';
		else if (point >= 5)
			return 'D';
		else
			return 'F';
	}

	public static boolean isPalindrome(int[] numbers) {
		if (numbers.length == 0)
			return false;
		else if (numbers.length == 1)
			return true;
		else {
			for (int i = 0; i < numbers.length / 2; i++) {
				if (numbers[i] != numbers[numbers.length - 1 - i])
					return false;
			}
			return true;
		}
	}

	// upgraded. Chi can chay toi 1 + number/2 la dc roi
	public static boolean isPrimeNumber(int number) {
		if (number <= 0)
			return false;
		else if (number <= 2)
			return true;
		else {
			for (int i = 2; i < 1 + number / 2; i++) {
				if (number % i == 0)
					return false;
			}
			return true;
		}
	}

	public static void mergeSort(int[] nums) {
		// chia doi nums thanh nums1 va nums2
		int endIndex = nums.length - 1;
		int middleIndex = nums.length / 2;
		int firstHalfArrSize = middleIndex;
		int secondHalArrSize = endIndex - middleIndex + 1;
		int[] firstHalfArr = new int[firstHalfArrSize];
		int[] secondHalfArr = new int[secondHalArrSize];
		// copy qua 2 sub array
		for (int i = 0; i < firstHalfArrSize; i++) {
			firstHalfArr[i] = nums[i];
		}
		for (int i = 0; i < secondHalArrSize; i++) {
			secondHalfArr[i] = nums[i + firstHalfArrSize];
		}
		// tiep tuc goi recursive cho toi khi nums.length = 1 moi bat dau swap
		// vay tu nums.length de chia xuong con 1 thi se co' log2(nums.length) lan chia
		// lan chia dau tien ton 1 effort
		// lan chia thu 2 ton 2 effort
		// lan chia thu 3 ton 4 effort
		// lan chia thu log2(nums.length) ton 2^(log2(nums.length) - 1) effort
		// vay tong cong ton 2^0 + 2^1 + 2^2 +..+ 2^(log2(nums.length)-1) effort de goi
		// recursive
		if (firstHalfArrSize > 1)
			mergeSort(firstHalfArr);
		if (secondHalArrSize > 1)
			mergeSort(secondHalfArr);
		// merge 2 sorted subarray
		int firstArrCurrentIndex = 0;
		int secondArrCurrentIndex = 0;
		int currentNumsArrIndex = 0;
		// loop qua 2 sub array de compare va copy qua nums cho toi khi finish 1 trong 2
		// cai array
		// moi recursive se loop qua firstHalf va secondHalf, tuc la nums.length effort
		// co log2(nums.length) level, vay tong cong ton log2(nums.length) * nums.length
		// effort
		while ((firstArrCurrentIndex < firstHalfArrSize) && (secondArrCurrentIndex < secondHalArrSize)) {
			if (firstHalfArr[firstArrCurrentIndex] <= secondHalfArr[secondArrCurrentIndex]) {
				nums[currentNumsArrIndex++] = firstHalfArr[firstArrCurrentIndex++];
			} else {
				nums[currentNumsArrIndex++] = secondHalfArr[secondArrCurrentIndex++];
			}
		}
		// copy phan con lai cua 1 trong 2 cai array qua nums
		if (firstArrCurrentIndex < firstHalfArrSize) {
			nums[currentNumsArrIndex++] = firstHalfArr[firstArrCurrentIndex++];
		} else if (secondArrCurrentIndex < secondHalArrSize) {
			nums[currentNumsArrIndex++] = secondHalfArr[secondArrCurrentIndex++];
		}
		// vay tong cong se ton 2^0 + 2^1 + ... + 2^(log2(nums.length)-1) +
		// log2(nums.length) * nums.length effort
	}

	public static int findSingleNumber(int[] nums) {
		// vi array da sort nen worst cua findSingleNumber la 1 + nums.length / 2
		// vay tong cong effot de tim so single la 2^0 + 2^1 + ... +
		// 2^(log2(nums.length)-1) + log2(nums.length) * nums.length + 1 + nums.length /
		// 2
		int singleNumber = nums[0];
		if (nums.length == 1)
			return singleNumber;
		for (int i = 1; i < nums.length; i++) {
			if (singleNumber == nums[i])
				singleNumber = nums[++i];
			else
				return singleNumber;
		}
		return singleNumber;
	}

	public static int singleNumber(int[] nums) {
		int singleNumber = nums[0];
		int count = 0;
		for (int i = 0; i < nums.length; i++) {
			if (nums[i] == nums.length)
				continue;
			boolean pairFound = false;
			for (int j = i + 1; j < nums.length; j++) {
				System.out.println(Arrays.toString(nums));
				count++;
				if (nums[i] == nums[j]) {
					pairFound = true;
					nums[j] = nums.length;
					break;
				}
			}
			if (!pairFound) {
				singleNumber = nums[i];
				break;
			}
		}
		System.out.println("N: " + nums.length + " - loop: " + count);
		return singleNumber;
	}

	public static int findSingle(int[] nums) {
		int[] firstHalf = new int[1 + nums.length / 2];
		int[] secondHalf = new int[1 + nums.length / 2];
		int firstHalfIndex = 0;
		int secondHalfIndex = 0;
		for (int num : nums) {
			if (num % 2 == 0) 
				firstHalf[firstHalfIndex++] = num;
			else
				secondHalf[secondHalfIndex++] = num;
		}
		if(firstHalfIndex > secondHalfIndex) {
			
		}else {
			
		}
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2022-10-10 02:58:05.149
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2022-10-10 02:58:05.149
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-10 02:58:05.156
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.Scanner;

public class MainDay3 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

		// SINGLE NUMBER
		int[] nums1 = { 2, 2, 1 };
		int[] nums2 = { 4, 1, 2, 1, 2 };
		int[] nums3 = { 1 };
		int[] nums4 = { 6, 3, 1, 7, 2, 5, 8, 4 };
		int[] nums5 = { 1, 2, 3, 4, 5, 6, 5, 6, 4, 3, 2, 1, 7 };
		1 3 5 5 3 1 7 a b c b c a d 
		2a+2b+2c+d =
		2(a+b+C) + d =
		2 4 6 6 4 2
		
		System.out.println("Average: " + findSingle(nums5));
//		mergeSort(nums5);
//		System.out.println("Sorted array: " + Arrays.toString(nums5));
//		System.out.println("Single number: " + findSingleNumber(nums5));
//		 PRIME NUMBER
//		int[] numbers = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };
//		for (int num : numbers) {
//			System.out.println("Is " + num + " a Prime number? " + isPrimeNumber(num));
//		}
		// PALINDROME
//		int[] intArr = { 1, 1, 1, 1 };
//		System.out.println("Is Palindrome: " + isPalindrome(intArr));
		// MIN MAX AVERAGE
//		int[] intArr = { 4, 6, 2, 1, 7, 9, 10, 15, 0 };
//		int min = intArr[0];
//		int max = intArr[0];
//		double average = 0;
//		for (int i = 0; i < intArr.length; i++) {
//			if (intArr[i] > max)
//				max = intArr[i];
//			if (intArr[i] < min)
//				min = intArr[i];
//			average += intArr[i];
//		}
//		System.out.println("Min is: " + min);
//		System.out.println("Max is: " + max);
//		System.out.println("Average is: " + Math.ceil(average * 100.00 / intArr.length) / 100.00);

		// GRADE
//		Scanner scanner = new Scanner(System.in);
//		System.out.println("Please enter your average point of Maths: ");
//		Double mathsPoint = scanner.nextDouble();
//		System.out.println("Your Maths Grade is: " + getGrade(mathsPoint));
//		System.out.println("Please enter your average point of English: ");
//		Double englishPoint = scanner.nextDouble();
//		System.out.println("Your English Grade is: " + getGrade(englishPoint));
//		System.out.println("Please enter your average point of Literature: ");
//		Double literaturePoint = scanner.nextDouble();
//		System.out.println("Your Literature Grade is: " + getGrade(literaturePoint));
//
//		Double averagePoint = Math.ceil((mathsPoint + englishPoint + literaturePoint) * 100.00 / 3) / 100.00;
//		System.out.println("Your Average Point is: " + averagePoint);
//
//		Double minPoint = (mathsPoint > englishPoint) ? englishPoint : mathsPoint;
//		minPoint = (minPoint > literaturePoint) ? literaturePoint : minPoint;
//		char grade;
//		if (minPoint < 5) {
//			grade = 'F';
//		} else if (averagePoint - minPoint > 1) {
//			grade = getGrade(minPoint + 1);
//			System.out.println("Your Grade is: " + grade);
//
//		} else {
//			grade = getGrade(averagePoint);
//			System.out.println("Your Grade is: " + grade);
//		}
//		switch (grade) {
//		case 'S':
//			System.out.println("Excellent Student");
//			break;
//		case 'A':
//			System.out.println("Good Student");
//			break;
//		case 'B':
//			System.out.println("Normal Student");
//			break;
//		case 'C':
//			System.out.println("Average Student");
//			break;
//		case 'D':
//			System.out.println("Not Bad Student");
//			break;
//		case 'F':
//			System.out.println("Fail Student");
//			break;
//		}
//		scanner.close();
	}

	public static char getGrade(double point) {
		if (point >= 9)
			return 'S';
		else if (point >= 8)
			return 'A';
		else if (point >= 7)
			return 'B';
		else if (point >= 6)
			return 'C';
		else if (point >= 5)
			return 'D';
		else
			return 'F';
	}

	public static boolean isPalindrome(int[] numbers) {
		if (numbers.length == 0)
			return false;
		else if (numbers.length == 1)
			return true;
		else {
			for (int i = 0; i < numbers.length / 2; i++) {
				if (numbers[i] != numbers[numbers.length - 1 - i])
					return false;
			}
			return true;
		}
	}

	// upgraded. Chi can chay toi 1 + number/2 la dc roi
	public static boolean isPrimeNumber(int number) {
		if (number <= 0)
			return false;
		else if (number <= 2)
			return true;
		else {
			for (int i = 2; i < 1 + number / 2; i++) {
				if (number % i == 0)
					return false;
			}
			return true;
		}
	}

	public static void mergeSort(int[] nums) {
		// chia doi nums thanh nums1 va nums2
		int endIndex = nums.length - 1;
		int middleIndex = nums.length / 2;
		int firstHalfArrSize = middleIndex;
		int secondHalArrSize = endIndex - middleIndex + 1;
		int[] firstHalfArr = new int[firstHalfArrSize];
		int[] secondHalfArr = new int[secondHalArrSize];
		// copy qua 2 sub array
		for (int i = 0; i < firstHalfArrSize; i++) {
			firstHalfArr[i] = nums[i];
		}
		for (int i = 0; i < secondHalArrSize; i++) {
			secondHalfArr[i] = nums[i + firstHalfArrSize];
		}
		// tiep tuc goi recursive cho toi khi nums.length = 1 moi bat dau swap
		// vay tu nums.length de chia xuong con 1 thi se co' log2(nums.length) lan chia
		// lan chia dau tien ton 1 effort
		// lan chia thu 2 ton 2 effort
		// lan chia thu 3 ton 4 effort
		// lan chia thu log2(nums.length) ton 2^(log2(nums.length) - 1) effort
		// vay tong cong ton 2^0 + 2^1 + 2^2 +..+ 2^(log2(nums.length)-1) effort de goi
		// recursive
		if (firstHalfArrSize > 1)
			mergeSort(firstHalfArr);
		if (secondHalArrSize > 1)
			mergeSort(secondHalfArr);
		// merge 2 sorted subarray
		int firstArrCurrentIndex = 0;
		int secondArrCurrentIndex = 0;
		int currentNumsArrIndex = 0;
		// loop qua 2 sub array de compare va copy qua nums cho toi khi finish 1 trong 2
		// cai array
		// moi recursive se loop qua firstHalf va secondHalf, tuc la nums.length effort
		// co log2(nums.length) level, vay tong cong ton log2(nums.length) * nums.length
		// effort
		while ((firstArrCurrentIndex < firstHalfArrSize) && (secondArrCurrentIndex < secondHalArrSize)) {
			if (firstHalfArr[firstArrCurrentIndex] <= secondHalfArr[secondArrCurrentIndex]) {
				nums[currentNumsArrIndex++] = firstHalfArr[firstArrCurrentIndex++];
			} else {
				nums[currentNumsArrIndex++] = secondHalfArr[secondArrCurrentIndex++];
			}
		}
		// copy phan con lai cua 1 trong 2 cai array qua nums
		if (firstArrCurrentIndex < firstHalfArrSize) {
			nums[currentNumsArrIndex++] = firstHalfArr[firstArrCurrentIndex++];
		} else if (secondArrCurrentIndex < secondHalArrSize) {
			nums[currentNumsArrIndex++] = secondHalfArr[secondArrCurrentIndex++];
		}
		// vay tong cong se ton 2^0 + 2^1 + ... + 2^(log2(nums.length)-1) +
		// log2(nums.length) * nums.length effort
	}

	public static int findSingleNumber(int[] nums) {
		// vi array da sort nen worst cua findSingleNumber la 1 + nums.length / 2
		// vay tong cong effot de tim so single la 2^0 + 2^1 + ... +
		// 2^(log2(nums.length)-1) + log2(nums.length) * nums.length + 1 + nums.length /
		// 2
		int singleNumber = nums[0];
		if (nums.length == 1)
			return singleNumber;
		for (int i = 1; i < nums.length; i++) {
			if (singleNumber == nums[i])
				singleNumber = nums[++i];
			else
				return singleNumber;
		}
		return singleNumber;
	}

	public static int singleNumber(int[] nums) {
		int singleNumber = nums[0];
		int count = 0;
		for (int i = 0; i < nums.length; i++) {
			if (nums[i] == nums.length)
				continue;
			boolean pairFound = false;
			for (int j = i + 1; j < nums.length; j++) {
				System.out.println(Arrays.toString(nums));
				count++;
				if (nums[i] == nums[j]) {
					pairFound = true;
					nums[j] = nums.length;
					break;
				}
			}
			if (!pairFound) {
				singleNumber = nums[i];
				break;
			}
		}
		System.out.println("N: " + nums.length + " - loop: " + count);
		return singleNumber;
	}

	public static int findSingle(int[] nums) {
		int[] firstHalf = new int[1 + nums.length / 2];
		int[] secondHalf = new int[1 + nums.length / 2];
		int firstHalfIndex = 0;
		int secondHalfIndex = 0;
		for (int num : nums) {
			if (num % 2 == 0) 
				firstHalf[firstHalfIndex++] = num;
			else
				secondHalf[secondHalfIndex++] = num;
		}
		if(firstHalfIndex > secondHalfIndex) {
			
		}else {
			
		}
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-10-10 02:58:05.157
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-10-10 02:58:05.157
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-10 02:58:05.712
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.Scanner;

public class MainDay3 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

		// SINGLE NUMBER
		int[] nums1 = { 2, 2, 1 };
		int[] nums2 = { 4, 1, 2, 1, 2 };
		int[] nums3 = { 1 };
		int[] nums4 = { 6, 3, 1, 7, 2, 5, 8, 4 };
		int[] nums5 = { 1, 2, 3, 4, 5, 6, 5, 6, 4, 3, 2, 1, 7 };
		1 3 5 5 3 1 7 a b c b c a d 
		2a+2b+2c+d =
		2(a+b+C) + d =
		
		2 4 6 6 4 2
		
		System.out.println("Average: " + findSingle(nums5));
//		mergeSort(nums5);
//		System.out.println("Sorted array: " + Arrays.toString(nums5));
//		System.out.println("Single number: " + findSingleNumber(nums5));
//		 PRIME NUMBER
//		int[] numbers = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };
//		for (int num : numbers) {
//			System.out.println("Is " + num + " a Prime number? " + isPrimeNumber(num));
//		}
		// PALINDROME
//		int[] intArr = { 1, 1, 1, 1 };
//		System.out.println("Is Palindrome: " + isPalindrome(intArr));
		// MIN MAX AVERAGE
//		int[] intArr = { 4, 6, 2, 1, 7, 9, 10, 15, 0 };
//		int min = intArr[0];
//		int max = intArr[0];
//		double average = 0;
//		for (int i = 0; i < intArr.length; i++) {
//			if (intArr[i] > max)
//				max = intArr[i];
//			if (intArr[i] < min)
//				min = intArr[i];
//			average += intArr[i];
//		}
//		System.out.println("Min is: " + min);
//		System.out.println("Max is: " + max);
//		System.out.println("Average is: " + Math.ceil(average * 100.00 / intArr.length) / 100.00);

		// GRADE
//		Scanner scanner = new Scanner(System.in);
//		System.out.println("Please enter your average point of Maths: ");
//		Double mathsPoint = scanner.nextDouble();
//		System.out.println("Your Maths Grade is: " + getGrade(mathsPoint));
//		System.out.println("Please enter your average point of English: ");
//		Double englishPoint = scanner.nextDouble();
//		System.out.println("Your English Grade is: " + getGrade(englishPoint));
//		System.out.println("Please enter your average point of Literature: ");
//		Double literaturePoint = scanner.nextDouble();
//		System.out.println("Your Literature Grade is: " + getGrade(literaturePoint));
//
//		Double averagePoint = Math.ceil((mathsPoint + englishPoint + literaturePoint) * 100.00 / 3) / 100.00;
//		System.out.println("Your Average Point is: " + averagePoint);
//
//		Double minPoint = (mathsPoint > englishPoint) ? englishPoint : mathsPoint;
//		minPoint = (minPoint > literaturePoint) ? literaturePoint : minPoint;
//		char grade;
//		if (minPoint < 5) {
//			grade = 'F';
//		} else if (averagePoint - minPoint > 1) {
//			grade = getGrade(minPoint + 1);
//			System.out.println("Your Grade is: " + grade);
//
//		} else {
//			grade = getGrade(averagePoint);
//			System.out.println("Your Grade is: " + grade);
//		}
//		switch (grade) {
//		case 'S':
//			System.out.println("Excellent Student");
//			break;
//		case 'A':
//			System.out.println("Good Student");
//			break;
//		case 'B':
//			System.out.println("Normal Student");
//			break;
//		case 'C':
//			System.out.println("Average Student");
//			break;
//		case 'D':
//			System.out.println("Not Bad Student");
//			break;
//		case 'F':
//			System.out.println("Fail Student");
//			break;
//		}
//		scanner.close();
	}

	public static char getGrade(double point) {
		if (point >= 9)
			return 'S';
		else if (point >= 8)
			return 'A';
		else if (point >= 7)
			return 'B';
		else if (point >= 6)
			return 'C';
		else if (point >= 5)
			return 'D';
		else
			return 'F';
	}

	public static boolean isPalindrome(int[] numbers) {
		if (numbers.length == 0)
			return false;
		else if (numbers.length == 1)
			return true;
		else {
			for (int i = 0; i < numbers.length / 2; i++) {
				if (numbers[i] != numbers[numbers.length - 1 - i])
					return false;
			}
			return true;
		}
	}

	// upgraded. Chi can chay toi 1 + number/2 la dc roi
	public static boolean isPrimeNumber(int number) {
		if (number <= 0)
			return false;
		else if (number <= 2)
			return true;
		else {
			for (int i = 2; i < 1 + number / 2; i++) {
				if (number % i == 0)
					return false;
			}
			return true;
		}
	}

	public static void mergeSort(int[] nums) {
		// chia doi nums thanh nums1 va nums2
		int endIndex = nums.length - 1;
		int middleIndex = nums.length / 2;
		int firstHalfArrSize = middleIndex;
		int secondHalArrSize = endIndex - middleIndex + 1;
		int[] firstHalfArr = new int[firstHalfArrSize];
		int[] secondHalfArr = new int[secondHalArrSize];
		// copy qua 2 sub array
		for (int i = 0; i < firstHalfArrSize; i++) {
			firstHalfArr[i] = nums[i];
		}
		for (int i = 0; i < secondHalArrSize; i++) {
			secondHalfArr[i] = nums[i + firstHalfArrSize];
		}
		// tiep tuc goi recursive cho toi khi nums.length = 1 moi bat dau swap
		// vay tu nums.length de chia xuong con 1 thi se co' log2(nums.length) lan chia
		// lan chia dau tien ton 1 effort
		// lan chia thu 2 ton 2 effort
		// lan chia thu 3 ton 4 effort
		// lan chia thu log2(nums.length) ton 2^(log2(nums.length) - 1) effort
		// vay tong cong ton 2^0 + 2^1 + 2^2 +..+ 2^(log2(nums.length)-1) effort de goi
		// recursive
		if (firstHalfArrSize > 1)
			mergeSort(firstHalfArr);
		if (secondHalArrSize > 1)
			mergeSort(secondHalfArr);
		// merge 2 sorted subarray
		int firstArrCurrentIndex = 0;
		int secondArrCurrentIndex = 0;
		int currentNumsArrIndex = 0;
		// loop qua 2 sub array de compare va copy qua nums cho toi khi finish 1 trong 2
		// cai array
		// moi recursive se loop qua firstHalf va secondHalf, tuc la nums.length effort
		// co log2(nums.length) level, vay tong cong ton log2(nums.length) * nums.length
		// effort
		while ((firstArrCurrentIndex < firstHalfArrSize) && (secondArrCurrentIndex < secondHalArrSize)) {
			if (firstHalfArr[firstArrCurrentIndex] <= secondHalfArr[secondArrCurrentIndex]) {
				nums[currentNumsArrIndex++] = firstHalfArr[firstArrCurrentIndex++];
			} else {
				nums[currentNumsArrIndex++] = secondHalfArr[secondArrCurrentIndex++];
			}
		}
		// copy phan con lai cua 1 trong 2 cai array qua nums
		if (firstArrCurrentIndex < firstHalfArrSize) {
			nums[currentNumsArrIndex++] = firstHalfArr[firstArrCurrentIndex++];
		} else if (secondArrCurrentIndex < secondHalArrSize) {
			nums[currentNumsArrIndex++] = secondHalfArr[secondArrCurrentIndex++];
		}
		// vay tong cong se ton 2^0 + 2^1 + ... + 2^(log2(nums.length)-1) +
		// log2(nums.length) * nums.length effort
	}

	public static int findSingleNumber(int[] nums) {
		// vi array da sort nen worst cua findSingleNumber la 1 + nums.length / 2
		// vay tong cong effot de tim so single la 2^0 + 2^1 + ... +
		// 2^(log2(nums.length)-1) + log2(nums.length) * nums.length + 1 + nums.length /
		// 2
		int singleNumber = nums[0];
		if (nums.length == 1)
			return singleNumber;
		for (int i = 1; i < nums.length; i++) {
			if (singleNumber == nums[i])
				singleNumber = nums[++i];
			else
				return singleNumber;
		}
		return singleNumber;
	}

	public static int singleNumber(int[] nums) {
		int singleNumber = nums[0];
		int count = 0;
		for (int i = 0; i < nums.length; i++) {
			if (nums[i] == nums.length)
				continue;
			boolean pairFound = false;
			for (int j = i + 1; j < nums.length; j++) {
				System.out.println(Arrays.toString(nums));
				count++;
				if (nums[i] == nums[j]) {
					pairFound = true;
					nums[j] = nums.length;
					break;
				}
			}
			if (!pairFound) {
				singleNumber = nums[i];
				break;
			}
		}
		System.out.println("N: " + nums.length + " - loop: " + count);
		return singleNumber;
	}

	public static int findSingle(int[] nums) {
		int[] firstHalf = new int[1 + nums.length / 2];
		int[] secondHalf = new int[1 + nums.length / 2];
		int firstHalfIndex = 0;
		int secondHalfIndex = 0;
		for (int num : nums) {
			if (num % 2 == 0) 
				firstHalf[firstHalfIndex++] = num;
			else
				secondHalf[secondHalfIndex++] = num;
		}
		if(firstHalfIndex > secondHalfIndex) {
			
		}else {
			
		}
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2022-10-10 02:58:05.713
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2022-10-10 02:58:05.713
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-10 02:58:05.720
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.Scanner;

public class MainDay3 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

		// SINGLE NUMBER
		int[] nums1 = { 2, 2, 1 };
		int[] nums2 = { 4, 1, 2, 1, 2 };
		int[] nums3 = { 1 };
		int[] nums4 = { 6, 3, 1, 7, 2, 5, 8, 4 };
		int[] nums5 = { 1, 2, 3, 4, 5, 6, 5, 6, 4, 3, 2, 1, 7 };
		1 3 5 5 3 1 7 a b c b c a d 
		2a+2b+2c+d =
		2(a+b+C) + d =
		
		2 4 6 6 4 2
		
		System.out.println("Average: " + findSingle(nums5));
//		mergeSort(nums5);
//		System.out.println("Sorted array: " + Arrays.toString(nums5));
//		System.out.println("Single number: " + findSingleNumber(nums5));
//		 PRIME NUMBER
//		int[] numbers = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };
//		for (int num : numbers) {
//			System.out.println("Is " + num + " a Prime number? " + isPrimeNumber(num));
//		}
		// PALINDROME
//		int[] intArr = { 1, 1, 1, 1 };
//		System.out.println("Is Palindrome: " + isPalindrome(intArr));
		// MIN MAX AVERAGE
//		int[] intArr = { 4, 6, 2, 1, 7, 9, 10, 15, 0 };
//		int min = intArr[0];
//		int max = intArr[0];
//		double average = 0;
//		for (int i = 0; i < intArr.length; i++) {
//			if (intArr[i] > max)
//				max = intArr[i];
//			if (intArr[i] < min)
//				min = intArr[i];
//			average += intArr[i];
//		}
//		System.out.println("Min is: " + min);
//		System.out.println("Max is: " + max);
//		System.out.println("Average is: " + Math.ceil(average * 100.00 / intArr.length) / 100.00);

		// GRADE
//		Scanner scanner = new Scanner(System.in);
//		System.out.println("Please enter your average point of Maths: ");
//		Double mathsPoint = scanner.nextDouble();
//		System.out.println("Your Maths Grade is: " + getGrade(mathsPoint));
//		System.out.println("Please enter your average point of English: ");
//		Double englishPoint = scanner.nextDouble();
//		System.out.println("Your English Grade is: " + getGrade(englishPoint));
//		System.out.println("Please enter your average point of Literature: ");
//		Double literaturePoint = scanner.nextDouble();
//		System.out.println("Your Literature Grade is: " + getGrade(literaturePoint));
//
//		Double averagePoint = Math.ceil((mathsPoint + englishPoint + literaturePoint) * 100.00 / 3) / 100.00;
//		System.out.println("Your Average Point is: " + averagePoint);
//
//		Double minPoint = (mathsPoint > englishPoint) ? englishPoint : mathsPoint;
//		minPoint = (minPoint > literaturePoint) ? literaturePoint : minPoint;
//		char grade;
//		if (minPoint < 5) {
//			grade = 'F';
//		} else if (averagePoint - minPoint > 1) {
//			grade = getGrade(minPoint + 1);
//			System.out.println("Your Grade is: " + grade);
//
//		} else {
//			grade = getGrade(averagePoint);
//			System.out.println("Your Grade is: " + grade);
//		}
//		switch (grade) {
//		case 'S':
//			System.out.println("Excellent Student");
//			break;
//		case 'A':
//			System.out.println("Good Student");
//			break;
//		case 'B':
//			System.out.println("Normal Student");
//			break;
//		case 'C':
//			System.out.println("Average Student");
//			break;
//		case 'D':
//			System.out.println("Not Bad Student");
//			break;
//		case 'F':
//			System.out.println("Fail Student");
//			break;
//		}
//		scanner.close();
	}

	public static char getGrade(double point) {
		if (point >= 9)
			return 'S';
		else if (point >= 8)
			return 'A';
		else if (point >= 7)
			return 'B';
		else if (point >= 6)
			return 'C';
		else if (point >= 5)
			return 'D';
		else
			return 'F';
	}

	public static boolean isPalindrome(int[] numbers) {
		if (numbers.length == 0)
			return false;
		else if (numbers.length == 1)
			return true;
		else {
			for (int i = 0; i < numbers.length / 2; i++) {
				if (numbers[i] != numbers[numbers.length - 1 - i])
					return false;
			}
			return true;
		}
	}

	// upgraded. Chi can chay toi 1 + number/2 la dc roi
	public static boolean isPrimeNumber(int number) {
		if (number <= 0)
			return false;
		else if (number <= 2)
			return true;
		else {
			for (int i = 2; i < 1 + number / 2; i++) {
				if (number % i == 0)
					return false;
			}
			return true;
		}
	}

	public static void mergeSort(int[] nums) {
		// chia doi nums thanh nums1 va nums2
		int endIndex = nums.length - 1;
		int middleIndex = nums.length / 2;
		int firstHalfArrSize = middleIndex;
		int secondHalArrSize = endIndex - middleIndex + 1;
		int[] firstHalfArr = new int[firstHalfArrSize];
		int[] secondHalfArr = new int[secondHalArrSize];
		// copy qua 2 sub array
		for (int i = 0; i < firstHalfArrSize; i++) {
			firstHalfArr[i] = nums[i];
		}
		for (int i = 0; i < secondHalArrSize; i++) {
			secondHalfArr[i] = nums[i + firstHalfArrSize];
		}
		// tiep tuc goi recursive cho toi khi nums.length = 1 moi bat dau swap
		// vay tu nums.length de chia xuong con 1 thi se co' log2(nums.length) lan chia
		// lan chia dau tien ton 1 effort
		// lan chia thu 2 ton 2 effort
		// lan chia thu 3 ton 4 effort
		// lan chia thu log2(nums.length) ton 2^(log2(nums.length) - 1) effort
		// vay tong cong ton 2^0 + 2^1 + 2^2 +..+ 2^(log2(nums.length)-1) effort de goi
		// recursive
		if (firstHalfArrSize > 1)
			mergeSort(firstHalfArr);
		if (secondHalArrSize > 1)
			mergeSort(secondHalfArr);
		// merge 2 sorted subarray
		int firstArrCurrentIndex = 0;
		int secondArrCurrentIndex = 0;
		int currentNumsArrIndex = 0;
		// loop qua 2 sub array de compare va copy qua nums cho toi khi finish 1 trong 2
		// cai array
		// moi recursive se loop qua firstHalf va secondHalf, tuc la nums.length effort
		// co log2(nums.length) level, vay tong cong ton log2(nums.length) * nums.length
		// effort
		while ((firstArrCurrentIndex < firstHalfArrSize) && (secondArrCurrentIndex < secondHalArrSize)) {
			if (firstHalfArr[firstArrCurrentIndex] <= secondHalfArr[secondArrCurrentIndex]) {
				nums[currentNumsArrIndex++] = firstHalfArr[firstArrCurrentIndex++];
			} else {
				nums[currentNumsArrIndex++] = secondHalfArr[secondArrCurrentIndex++];
			}
		}
		// copy phan con lai cua 1 trong 2 cai array qua nums
		if (firstArrCurrentIndex < firstHalfArrSize) {
			nums[currentNumsArrIndex++] = firstHalfArr[firstArrCurrentIndex++];
		} else if (secondArrCurrentIndex < secondHalArrSize) {
			nums[currentNumsArrIndex++] = secondHalfArr[secondArrCurrentIndex++];
		}
		// vay tong cong se ton 2^0 + 2^1 + ... + 2^(log2(nums.length)-1) +
		// log2(nums.length) * nums.length effort
	}

	public static int findSingleNumber(int[] nums) {
		// vi array da sort nen worst cua findSingleNumber la 1 + nums.length / 2
		// vay tong cong effot de tim so single la 2^0 + 2^1 + ... +
		// 2^(log2(nums.length)-1) + log2(nums.length) * nums.length + 1 + nums.length /
		// 2
		int singleNumber = nums[0];
		if (nums.length == 1)
			return singleNumber;
		for (int i = 1; i < nums.length; i++) {
			if (singleNumber == nums[i])
				singleNumber = nums[++i];
			else
				return singleNumber;
		}
		return singleNumber;
	}

	public static int singleNumber(int[] nums) {
		int singleNumber = nums[0];
		int count = 0;
		for (int i = 0; i < nums.length; i++) {
			if (nums[i] == nums.length)
				continue;
			boolean pairFound = false;
			for (int j = i + 1; j < nums.length; j++) {
				System.out.println(Arrays.toString(nums));
				count++;
				if (nums[i] == nums[j]) {
					pairFound = true;
					nums[j] = nums.length;
					break;
				}
			}
			if (!pairFound) {
				singleNumber = nums[i];
				break;
			}
		}
		System.out.println("N: " + nums.length + " - loop: " + count);
		return singleNumber;
	}

	public static int findSingle(int[] nums) {
		int[] firstHalf = new int[1 + nums.length / 2];
		int[] secondHalf = new int[1 + nums.length / 2];
		int firstHalfIndex = 0;
		int secondHalfIndex = 0;
		for (int num : nums) {
			if (num % 2 == 0) 
				firstHalf[firstHalfIndex++] = num;
			else
				secondHalf[secondHalfIndex++] = num;
		}
		if(firstHalfIndex > secondHalfIndex) {
			
		}else {
			
		}
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-10-10 02:58:05.720
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-10-10 02:58:05.721
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-10 02:58:29.009
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.Scanner;

public class MainDay3 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

		// SINGLE NUMBER
		int[] nums1 = { 2, 2, 1 };
		int[] nums2 = { 4, 1, 2, 1, 2 };
		int[] nums3 = { 1 };
		int[] nums4 = { 6, 3, 1, 7, 2, 5, 8, 4 };
		int[] nums5 = { 1, 2, 3, 4, 5, 6, 5, 6, 4, 3, 2, 1, 7 };
		1 3 5 5 3 1 7 a b c b c a d 
		2a+2b+2c+d =
		2(a+b+C) + d
		2 4 6 6 4 2
		
		System.out.println("Average: " + findSingle(nums5));
//		mergeSort(nums5);
//		System.out.println("Sorted array: " + Arrays.toString(nums5));
//		System.out.println("Single number: " + findSingleNumber(nums5));
//		 PRIME NUMBER
//		int[] numbers = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };
//		for (int num : numbers) {
//			System.out.println("Is " + num + " a Prime number? " + isPrimeNumber(num));
//		}
		// PALINDROME
//		int[] intArr = { 1, 1, 1, 1 };
//		System.out.println("Is Palindrome: " + isPalindrome(intArr));
		// MIN MAX AVERAGE
//		int[] intArr = { 4, 6, 2, 1, 7, 9, 10, 15, 0 };
//		int min = intArr[0];
//		int max = intArr[0];
//		double average = 0;
//		for (int i = 0; i < intArr.length; i++) {
//			if (intArr[i] > max)
//				max = intArr[i];
//			if (intArr[i] < min)
//				min = intArr[i];
//			average += intArr[i];
//		}
//		System.out.println("Min is: " + min);
//		System.out.println("Max is: " + max);
//		System.out.println("Average is: " + Math.ceil(average * 100.00 / intArr.length) / 100.00);

		// GRADE
//		Scanner scanner = new Scanner(System.in);
//		System.out.println("Please enter your average point of Maths: ");
//		Double mathsPoint = scanner.nextDouble();
//		System.out.println("Your Maths Grade is: " + getGrade(mathsPoint));
//		System.out.println("Please enter your average point of English: ");
//		Double englishPoint = scanner.nextDouble();
//		System.out.println("Your English Grade is: " + getGrade(englishPoint));
//		System.out.println("Please enter your average point of Literature: ");
//		Double literaturePoint = scanner.nextDouble();
//		System.out.println("Your Literature Grade is: " + getGrade(literaturePoint));
//
//		Double averagePoint = Math.ceil((mathsPoint + englishPoint + literaturePoint) * 100.00 / 3) / 100.00;
//		System.out.println("Your Average Point is: " + averagePoint);
//
//		Double minPoint = (mathsPoint > englishPoint) ? englishPoint : mathsPoint;
//		minPoint = (minPoint > literaturePoint) ? literaturePoint : minPoint;
//		char grade;
//		if (minPoint < 5) {
//			grade = 'F';
//		} else if (averagePoint - minPoint > 1) {
//			grade = getGrade(minPoint + 1);
//			System.out.println("Your Grade is: " + grade);
//
//		} else {
//			grade = getGrade(averagePoint);
//			System.out.println("Your Grade is: " + grade);
//		}
//		switch (grade) {
//		case 'S':
//			System.out.println("Excellent Student");
//			break;
//		case 'A':
//			System.out.println("Good Student");
//			break;
//		case 'B':
//			System.out.println("Normal Student");
//			break;
//		case 'C':
//			System.out.println("Average Student");
//			break;
//		case 'D':
//			System.out.println("Not Bad Student");
//			break;
//		case 'F':
//			System.out.println("Fail Student");
//			break;
//		}
//		scanner.close();
	}

	public static char getGrade(double point) {
		if (point >= 9)
			return 'S';
		else if (point >= 8)
			return 'A';
		else if (point >= 7)
			return 'B';
		else if (point >= 6)
			return 'C';
		else if (point >= 5)
			return 'D';
		else
			return 'F';
	}

	public static boolean isPalindrome(int[] numbers) {
		if (numbers.length == 0)
			return false;
		else if (numbers.length == 1)
			return true;
		else {
			for (int i = 0; i < numbers.length / 2; i++) {
				if (numbers[i] != numbers[numbers.length - 1 - i])
					return false;
			}
			return true;
		}
	}

	// upgraded. Chi can chay toi 1 + number/2 la dc roi
	public static boolean isPrimeNumber(int number) {
		if (number <= 0)
			return false;
		else if (number <= 2)
			return true;
		else {
			for (int i = 2; i < 1 + number / 2; i++) {
				if (number % i == 0)
					return false;
			}
			return true;
		}
	}

	public static void mergeSort(int[] nums) {
		// chia doi nums thanh nums1 va nums2
		int endIndex = nums.length - 1;
		int middleIndex = nums.length / 2;
		int firstHalfArrSize = middleIndex;
		int secondHalArrSize = endIndex - middleIndex + 1;
		int[] firstHalfArr = new int[firstHalfArrSize];
		int[] secondHalfArr = new int[secondHalArrSize];
		// copy qua 2 sub array
		for (int i = 0; i < firstHalfArrSize; i++) {
			firstHalfArr[i] = nums[i];
		}
		for (int i = 0; i < secondHalArrSize; i++) {
			secondHalfArr[i] = nums[i + firstHalfArrSize];
		}
		// tiep tuc goi recursive cho toi khi nums.length = 1 moi bat dau swap
		// vay tu nums.length de chia xuong con 1 thi se co' log2(nums.length) lan chia
		// lan chia dau tien ton 1 effort
		// lan chia thu 2 ton 2 effort
		// lan chia thu 3 ton 4 effort
		// lan chia thu log2(nums.length) ton 2^(log2(nums.length) - 1) effort
		// vay tong cong ton 2^0 + 2^1 + 2^2 +..+ 2^(log2(nums.length)-1) effort de goi
		// recursive
		if (firstHalfArrSize > 1)
			mergeSort(firstHalfArr);
		if (secondHalArrSize > 1)
			mergeSort(secondHalfArr);
		// merge 2 sorted subarray
		int firstArrCurrentIndex = 0;
		int secondArrCurrentIndex = 0;
		int currentNumsArrIndex = 0;
		// loop qua 2 sub array de compare va copy qua nums cho toi khi finish 1 trong 2
		// cai array
		// moi recursive se loop qua firstHalf va secondHalf, tuc la nums.length effort
		// co log2(nums.length) level, vay tong cong ton log2(nums.length) * nums.length
		// effort
		while ((firstArrCurrentIndex < firstHalfArrSize) && (secondArrCurrentIndex < secondHalArrSize)) {
			if (firstHalfArr[firstArrCurrentIndex] <= secondHalfArr[secondArrCurrentIndex]) {
				nums[currentNumsArrIndex++] = firstHalfArr[firstArrCurrentIndex++];
			} else {
				nums[currentNumsArrIndex++] = secondHalfArr[secondArrCurrentIndex++];
			}
		}
		// copy phan con lai cua 1 trong 2 cai array qua nums
		if (firstArrCurrentIndex < firstHalfArrSize) {
			nums[currentNumsArrIndex++] = firstHalfArr[firstArrCurrentIndex++];
		} else if (secondArrCurrentIndex < secondHalArrSize) {
			nums[currentNumsArrIndex++] = secondHalfArr[secondArrCurrentIndex++];
		}
		// vay tong cong se ton 2^0 + 2^1 + ... + 2^(log2(nums.length)-1) +
		// log2(nums.length) * nums.length effort
	}

	public static int findSingleNumber(int[] nums) {
		// vi array da sort nen worst cua findSingleNumber la 1 + nums.length / 2
		// vay tong cong effot de tim so single la 2^0 + 2^1 + ... +
		// 2^(log2(nums.length)-1) + log2(nums.length) * nums.length + 1 + nums.length /
		// 2
		int singleNumber = nums[0];
		if (nums.length == 1)
			return singleNumber;
		for (int i = 1; i < nums.length; i++) {
			if (singleNumber == nums[i])
				singleNumber = nums[++i];
			else
				return singleNumber;
		}
		return singleNumber;
	}

	public static int singleNumber(int[] nums) {
		int singleNumber = nums[0];
		int count = 0;
		for (int i = 0; i < nums.length; i++) {
			if (nums[i] == nums.length)
				continue;
			boolean pairFound = false;
			for (int j = i + 1; j < nums.length; j++) {
				System.out.println(Arrays.toString(nums));
				count++;
				if (nums[i] == nums[j]) {
					pairFound = true;
					nums[j] = nums.length;
					break;
				}
			}
			if (!pairFound) {
				singleNumber = nums[i];
				break;
			}
		}
		System.out.println("N: " + nums.length + " - loop: " + count);
		return singleNumber;
	}

	public static int findSingle(int[] nums) {
		int[] firstHalf = new int[1 + nums.length / 2];
		int[] secondHalf = new int[1 + nums.length / 2];
		int firstHalfIndex = 0;
		int secondHalfIndex = 0;
		for (int num : nums) {
			if (num % 2 == 0) 
				firstHalf[firstHalfIndex++] = num;
			else
				secondHalf[secondHalfIndex++] = num;
		}
		if(firstHalfIndex > secondHalfIndex) {
			
		}else {
			
		}
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2022-10-10 02:58:29.009
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2022-10-10 02:58:29.010
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-10 02:58:29.020
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.Scanner;

public class MainDay3 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

		// SINGLE NUMBER
		int[] nums1 = { 2, 2, 1 };
		int[] nums2 = { 4, 1, 2, 1, 2 };
		int[] nums3 = { 1 };
		int[] nums4 = { 6, 3, 1, 7, 2, 5, 8, 4 };
		int[] nums5 = { 1, 2, 3, 4, 5, 6, 5, 6, 4, 3, 2, 1, 7 };
		1 3 5 5 3 1 7 a b c b c a d 
		2a+2b+2c+d =
		2(a+b+C) + d
		2 4 6 6 4 2
		
		System.out.println("Average: " + findSingle(nums5));
//		mergeSort(nums5);
//		System.out.println("Sorted array: " + Arrays.toString(nums5));
//		System.out.println("Single number: " + findSingleNumber(nums5));
//		 PRIME NUMBER
//		int[] numbers = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };
//		for (int num : numbers) {
//			System.out.println("Is " + num + " a Prime number? " + isPrimeNumber(num));
//		}
		// PALINDROME
//		int[] intArr = { 1, 1, 1, 1 };
//		System.out.println("Is Palindrome: " + isPalindrome(intArr));
		// MIN MAX AVERAGE
//		int[] intArr = { 4, 6, 2, 1, 7, 9, 10, 15, 0 };
//		int min = intArr[0];
//		int max = intArr[0];
//		double average = 0;
//		for (int i = 0; i < intArr.length; i++) {
//			if (intArr[i] > max)
//				max = intArr[i];
//			if (intArr[i] < min)
//				min = intArr[i];
//			average += intArr[i];
//		}
//		System.out.println("Min is: " + min);
//		System.out.println("Max is: " + max);
//		System.out.println("Average is: " + Math.ceil(average * 100.00 / intArr.length) / 100.00);

		// GRADE
//		Scanner scanner = new Scanner(System.in);
//		System.out.println("Please enter your average point of Maths: ");
//		Double mathsPoint = scanner.nextDouble();
//		System.out.println("Your Maths Grade is: " + getGrade(mathsPoint));
//		System.out.println("Please enter your average point of English: ");
//		Double englishPoint = scanner.nextDouble();
//		System.out.println("Your English Grade is: " + getGrade(englishPoint));
//		System.out.println("Please enter your average point of Literature: ");
//		Double literaturePoint = scanner.nextDouble();
//		System.out.println("Your Literature Grade is: " + getGrade(literaturePoint));
//
//		Double averagePoint = Math.ceil((mathsPoint + englishPoint + literaturePoint) * 100.00 / 3) / 100.00;
//		System.out.println("Your Average Point is: " + averagePoint);
//
//		Double minPoint = (mathsPoint > englishPoint) ? englishPoint : mathsPoint;
//		minPoint = (minPoint > literaturePoint) ? literaturePoint : minPoint;
//		char grade;
//		if (minPoint < 5) {
//			grade = 'F';
//		} else if (averagePoint - minPoint > 1) {
//			grade = getGrade(minPoint + 1);
//			System.out.println("Your Grade is: " + grade);
//
//		} else {
//			grade = getGrade(averagePoint);
//			System.out.println("Your Grade is: " + grade);
//		}
//		switch (grade) {
//		case 'S':
//			System.out.println("Excellent Student");
//			break;
//		case 'A':
//			System.out.println("Good Student");
//			break;
//		case 'B':
//			System.out.println("Normal Student");
//			break;
//		case 'C':
//			System.out.println("Average Student");
//			break;
//		case 'D':
//			System.out.println("Not Bad Student");
//			break;
//		case 'F':
//			System.out.println("Fail Student");
//			break;
//		}
//		scanner.close();
	}

	public static char getGrade(double point) {
		if (point >= 9)
			return 'S';
		else if (point >= 8)
			return 'A';
		else if (point >= 7)
			return 'B';
		else if (point >= 6)
			return 'C';
		else if (point >= 5)
			return 'D';
		else
			return 'F';
	}

	public static boolean isPalindrome(int[] numbers) {
		if (numbers.length == 0)
			return false;
		else if (numbers.length == 1)
			return true;
		else {
			for (int i = 0; i < numbers.length / 2; i++) {
				if (numbers[i] != numbers[numbers.length - 1 - i])
					return false;
			}
			return true;
		}
	}

	// upgraded. Chi can chay toi 1 + number/2 la dc roi
	public static boolean isPrimeNumber(int number) {
		if (number <= 0)
			return false;
		else if (number <= 2)
			return true;
		else {
			for (int i = 2; i < 1 + number / 2; i++) {
				if (number % i == 0)
					return false;
			}
			return true;
		}
	}

	public static void mergeSort(int[] nums) {
		// chia doi nums thanh nums1 va nums2
		int endIndex = nums.length - 1;
		int middleIndex = nums.length / 2;
		int firstHalfArrSize = middleIndex;
		int secondHalArrSize = endIndex - middleIndex + 1;
		int[] firstHalfArr = new int[firstHalfArrSize];
		int[] secondHalfArr = new int[secondHalArrSize];
		// copy qua 2 sub array
		for (int i = 0; i < firstHalfArrSize; i++) {
			firstHalfArr[i] = nums[i];
		}
		for (int i = 0; i < secondHalArrSize; i++) {
			secondHalfArr[i] = nums[i + firstHalfArrSize];
		}
		// tiep tuc goi recursive cho toi khi nums.length = 1 moi bat dau swap
		// vay tu nums.length de chia xuong con 1 thi se co' log2(nums.length) lan chia
		// lan chia dau tien ton 1 effort
		// lan chia thu 2 ton 2 effort
		// lan chia thu 3 ton 4 effort
		// lan chia thu log2(nums.length) ton 2^(log2(nums.length) - 1) effort
		// vay tong cong ton 2^0 + 2^1 + 2^2 +..+ 2^(log2(nums.length)-1) effort de goi
		// recursive
		if (firstHalfArrSize > 1)
			mergeSort(firstHalfArr);
		if (secondHalArrSize > 1)
			mergeSort(secondHalfArr);
		// merge 2 sorted subarray
		int firstArrCurrentIndex = 0;
		int secondArrCurrentIndex = 0;
		int currentNumsArrIndex = 0;
		// loop qua 2 sub array de compare va copy qua nums cho toi khi finish 1 trong 2
		// cai array
		// moi recursive se loop qua firstHalf va secondHalf, tuc la nums.length effort
		// co log2(nums.length) level, vay tong cong ton log2(nums.length) * nums.length
		// effort
		while ((firstArrCurrentIndex < firstHalfArrSize) && (secondArrCurrentIndex < secondHalArrSize)) {
			if (firstHalfArr[firstArrCurrentIndex] <= secondHalfArr[secondArrCurrentIndex]) {
				nums[currentNumsArrIndex++] = firstHalfArr[firstArrCurrentIndex++];
			} else {
				nums[currentNumsArrIndex++] = secondHalfArr[secondArrCurrentIndex++];
			}
		}
		// copy phan con lai cua 1 trong 2 cai array qua nums
		if (firstArrCurrentIndex < firstHalfArrSize) {
			nums[currentNumsArrIndex++] = firstHalfArr[firstArrCurrentIndex++];
		} else if (secondArrCurrentIndex < secondHalArrSize) {
			nums[currentNumsArrIndex++] = secondHalfArr[secondArrCurrentIndex++];
		}
		// vay tong cong se ton 2^0 + 2^1 + ... + 2^(log2(nums.length)-1) +
		// log2(nums.length) * nums.length effort
	}

	public static int findSingleNumber(int[] nums) {
		// vi array da sort nen worst cua findSingleNumber la 1 + nums.length / 2
		// vay tong cong effot de tim so single la 2^0 + 2^1 + ... +
		// 2^(log2(nums.length)-1) + log2(nums.length) * nums.length + 1 + nums.length /
		// 2
		int singleNumber = nums[0];
		if (nums.length == 1)
			return singleNumber;
		for (int i = 1; i < nums.length; i++) {
			if (singleNumber == nums[i])
				singleNumber = nums[++i];
			else
				return singleNumber;
		}
		return singleNumber;
	}

	public static int singleNumber(int[] nums) {
		int singleNumber = nums[0];
		int count = 0;
		for (int i = 0; i < nums.length; i++) {
			if (nums[i] == nums.length)
				continue;
			boolean pairFound = false;
			for (int j = i + 1; j < nums.length; j++) {
				System.out.println(Arrays.toString(nums));
				count++;
				if (nums[i] == nums[j]) {
					pairFound = true;
					nums[j] = nums.length;
					break;
				}
			}
			if (!pairFound) {
				singleNumber = nums[i];
				break;
			}
		}
		System.out.println("N: " + nums.length + " - loop: " + count);
		return singleNumber;
	}

	public static int findSingle(int[] nums) {
		int[] firstHalf = new int[1 + nums.length / 2];
		int[] secondHalf = new int[1 + nums.length / 2];
		int firstHalfIndex = 0;
		int secondHalfIndex = 0;
		for (int num : nums) {
			if (num % 2 == 0) 
				firstHalf[firstHalfIndex++] = num;
			else
				secondHalf[secondHalfIndex++] = num;
		}
		if(firstHalfIndex > secondHalfIndex) {
			
		}else {
			
		}
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-10-10 02:58:29.020
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-10-10 02:58:29.021
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-10 02:58:30.006
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.Scanner;

public class MainDay3 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

		// SINGLE NUMBER
		int[] nums1 = { 2, 2, 1 };
		int[] nums2 = { 4, 1, 2, 1, 2 };
		int[] nums3 = { 1 };
		int[] nums4 = { 6, 3, 1, 7, 2, 5, 8, 4 };
		int[] nums5 = { 1, 2, 3, 4, 5, 6, 5, 6, 4, 3, 2, 1, 7 };
		1 3 5 5 3 1 7 a b c b c a d 
		2a+2b+2c+d =
		2(a+b+
		2 4 6 6 4 2
		
		System.out.println("Average: " + findSingle(nums5));
//		mergeSort(nums5);
//		System.out.println("Sorted array: " + Arrays.toString(nums5));
//		System.out.println("Single number: " + findSingleNumber(nums5));
//		 PRIME NUMBER
//		int[] numbers = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };
//		for (int num : numbers) {
//			System.out.println("Is " + num + " a Prime number? " + isPrimeNumber(num));
//		}
		// PALINDROME
//		int[] intArr = { 1, 1, 1, 1 };
//		System.out.println("Is Palindrome: " + isPalindrome(intArr));
		// MIN MAX AVERAGE
//		int[] intArr = { 4, 6, 2, 1, 7, 9, 10, 15, 0 };
//		int min = intArr[0];
//		int max = intArr[0];
//		double average = 0;
//		for (int i = 0; i < intArr.length; i++) {
//			if (intArr[i] > max)
//				max = intArr[i];
//			if (intArr[i] < min)
//				min = intArr[i];
//			average += intArr[i];
//		}
//		System.out.println("Min is: " + min);
//		System.out.println("Max is: " + max);
//		System.out.println("Average is: " + Math.ceil(average * 100.00 / intArr.length) / 100.00);

		// GRADE
//		Scanner scanner = new Scanner(System.in);
//		System.out.println("Please enter your average point of Maths: ");
//		Double mathsPoint = scanner.nextDouble();
//		System.out.println("Your Maths Grade is: " + getGrade(mathsPoint));
//		System.out.println("Please enter your average point of English: ");
//		Double englishPoint = scanner.nextDouble();
//		System.out.println("Your English Grade is: " + getGrade(englishPoint));
//		System.out.println("Please enter your average point of Literature: ");
//		Double literaturePoint = scanner.nextDouble();
//		System.out.println("Your Literature Grade is: " + getGrade(literaturePoint));
//
//		Double averagePoint = Math.ceil((mathsPoint + englishPoint + literaturePoint) * 100.00 / 3) / 100.00;
//		System.out.println("Your Average Point is: " + averagePoint);
//
//		Double minPoint = (mathsPoint > englishPoint) ? englishPoint : mathsPoint;
//		minPoint = (minPoint > literaturePoint) ? literaturePoint : minPoint;
//		char grade;
//		if (minPoint < 5) {
//			grade = 'F';
//		} else if (averagePoint - minPoint > 1) {
//			grade = getGrade(minPoint + 1);
//			System.out.println("Your Grade is: " + grade);
//
//		} else {
//			grade = getGrade(averagePoint);
//			System.out.println("Your Grade is: " + grade);
//		}
//		switch (grade) {
//		case 'S':
//			System.out.println("Excellent Student");
//			break;
//		case 'A':
//			System.out.println("Good Student");
//			break;
//		case 'B':
//			System.out.println("Normal Student");
//			break;
//		case 'C':
//			System.out.println("Average Student");
//			break;
//		case 'D':
//			System.out.println("Not Bad Student");
//			break;
//		case 'F':
//			System.out.println("Fail Student");
//			break;
//		}
//		scanner.close();
	}

	public static char getGrade(double point) {
		if (point >= 9)
			return 'S';
		else if (point >= 8)
			return 'A';
		else if (point >= 7)
			return 'B';
		else if (point >= 6)
			return 'C';
		else if (point >= 5)
			return 'D';
		else
			return 'F';
	}

	public static boolean isPalindrome(int[] numbers) {
		if (numbers.length == 0)
			return false;
		else if (numbers.length == 1)
			return true;
		else {
			for (int i = 0; i < numbers.length / 2; i++) {
				if (numbers[i] != numbers[numbers.length - 1 - i])
					return false;
			}
			return true;
		}
	}

	// upgraded. Chi can chay toi 1 + number/2 la dc roi
	public static boolean isPrimeNumber(int number) {
		if (number <= 0)
			return false;
		else if (number <= 2)
			return true;
		else {
			for (int i = 2; i < 1 + number / 2; i++) {
				if (number % i == 0)
					return false;
			}
			return true;
		}
	}

	public static void mergeSort(int[] nums) {
		// chia doi nums thanh nums1 va nums2
		int endIndex = nums.length - 1;
		int middleIndex = nums.length / 2;
		int firstHalfArrSize = middleIndex;
		int secondHalArrSize = endIndex - middleIndex + 1;
		int[] firstHalfArr = new int[firstHalfArrSize];
		int[] secondHalfArr = new int[secondHalArrSize];
		// copy qua 2 sub array
		for (int i = 0; i < firstHalfArrSize; i++) {
			firstHalfArr[i] = nums[i];
		}
		for (int i = 0; i < secondHalArrSize; i++) {
			secondHalfArr[i] = nums[i + firstHalfArrSize];
		}
		// tiep tuc goi recursive cho toi khi nums.length = 1 moi bat dau swap
		// vay tu nums.length de chia xuong con 1 thi se co' log2(nums.length) lan chia
		// lan chia dau tien ton 1 effort
		// lan chia thu 2 ton 2 effort
		// lan chia thu 3 ton 4 effort
		// lan chia thu log2(nums.length) ton 2^(log2(nums.length) - 1) effort
		// vay tong cong ton 2^0 + 2^1 + 2^2 +..+ 2^(log2(nums.length)-1) effort de goi
		// recursive
		if (firstHalfArrSize > 1)
			mergeSort(firstHalfArr);
		if (secondHalArrSize > 1)
			mergeSort(secondHalfArr);
		// merge 2 sorted subarray
		int firstArrCurrentIndex = 0;
		int secondArrCurrentIndex = 0;
		int currentNumsArrIndex = 0;
		// loop qua 2 sub array de compare va copy qua nums cho toi khi finish 1 trong 2
		// cai array
		// moi recursive se loop qua firstHalf va secondHalf, tuc la nums.length effort
		// co log2(nums.length) level, vay tong cong ton log2(nums.length) * nums.length
		// effort
		while ((firstArrCurrentIndex < firstHalfArrSize) && (secondArrCurrentIndex < secondHalArrSize)) {
			if (firstHalfArr[firstArrCurrentIndex] <= secondHalfArr[secondArrCurrentIndex]) {
				nums[currentNumsArrIndex++] = firstHalfArr[firstArrCurrentIndex++];
			} else {
				nums[currentNumsArrIndex++] = secondHalfArr[secondArrCurrentIndex++];
			}
		}
		// copy phan con lai cua 1 trong 2 cai array qua nums
		if (firstArrCurrentIndex < firstHalfArrSize) {
			nums[currentNumsArrIndex++] = firstHalfArr[firstArrCurrentIndex++];
		} else if (secondArrCurrentIndex < secondHalArrSize) {
			nums[currentNumsArrIndex++] = secondHalfArr[secondArrCurrentIndex++];
		}
		// vay tong cong se ton 2^0 + 2^1 + ... + 2^(log2(nums.length)-1) +
		// log2(nums.length) * nums.length effort
	}

	public static int findSingleNumber(int[] nums) {
		// vi array da sort nen worst cua findSingleNumber la 1 + nums.length / 2
		// vay tong cong effot de tim so single la 2^0 + 2^1 + ... +
		// 2^(log2(nums.length)-1) + log2(nums.length) * nums.length + 1 + nums.length /
		// 2
		int singleNumber = nums[0];
		if (nums.length == 1)
			return singleNumber;
		for (int i = 1; i < nums.length; i++) {
			if (singleNumber == nums[i])
				singleNumber = nums[++i];
			else
				return singleNumber;
		}
		return singleNumber;
	}

	public static int singleNumber(int[] nums) {
		int singleNumber = nums[0];
		int count = 0;
		for (int i = 0; i < nums.length; i++) {
			if (nums[i] == nums.length)
				continue;
			boolean pairFound = false;
			for (int j = i + 1; j < nums.length; j++) {
				System.out.println(Arrays.toString(nums));
				count++;
				if (nums[i] == nums[j]) {
					pairFound = true;
					nums[j] = nums.length;
					break;
				}
			}
			if (!pairFound) {
				singleNumber = nums[i];
				break;
			}
		}
		System.out.println("N: " + nums.length + " - loop: " + count);
		return singleNumber;
	}

	public static int findSingle(int[] nums) {
		int[] firstHalf = new int[1 + nums.length / 2];
		int[] secondHalf = new int[1 + nums.length / 2];
		int firstHalfIndex = 0;
		int secondHalfIndex = 0;
		for (int num : nums) {
			if (num % 2 == 0) 
				firstHalf[firstHalfIndex++] = num;
			else
				secondHalf[secondHalfIndex++] = num;
		}
		if(firstHalfIndex > secondHalfIndex) {
			
		}else {
			
		}
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2022-10-10 02:58:30.006
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2022-10-10 02:58:30.007
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-10 02:58:30.013
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.Scanner;

public class MainDay3 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

		// SINGLE NUMBER
		int[] nums1 = { 2, 2, 1 };
		int[] nums2 = { 4, 1, 2, 1, 2 };
		int[] nums3 = { 1 };
		int[] nums4 = { 6, 3, 1, 7, 2, 5, 8, 4 };
		int[] nums5 = { 1, 2, 3, 4, 5, 6, 5, 6, 4, 3, 2, 1, 7 };
		1 3 5 5 3 1 7 a b c b c a d 
		2a+2b+2c+d =
		2(a+b+
		2 4 6 6 4 2
		
		System.out.println("Average: " + findSingle(nums5));
//		mergeSort(nums5);
//		System.out.println("Sorted array: " + Arrays.toString(nums5));
//		System.out.println("Single number: " + findSingleNumber(nums5));
//		 PRIME NUMBER
//		int[] numbers = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };
//		for (int num : numbers) {
//			System.out.println("Is " + num + " a Prime number? " + isPrimeNumber(num));
//		}
		// PALINDROME
//		int[] intArr = { 1, 1, 1, 1 };
//		System.out.println("Is Palindrome: " + isPalindrome(intArr));
		// MIN MAX AVERAGE
//		int[] intArr = { 4, 6, 2, 1, 7, 9, 10, 15, 0 };
//		int min = intArr[0];
//		int max = intArr[0];
//		double average = 0;
//		for (int i = 0; i < intArr.length; i++) {
//			if (intArr[i] > max)
//				max = intArr[i];
//			if (intArr[i] < min)
//				min = intArr[i];
//			average += intArr[i];
//		}
//		System.out.println("Min is: " + min);
//		System.out.println("Max is: " + max);
//		System.out.println("Average is: " + Math.ceil(average * 100.00 / intArr.length) / 100.00);

		// GRADE
//		Scanner scanner = new Scanner(System.in);
//		System.out.println("Please enter your average point of Maths: ");
//		Double mathsPoint = scanner.nextDouble();
//		System.out.println("Your Maths Grade is: " + getGrade(mathsPoint));
//		System.out.println("Please enter your average point of English: ");
//		Double englishPoint = scanner.nextDouble();
//		System.out.println("Your English Grade is: " + getGrade(englishPoint));
//		System.out.println("Please enter your average point of Literature: ");
//		Double literaturePoint = scanner.nextDouble();
//		System.out.println("Your Literature Grade is: " + getGrade(literaturePoint));
//
//		Double averagePoint = Math.ceil((mathsPoint + englishPoint + literaturePoint) * 100.00 / 3) / 100.00;
//		System.out.println("Your Average Point is: " + averagePoint);
//
//		Double minPoint = (mathsPoint > englishPoint) ? englishPoint : mathsPoint;
//		minPoint = (minPoint > literaturePoint) ? literaturePoint : minPoint;
//		char grade;
//		if (minPoint < 5) {
//			grade = 'F';
//		} else if (averagePoint - minPoint > 1) {
//			grade = getGrade(minPoint + 1);
//			System.out.println("Your Grade is: " + grade);
//
//		} else {
//			grade = getGrade(averagePoint);
//			System.out.println("Your Grade is: " + grade);
//		}
//		switch (grade) {
//		case 'S':
//			System.out.println("Excellent Student");
//			break;
//		case 'A':
//			System.out.println("Good Student");
//			break;
//		case 'B':
//			System.out.println("Normal Student");
//			break;
//		case 'C':
//			System.out.println("Average Student");
//			break;
//		case 'D':
//			System.out.println("Not Bad Student");
//			break;
//		case 'F':
//			System.out.println("Fail Student");
//			break;
//		}
//		scanner.close();
	}

	public static char getGrade(double point) {
		if (point >= 9)
			return 'S';
		else if (point >= 8)
			return 'A';
		else if (point >= 7)
			return 'B';
		else if (point >= 6)
			return 'C';
		else if (point >= 5)
			return 'D';
		else
			return 'F';
	}

	public static boolean isPalindrome(int[] numbers) {
		if (numbers.length == 0)
			return false;
		else if (numbers.length == 1)
			return true;
		else {
			for (int i = 0; i < numbers.length / 2; i++) {
				if (numbers[i] != numbers[numbers.length - 1 - i])
					return false;
			}
			return true;
		}
	}

	// upgraded. Chi can chay toi 1 + number/2 la dc roi
	public static boolean isPrimeNumber(int number) {
		if (number <= 0)
			return false;
		else if (number <= 2)
			return true;
		else {
			for (int i = 2; i < 1 + number / 2; i++) {
				if (number % i == 0)
					return false;
			}
			return true;
		}
	}

	public static void mergeSort(int[] nums) {
		// chia doi nums thanh nums1 va nums2
		int endIndex = nums.length - 1;
		int middleIndex = nums.length / 2;
		int firstHalfArrSize = middleIndex;
		int secondHalArrSize = endIndex - middleIndex + 1;
		int[] firstHalfArr = new int[firstHalfArrSize];
		int[] secondHalfArr = new int[secondHalArrSize];
		// copy qua 2 sub array
		for (int i = 0; i < firstHalfArrSize; i++) {
			firstHalfArr[i] = nums[i];
		}
		for (int i = 0; i < secondHalArrSize; i++) {
			secondHalfArr[i] = nums[i + firstHalfArrSize];
		}
		// tiep tuc goi recursive cho toi khi nums.length = 1 moi bat dau swap
		// vay tu nums.length de chia xuong con 1 thi se co' log2(nums.length) lan chia
		// lan chia dau tien ton 1 effort
		// lan chia thu 2 ton 2 effort
		// lan chia thu 3 ton 4 effort
		// lan chia thu log2(nums.length) ton 2^(log2(nums.length) - 1) effort
		// vay tong cong ton 2^0 + 2^1 + 2^2 +..+ 2^(log2(nums.length)-1) effort de goi
		// recursive
		if (firstHalfArrSize > 1)
			mergeSort(firstHalfArr);
		if (secondHalArrSize > 1)
			mergeSort(secondHalfArr);
		// merge 2 sorted subarray
		int firstArrCurrentIndex = 0;
		int secondArrCurrentIndex = 0;
		int currentNumsArrIndex = 0;
		// loop qua 2 sub array de compare va copy qua nums cho toi khi finish 1 trong 2
		// cai array
		// moi recursive se loop qua firstHalf va secondHalf, tuc la nums.length effort
		// co log2(nums.length) level, vay tong cong ton log2(nums.length) * nums.length
		// effort
		while ((firstArrCurrentIndex < firstHalfArrSize) && (secondArrCurrentIndex < secondHalArrSize)) {
			if (firstHalfArr[firstArrCurrentIndex] <= secondHalfArr[secondArrCurrentIndex]) {
				nums[currentNumsArrIndex++] = firstHalfArr[firstArrCurrentIndex++];
			} else {
				nums[currentNumsArrIndex++] = secondHalfArr[secondArrCurrentIndex++];
			}
		}
		// copy phan con lai cua 1 trong 2 cai array qua nums
		if (firstArrCurrentIndex < firstHalfArrSize) {
			nums[currentNumsArrIndex++] = firstHalfArr[firstArrCurrentIndex++];
		} else if (secondArrCurrentIndex < secondHalArrSize) {
			nums[currentNumsArrIndex++] = secondHalfArr[secondArrCurrentIndex++];
		}
		// vay tong cong se ton 2^0 + 2^1 + ... + 2^(log2(nums.length)-1) +
		// log2(nums.length) * nums.length effort
	}

	public static int findSingleNumber(int[] nums) {
		// vi array da sort nen worst cua findSingleNumber la 1 + nums.length / 2
		// vay tong cong effot de tim so single la 2^0 + 2^1 + ... +
		// 2^(log2(nums.length)-1) + log2(nums.length) * nums.length + 1 + nums.length /
		// 2
		int singleNumber = nums[0];
		if (nums.length == 1)
			return singleNumber;
		for (int i = 1; i < nums.length; i++) {
			if (singleNumber == nums[i])
				singleNumber = nums[++i];
			else
				return singleNumber;
		}
		return singleNumber;
	}

	public static int singleNumber(int[] nums) {
		int singleNumber = nums[0];
		int count = 0;
		for (int i = 0; i < nums.length; i++) {
			if (nums[i] == nums.length)
				continue;
			boolean pairFound = false;
			for (int j = i + 1; j < nums.length; j++) {
				System.out.println(Arrays.toString(nums));
				count++;
				if (nums[i] == nums[j]) {
					pairFound = true;
					nums[j] = nums.length;
					break;
				}
			}
			if (!pairFound) {
				singleNumber = nums[i];
				break;
			}
		}
		System.out.println("N: " + nums.length + " - loop: " + count);
		return singleNumber;
	}

	public static int findSingle(int[] nums) {
		int[] firstHalf = new int[1 + nums.length / 2];
		int[] secondHalf = new int[1 + nums.length / 2];
		int firstHalfIndex = 0;
		int secondHalfIndex = 0;
		for (int num : nums) {
			if (num % 2 == 0) 
				firstHalf[firstHalfIndex++] = num;
			else
				secondHalf[secondHalfIndex++] = num;
		}
		if(firstHalfIndex > secondHalfIndex) {
			
		}else {
			
		}
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-10-10 02:58:30.014
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-10-10 02:58:30.015
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-10 02:58:31.086
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.Scanner;

public class MainDay3 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

		// SINGLE NUMBER
		int[] nums1 = { 2, 2, 1 };
		int[] nums2 = { 4, 1, 2, 1, 2 };
		int[] nums3 = { 1 };
		int[] nums4 = { 6, 3, 1, 7, 2, 5, 8, 4 };
		int[] nums5 = { 1, 2, 3, 4, 5, 6, 5, 6, 4, 3, 2, 1, 7 };
		1 3 5 5 3 1 7 a b c b c a d 
		2a+2b+2c+d =
		
		2 4 6 6 4 2
		
		System.out.println("Average: " + findSingle(nums5));
//		mergeSort(nums5);
//		System.out.println("Sorted array: " + Arrays.toString(nums5));
//		System.out.println("Single number: " + findSingleNumber(nums5));
//		 PRIME NUMBER
//		int[] numbers = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };
//		for (int num : numbers) {
//			System.out.println("Is " + num + " a Prime number? " + isPrimeNumber(num));
//		}
		// PALINDROME
//		int[] intArr = { 1, 1, 1, 1 };
//		System.out.println("Is Palindrome: " + isPalindrome(intArr));
		// MIN MAX AVERAGE
//		int[] intArr = { 4, 6, 2, 1, 7, 9, 10, 15, 0 };
//		int min = intArr[0];
//		int max = intArr[0];
//		double average = 0;
//		for (int i = 0; i < intArr.length; i++) {
//			if (intArr[i] > max)
//				max = intArr[i];
//			if (intArr[i] < min)
//				min = intArr[i];
//			average += intArr[i];
//		}
//		System.out.println("Min is: " + min);
//		System.out.println("Max is: " + max);
//		System.out.println("Average is: " + Math.ceil(average * 100.00 / intArr.length) / 100.00);

		// GRADE
//		Scanner scanner = new Scanner(System.in);
//		System.out.println("Please enter your average point of Maths: ");
//		Double mathsPoint = scanner.nextDouble();
//		System.out.println("Your Maths Grade is: " + getGrade(mathsPoint));
//		System.out.println("Please enter your average point of English: ");
//		Double englishPoint = scanner.nextDouble();
//		System.out.println("Your English Grade is: " + getGrade(englishPoint));
//		System.out.println("Please enter your average point of Literature: ");
//		Double literaturePoint = scanner.nextDouble();
//		System.out.println("Your Literature Grade is: " + getGrade(literaturePoint));
//
//		Double averagePoint = Math.ceil((mathsPoint + englishPoint + literaturePoint) * 100.00 / 3) / 100.00;
//		System.out.println("Your Average Point is: " + averagePoint);
//
//		Double minPoint = (mathsPoint > englishPoint) ? englishPoint : mathsPoint;
//		minPoint = (minPoint > literaturePoint) ? literaturePoint : minPoint;
//		char grade;
//		if (minPoint < 5) {
//			grade = 'F';
//		} else if (averagePoint - minPoint > 1) {
//			grade = getGrade(minPoint + 1);
//			System.out.println("Your Grade is: " + grade);
//
//		} else {
//			grade = getGrade(averagePoint);
//			System.out.println("Your Grade is: " + grade);
//		}
//		switch (grade) {
//		case 'S':
//			System.out.println("Excellent Student");
//			break;
//		case 'A':
//			System.out.println("Good Student");
//			break;
//		case 'B':
//			System.out.println("Normal Student");
//			break;
//		case 'C':
//			System.out.println("Average Student");
//			break;
//		case 'D':
//			System.out.println("Not Bad Student");
//			break;
//		case 'F':
//			System.out.println("Fail Student");
//			break;
//		}
//		scanner.close();
	}

	public static char getGrade(double point) {
		if (point >= 9)
			return 'S';
		else if (point >= 8)
			return 'A';
		else if (point >= 7)
			return 'B';
		else if (point >= 6)
			return 'C';
		else if (point >= 5)
			return 'D';
		else
			return 'F';
	}

	public static boolean isPalindrome(int[] numbers) {
		if (numbers.length == 0)
			return false;
		else if (numbers.length == 1)
			return true;
		else {
			for (int i = 0; i < numbers.length / 2; i++) {
				if (numbers[i] != numbers[numbers.length - 1 - i])
					return false;
			}
			return true;
		}
	}

	// upgraded. Chi can chay toi 1 + number/2 la dc roi
	public static boolean isPrimeNumber(int number) {
		if (number <= 0)
			return false;
		else if (number <= 2)
			return true;
		else {
			for (int i = 2; i < 1 + number / 2; i++) {
				if (number % i == 0)
					return false;
			}
			return true;
		}
	}

	public static void mergeSort(int[] nums) {
		// chia doi nums thanh nums1 va nums2
		int endIndex = nums.length - 1;
		int middleIndex = nums.length / 2;
		int firstHalfArrSize = middleIndex;
		int secondHalArrSize = endIndex - middleIndex + 1;
		int[] firstHalfArr = new int[firstHalfArrSize];
		int[] secondHalfArr = new int[secondHalArrSize];
		// copy qua 2 sub array
		for (int i = 0; i < firstHalfArrSize; i++) {
			firstHalfArr[i] = nums[i];
		}
		for (int i = 0; i < secondHalArrSize; i++) {
			secondHalfArr[i] = nums[i + firstHalfArrSize];
		}
		// tiep tuc goi recursive cho toi khi nums.length = 1 moi bat dau swap
		// vay tu nums.length de chia xuong con 1 thi se co' log2(nums.length) lan chia
		// lan chia dau tien ton 1 effort
		// lan chia thu 2 ton 2 effort
		// lan chia thu 3 ton 4 effort
		// lan chia thu log2(nums.length) ton 2^(log2(nums.length) - 1) effort
		// vay tong cong ton 2^0 + 2^1 + 2^2 +..+ 2^(log2(nums.length)-1) effort de goi
		// recursive
		if (firstHalfArrSize > 1)
			mergeSort(firstHalfArr);
		if (secondHalArrSize > 1)
			mergeSort(secondHalfArr);
		// merge 2 sorted subarray
		int firstArrCurrentIndex = 0;
		int secondArrCurrentIndex = 0;
		int currentNumsArrIndex = 0;
		// loop qua 2 sub array de compare va copy qua nums cho toi khi finish 1 trong 2
		// cai array
		// moi recursive se loop qua firstHalf va secondHalf, tuc la nums.length effort
		// co log2(nums.length) level, vay tong cong ton log2(nums.length) * nums.length
		// effort
		while ((firstArrCurrentIndex < firstHalfArrSize) && (secondArrCurrentIndex < secondHalArrSize)) {
			if (firstHalfArr[firstArrCurrentIndex] <= secondHalfArr[secondArrCurrentIndex]) {
				nums[currentNumsArrIndex++] = firstHalfArr[firstArrCurrentIndex++];
			} else {
				nums[currentNumsArrIndex++] = secondHalfArr[secondArrCurrentIndex++];
			}
		}
		// copy phan con lai cua 1 trong 2 cai array qua nums
		if (firstArrCurrentIndex < firstHalfArrSize) {
			nums[currentNumsArrIndex++] = firstHalfArr[firstArrCurrentIndex++];
		} else if (secondArrCurrentIndex < secondHalArrSize) {
			nums[currentNumsArrIndex++] = secondHalfArr[secondArrCurrentIndex++];
		}
		// vay tong cong se ton 2^0 + 2^1 + ... + 2^(log2(nums.length)-1) +
		// log2(nums.length) * nums.length effort
	}

	public static int findSingleNumber(int[] nums) {
		// vi array da sort nen worst cua findSingleNumber la 1 + nums.length / 2
		// vay tong cong effot de tim so single la 2^0 + 2^1 + ... +
		// 2^(log2(nums.length)-1) + log2(nums.length) * nums.length + 1 + nums.length /
		// 2
		int singleNumber = nums[0];
		if (nums.length == 1)
			return singleNumber;
		for (int i = 1; i < nums.length; i++) {
			if (singleNumber == nums[i])
				singleNumber = nums[++i];
			else
				return singleNumber;
		}
		return singleNumber;
	}

	public static int singleNumber(int[] nums) {
		int singleNumber = nums[0];
		int count = 0;
		for (int i = 0; i < nums.length; i++) {
			if (nums[i] == nums.length)
				continue;
			boolean pairFound = false;
			for (int j = i + 1; j < nums.length; j++) {
				System.out.println(Arrays.toString(nums));
				count++;
				if (nums[i] == nums[j]) {
					pairFound = true;
					nums[j] = nums.length;
					break;
				}
			}
			if (!pairFound) {
				singleNumber = nums[i];
				break;
			}
		}
		System.out.println("N: " + nums.length + " - loop: " + count);
		return singleNumber;
	}

	public static int findSingle(int[] nums) {
		int[] firstHalf = new int[1 + nums.length / 2];
		int[] secondHalf = new int[1 + nums.length / 2];
		int firstHalfIndex = 0;
		int secondHalfIndex = 0;
		for (int num : nums) {
			if (num % 2 == 0) 
				firstHalf[firstHalfIndex++] = num;
			else
				secondHalf[secondHalfIndex++] = num;
		}
		if(firstHalfIndex > secondHalfIndex) {
			
		}else {
			
		}
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2022-10-10 02:58:31.086
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2022-10-10 02:58:31.087
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-10 02:58:31.093
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.Scanner;

public class MainDay3 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

		// SINGLE NUMBER
		int[] nums1 = { 2, 2, 1 };
		int[] nums2 = { 4, 1, 2, 1, 2 };
		int[] nums3 = { 1 };
		int[] nums4 = { 6, 3, 1, 7, 2, 5, 8, 4 };
		int[] nums5 = { 1, 2, 3, 4, 5, 6, 5, 6, 4, 3, 2, 1, 7 };
		1 3 5 5 3 1 7 a b c b c a d 
		2a+2b+2c+d =
		
		2 4 6 6 4 2
		
		System.out.println("Average: " + findSingle(nums5));
//		mergeSort(nums5);
//		System.out.println("Sorted array: " + Arrays.toString(nums5));
//		System.out.println("Single number: " + findSingleNumber(nums5));
//		 PRIME NUMBER
//		int[] numbers = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };
//		for (int num : numbers) {
//			System.out.println("Is " + num + " a Prime number? " + isPrimeNumber(num));
//		}
		// PALINDROME
//		int[] intArr = { 1, 1, 1, 1 };
//		System.out.println("Is Palindrome: " + isPalindrome(intArr));
		// MIN MAX AVERAGE
//		int[] intArr = { 4, 6, 2, 1, 7, 9, 10, 15, 0 };
//		int min = intArr[0];
//		int max = intArr[0];
//		double average = 0;
//		for (int i = 0; i < intArr.length; i++) {
//			if (intArr[i] > max)
//				max = intArr[i];
//			if (intArr[i] < min)
//				min = intArr[i];
//			average += intArr[i];
//		}
//		System.out.println("Min is: " + min);
//		System.out.println("Max is: " + max);
//		System.out.println("Average is: " + Math.ceil(average * 100.00 / intArr.length) / 100.00);

		// GRADE
//		Scanner scanner = new Scanner(System.in);
//		System.out.println("Please enter your average point of Maths: ");
//		Double mathsPoint = scanner.nextDouble();
//		System.out.println("Your Maths Grade is: " + getGrade(mathsPoint));
//		System.out.println("Please enter your average point of English: ");
//		Double englishPoint = scanner.nextDouble();
//		System.out.println("Your English Grade is: " + getGrade(englishPoint));
//		System.out.println("Please enter your average point of Literature: ");
//		Double literaturePoint = scanner.nextDouble();
//		System.out.println("Your Literature Grade is: " + getGrade(literaturePoint));
//
//		Double averagePoint = Math.ceil((mathsPoint + englishPoint + literaturePoint) * 100.00 / 3) / 100.00;
//		System.out.println("Your Average Point is: " + averagePoint);
//
//		Double minPoint = (mathsPoint > englishPoint) ? englishPoint : mathsPoint;
//		minPoint = (minPoint > literaturePoint) ? literaturePoint : minPoint;
//		char grade;
//		if (minPoint < 5) {
//			grade = 'F';
//		} else if (averagePoint - minPoint > 1) {
//			grade = getGrade(minPoint + 1);
//			System.out.println("Your Grade is: " + grade);
//
//		} else {
//			grade = getGrade(averagePoint);
//			System.out.println("Your Grade is: " + grade);
//		}
//		switch (grade) {
//		case 'S':
//			System.out.println("Excellent Student");
//			break;
//		case 'A':
//			System.out.println("Good Student");
//			break;
//		case 'B':
//			System.out.println("Normal Student");
//			break;
//		case 'C':
//			System.out.println("Average Student");
//			break;
//		case 'D':
//			System.out.println("Not Bad Student");
//			break;
//		case 'F':
//			System.out.println("Fail Student");
//			break;
//		}
//		scanner.close();
	}

	public static char getGrade(double point) {
		if (point >= 9)
			return 'S';
		else if (point >= 8)
			return 'A';
		else if (point >= 7)
			return 'B';
		else if (point >= 6)
			return 'C';
		else if (point >= 5)
			return 'D';
		else
			return 'F';
	}

	public static boolean isPalindrome(int[] numbers) {
		if (numbers.length == 0)
			return false;
		else if (numbers.length == 1)
			return true;
		else {
			for (int i = 0; i < numbers.length / 2; i++) {
				if (numbers[i] != numbers[numbers.length - 1 - i])
					return false;
			}
			return true;
		}
	}

	// upgraded. Chi can chay toi 1 + number/2 la dc roi
	public static boolean isPrimeNumber(int number) {
		if (number <= 0)
			return false;
		else if (number <= 2)
			return true;
		else {
			for (int i = 2; i < 1 + number / 2; i++) {
				if (number % i == 0)
					return false;
			}
			return true;
		}
	}

	public static void mergeSort(int[] nums) {
		// chia doi nums thanh nums1 va nums2
		int endIndex = nums.length - 1;
		int middleIndex = nums.length / 2;
		int firstHalfArrSize = middleIndex;
		int secondHalArrSize = endIndex - middleIndex + 1;
		int[] firstHalfArr = new int[firstHalfArrSize];
		int[] secondHalfArr = new int[secondHalArrSize];
		// copy qua 2 sub array
		for (int i = 0; i < firstHalfArrSize; i++) {
			firstHalfArr[i] = nums[i];
		}
		for (int i = 0; i < secondHalArrSize; i++) {
			secondHalfArr[i] = nums[i + firstHalfArrSize];
		}
		// tiep tuc goi recursive cho toi khi nums.length = 1 moi bat dau swap
		// vay tu nums.length de chia xuong con 1 thi se co' log2(nums.length) lan chia
		// lan chia dau tien ton 1 effort
		// lan chia thu 2 ton 2 effort
		// lan chia thu 3 ton 4 effort
		// lan chia thu log2(nums.length) ton 2^(log2(nums.length) - 1) effort
		// vay tong cong ton 2^0 + 2^1 + 2^2 +..+ 2^(log2(nums.length)-1) effort de goi
		// recursive
		if (firstHalfArrSize > 1)
			mergeSort(firstHalfArr);
		if (secondHalArrSize > 1)
			mergeSort(secondHalfArr);
		// merge 2 sorted subarray
		int firstArrCurrentIndex = 0;
		int secondArrCurrentIndex = 0;
		int currentNumsArrIndex = 0;
		// loop qua 2 sub array de compare va copy qua nums cho toi khi finish 1 trong 2
		// cai array
		// moi recursive se loop qua firstHalf va secondHalf, tuc la nums.length effort
		// co log2(nums.length) level, vay tong cong ton log2(nums.length) * nums.length
		// effort
		while ((firstArrCurrentIndex < firstHalfArrSize) && (secondArrCurrentIndex < secondHalArrSize)) {
			if (firstHalfArr[firstArrCurrentIndex] <= secondHalfArr[secondArrCurrentIndex]) {
				nums[currentNumsArrIndex++] = firstHalfArr[firstArrCurrentIndex++];
			} else {
				nums[currentNumsArrIndex++] = secondHalfArr[secondArrCurrentIndex++];
			}
		}
		// copy phan con lai cua 1 trong 2 cai array qua nums
		if (firstArrCurrentIndex < firstHalfArrSize) {
			nums[currentNumsArrIndex++] = firstHalfArr[firstArrCurrentIndex++];
		} else if (secondArrCurrentIndex < secondHalArrSize) {
			nums[currentNumsArrIndex++] = secondHalfArr[secondArrCurrentIndex++];
		}
		// vay tong cong se ton 2^0 + 2^1 + ... + 2^(log2(nums.length)-1) +
		// log2(nums.length) * nums.length effort
	}

	public static int findSingleNumber(int[] nums) {
		// vi array da sort nen worst cua findSingleNumber la 1 + nums.length / 2
		// vay tong cong effot de tim so single la 2^0 + 2^1 + ... +
		// 2^(log2(nums.length)-1) + log2(nums.length) * nums.length + 1 + nums.length /
		// 2
		int singleNumber = nums[0];
		if (nums.length == 1)
			return singleNumber;
		for (int i = 1; i < nums.length; i++) {
			if (singleNumber == nums[i])
				singleNumber = nums[++i];
			else
				return singleNumber;
		}
		return singleNumber;
	}

	public static int singleNumber(int[] nums) {
		int singleNumber = nums[0];
		int count = 0;
		for (int i = 0; i < nums.length; i++) {
			if (nums[i] == nums.length)
				continue;
			boolean pairFound = false;
			for (int j = i + 1; j < nums.length; j++) {
				System.out.println(Arrays.toString(nums));
				count++;
				if (nums[i] == nums[j]) {
					pairFound = true;
					nums[j] = nums.length;
					break;
				}
			}
			if (!pairFound) {
				singleNumber = nums[i];
				break;
			}
		}
		System.out.println("N: " + nums.length + " - loop: " + count);
		return singleNumber;
	}

	public static int findSingle(int[] nums) {
		int[] firstHalf = new int[1 + nums.length / 2];
		int[] secondHalf = new int[1 + nums.length / 2];
		int firstHalfIndex = 0;
		int secondHalfIndex = 0;
		for (int num : nums) {
			if (num % 2 == 0) 
				firstHalf[firstHalfIndex++] = num;
			else
				secondHalf[secondHalfIndex++] = num;
		}
		if(firstHalfIndex > secondHalfIndex) {
			
		}else {
			
		}
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-10-10 02:58:31.094
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-10-10 02:58:31.094
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-10 02:58:31.774
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.Scanner;

public class MainDay3 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

		// SINGLE NUMBER
		int[] nums1 = { 2, 2, 1 };
		int[] nums2 = { 4, 1, 2, 1, 2 };
		int[] nums3 = { 1 };
		int[] nums4 = { 6, 3, 1, 7, 2, 5, 8, 4 };
		int[] nums5 = { 1, 2, 3, 4, 5, 6, 5, 6, 4, 3, 2, 1, 7 };
		1 3 5 5 3 1 7 a b c b c a d 
		2a+2b+2c+d 
		2 4 6 6 4 2
		
		System.out.println("Average: " + findSingle(nums5));
//		mergeSort(nums5);
//		System.out.println("Sorted array: " + Arrays.toString(nums5));
//		System.out.println("Single number: " + findSingleNumber(nums5));
//		 PRIME NUMBER
//		int[] numbers = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };
//		for (int num : numbers) {
//			System.out.println("Is " + num + " a Prime number? " + isPrimeNumber(num));
//		}
		// PALINDROME
//		int[] intArr = { 1, 1, 1, 1 };
//		System.out.println("Is Palindrome: " + isPalindrome(intArr));
		// MIN MAX AVERAGE
//		int[] intArr = { 4, 6, 2, 1, 7, 9, 10, 15, 0 };
//		int min = intArr[0];
//		int max = intArr[0];
//		double average = 0;
//		for (int i = 0; i < intArr.length; i++) {
//			if (intArr[i] > max)
//				max = intArr[i];
//			if (intArr[i] < min)
//				min = intArr[i];
//			average += intArr[i];
//		}
//		System.out.println("Min is: " + min);
//		System.out.println("Max is: " + max);
//		System.out.println("Average is: " + Math.ceil(average * 100.00 / intArr.length) / 100.00);

		// GRADE
//		Scanner scanner = new Scanner(System.in);
//		System.out.println("Please enter your average point of Maths: ");
//		Double mathsPoint = scanner.nextDouble();
//		System.out.println("Your Maths Grade is: " + getGrade(mathsPoint));
//		System.out.println("Please enter your average point of English: ");
//		Double englishPoint = scanner.nextDouble();
//		System.out.println("Your English Grade is: " + getGrade(englishPoint));
//		System.out.println("Please enter your average point of Literature: ");
//		Double literaturePoint = scanner.nextDouble();
//		System.out.println("Your Literature Grade is: " + getGrade(literaturePoint));
//
//		Double averagePoint = Math.ceil((mathsPoint + englishPoint + literaturePoint) * 100.00 / 3) / 100.00;
//		System.out.println("Your Average Point is: " + averagePoint);
//
//		Double minPoint = (mathsPoint > englishPoint) ? englishPoint : mathsPoint;
//		minPoint = (minPoint > literaturePoint) ? literaturePoint : minPoint;
//		char grade;
//		if (minPoint < 5) {
//			grade = 'F';
//		} else if (averagePoint - minPoint > 1) {
//			grade = getGrade(minPoint + 1);
//			System.out.println("Your Grade is: " + grade);
//
//		} else {
//			grade = getGrade(averagePoint);
//			System.out.println("Your Grade is: " + grade);
//		}
//		switch (grade) {
//		case 'S':
//			System.out.println("Excellent Student");
//			break;
//		case 'A':
//			System.out.println("Good Student");
//			break;
//		case 'B':
//			System.out.println("Normal Student");
//			break;
//		case 'C':
//			System.out.println("Average Student");
//			break;
//		case 'D':
//			System.out.println("Not Bad Student");
//			break;
//		case 'F':
//			System.out.println("Fail Student");
//			break;
//		}
//		scanner.close();
	}

	public static char getGrade(double point) {
		if (point >= 9)
			return 'S';
		else if (point >= 8)
			return 'A';
		else if (point >= 7)
			return 'B';
		else if (point >= 6)
			return 'C';
		else if (point >= 5)
			return 'D';
		else
			return 'F';
	}

	public static boolean isPalindrome(int[] numbers) {
		if (numbers.length == 0)
			return false;
		else if (numbers.length == 1)
			return true;
		else {
			for (int i = 0; i < numbers.length / 2; i++) {
				if (numbers[i] != numbers[numbers.length - 1 - i])
					return false;
			}
			return true;
		}
	}

	// upgraded. Chi can chay toi 1 + number/2 la dc roi
	public static boolean isPrimeNumber(int number) {
		if (number <= 0)
			return false;
		else if (number <= 2)
			return true;
		else {
			for (int i = 2; i < 1 + number / 2; i++) {
				if (number % i == 0)
					return false;
			}
			return true;
		}
	}

	public static void mergeSort(int[] nums) {
		// chia doi nums thanh nums1 va nums2
		int endIndex = nums.length - 1;
		int middleIndex = nums.length / 2;
		int firstHalfArrSize = middleIndex;
		int secondHalArrSize = endIndex - middleIndex + 1;
		int[] firstHalfArr = new int[firstHalfArrSize];
		int[] secondHalfArr = new int[secondHalArrSize];
		// copy qua 2 sub array
		for (int i = 0; i < firstHalfArrSize; i++) {
			firstHalfArr[i] = nums[i];
		}
		for (int i = 0; i < secondHalArrSize; i++) {
			secondHalfArr[i] = nums[i + firstHalfArrSize];
		}
		// tiep tuc goi recursive cho toi khi nums.length = 1 moi bat dau swap
		// vay tu nums.length de chia xuong con 1 thi se co' log2(nums.length) lan chia
		// lan chia dau tien ton 1 effort
		// lan chia thu 2 ton 2 effort
		// lan chia thu 3 ton 4 effort
		// lan chia thu log2(nums.length) ton 2^(log2(nums.length) - 1) effort
		// vay tong cong ton 2^0 + 2^1 + 2^2 +..+ 2^(log2(nums.length)-1) effort de goi
		// recursive
		if (firstHalfArrSize > 1)
			mergeSort(firstHalfArr);
		if (secondHalArrSize > 1)
			mergeSort(secondHalfArr);
		// merge 2 sorted subarray
		int firstArrCurrentIndex = 0;
		int secondArrCurrentIndex = 0;
		int currentNumsArrIndex = 0;
		// loop qua 2 sub array de compare va copy qua nums cho toi khi finish 1 trong 2
		// cai array
		// moi recursive se loop qua firstHalf va secondHalf, tuc la nums.length effort
		// co log2(nums.length) level, vay tong cong ton log2(nums.length) * nums.length
		// effort
		while ((firstArrCurrentIndex < firstHalfArrSize) && (secondArrCurrentIndex < secondHalArrSize)) {
			if (firstHalfArr[firstArrCurrentIndex] <= secondHalfArr[secondArrCurrentIndex]) {
				nums[currentNumsArrIndex++] = firstHalfArr[firstArrCurrentIndex++];
			} else {
				nums[currentNumsArrIndex++] = secondHalfArr[secondArrCurrentIndex++];
			}
		}
		// copy phan con lai cua 1 trong 2 cai array qua nums
		if (firstArrCurrentIndex < firstHalfArrSize) {
			nums[currentNumsArrIndex++] = firstHalfArr[firstArrCurrentIndex++];
		} else if (secondArrCurrentIndex < secondHalArrSize) {
			nums[currentNumsArrIndex++] = secondHalfArr[secondArrCurrentIndex++];
		}
		// vay tong cong se ton 2^0 + 2^1 + ... + 2^(log2(nums.length)-1) +
		// log2(nums.length) * nums.length effort
	}

	public static int findSingleNumber(int[] nums) {
		// vi array da sort nen worst cua findSingleNumber la 1 + nums.length / 2
		// vay tong cong effot de tim so single la 2^0 + 2^1 + ... +
		// 2^(log2(nums.length)-1) + log2(nums.length) * nums.length + 1 + nums.length /
		// 2
		int singleNumber = nums[0];
		if (nums.length == 1)
			return singleNumber;
		for (int i = 1; i < nums.length; i++) {
			if (singleNumber == nums[i])
				singleNumber = nums[++i];
			else
				return singleNumber;
		}
		return singleNumber;
	}

	public static int singleNumber(int[] nums) {
		int singleNumber = nums[0];
		int count = 0;
		for (int i = 0; i < nums.length; i++) {
			if (nums[i] == nums.length)
				continue;
			boolean pairFound = false;
			for (int j = i + 1; j < nums.length; j++) {
				System.out.println(Arrays.toString(nums));
				count++;
				if (nums[i] == nums[j]) {
					pairFound = true;
					nums[j] = nums.length;
					break;
				}
			}
			if (!pairFound) {
				singleNumber = nums[i];
				break;
			}
		}
		System.out.println("N: " + nums.length + " - loop: " + count);
		return singleNumber;
	}

	public static int findSingle(int[] nums) {
		int[] firstHalf = new int[1 + nums.length / 2];
		int[] secondHalf = new int[1 + nums.length / 2];
		int firstHalfIndex = 0;
		int secondHalfIndex = 0;
		for (int num : nums) {
			if (num % 2 == 0) 
				firstHalf[firstHalfIndex++] = num;
			else
				secondHalf[secondHalfIndex++] = num;
		}
		if(firstHalfIndex > secondHalfIndex) {
			
		}else {
			
		}
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2022-10-10 02:58:31.775
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2022-10-10 02:58:31.775
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-10 02:58:31.783
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.Scanner;

public class MainDay3 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

		// SINGLE NUMBER
		int[] nums1 = { 2, 2, 1 };
		int[] nums2 = { 4, 1, 2, 1, 2 };
		int[] nums3 = { 1 };
		int[] nums4 = { 6, 3, 1, 7, 2, 5, 8, 4 };
		int[] nums5 = { 1, 2, 3, 4, 5, 6, 5, 6, 4, 3, 2, 1, 7 };
		1 3 5 5 3 1 7 a b c b c a d 
		2a+2b+2c+d 
		2 4 6 6 4 2
		
		System.out.println("Average: " + findSingle(nums5));
//		mergeSort(nums5);
//		System.out.println("Sorted array: " + Arrays.toString(nums5));
//		System.out.println("Single number: " + findSingleNumber(nums5));
//		 PRIME NUMBER
//		int[] numbers = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };
//		for (int num : numbers) {
//			System.out.println("Is " + num + " a Prime number? " + isPrimeNumber(num));
//		}
		// PALINDROME
//		int[] intArr = { 1, 1, 1, 1 };
//		System.out.println("Is Palindrome: " + isPalindrome(intArr));
		// MIN MAX AVERAGE
//		int[] intArr = { 4, 6, 2, 1, 7, 9, 10, 15, 0 };
//		int min = intArr[0];
//		int max = intArr[0];
//		double average = 0;
//		for (int i = 0; i < intArr.length; i++) {
//			if (intArr[i] > max)
//				max = intArr[i];
//			if (intArr[i] < min)
//				min = intArr[i];
//			average += intArr[i];
//		}
//		System.out.println("Min is: " + min);
//		System.out.println("Max is: " + max);
//		System.out.println("Average is: " + Math.ceil(average * 100.00 / intArr.length) / 100.00);

		// GRADE
//		Scanner scanner = new Scanner(System.in);
//		System.out.println("Please enter your average point of Maths: ");
//		Double mathsPoint = scanner.nextDouble();
//		System.out.println("Your Maths Grade is: " + getGrade(mathsPoint));
//		System.out.println("Please enter your average point of English: ");
//		Double englishPoint = scanner.nextDouble();
//		System.out.println("Your English Grade is: " + getGrade(englishPoint));
//		System.out.println("Please enter your average point of Literature: ");
//		Double literaturePoint = scanner.nextDouble();
//		System.out.println("Your Literature Grade is: " + getGrade(literaturePoint));
//
//		Double averagePoint = Math.ceil((mathsPoint + englishPoint + literaturePoint) * 100.00 / 3) / 100.00;
//		System.out.println("Your Average Point is: " + averagePoint);
//
//		Double minPoint = (mathsPoint > englishPoint) ? englishPoint : mathsPoint;
//		minPoint = (minPoint > literaturePoint) ? literaturePoint : minPoint;
//		char grade;
//		if (minPoint < 5) {
//			grade = 'F';
//		} else if (averagePoint - minPoint > 1) {
//			grade = getGrade(minPoint + 1);
//			System.out.println("Your Grade is: " + grade);
//
//		} else {
//			grade = getGrade(averagePoint);
//			System.out.println("Your Grade is: " + grade);
//		}
//		switch (grade) {
//		case 'S':
//			System.out.println("Excellent Student");
//			break;
//		case 'A':
//			System.out.println("Good Student");
//			break;
//		case 'B':
//			System.out.println("Normal Student");
//			break;
//		case 'C':
//			System.out.println("Average Student");
//			break;
//		case 'D':
//			System.out.println("Not Bad Student");
//			break;
//		case 'F':
//			System.out.println("Fail Student");
//			break;
//		}
//		scanner.close();
	}

	public static char getGrade(double point) {
		if (point >= 9)
			return 'S';
		else if (point >= 8)
			return 'A';
		else if (point >= 7)
			return 'B';
		else if (point >= 6)
			return 'C';
		else if (point >= 5)
			return 'D';
		else
			return 'F';
	}

	public static boolean isPalindrome(int[] numbers) {
		if (numbers.length == 0)
			return false;
		else if (numbers.length == 1)
			return true;
		else {
			for (int i = 0; i < numbers.length / 2; i++) {
				if (numbers[i] != numbers[numbers.length - 1 - i])
					return false;
			}
			return true;
		}
	}

	// upgraded. Chi can chay toi 1 + number/2 la dc roi
	public static boolean isPrimeNumber(int number) {
		if (number <= 0)
			return false;
		else if (number <= 2)
			return true;
		else {
			for (int i = 2; i < 1 + number / 2; i++) {
				if (number % i == 0)
					return false;
			}
			return true;
		}
	}

	public static void mergeSort(int[] nums) {
		// chia doi nums thanh nums1 va nums2
		int endIndex = nums.length - 1;
		int middleIndex = nums.length / 2;
		int firstHalfArrSize = middleIndex;
		int secondHalArrSize = endIndex - middleIndex + 1;
		int[] firstHalfArr = new int[firstHalfArrSize];
		int[] secondHalfArr = new int[secondHalArrSize];
		// copy qua 2 sub array
		for (int i = 0; i < firstHalfArrSize; i++) {
			firstHalfArr[i] = nums[i];
		}
		for (int i = 0; i < secondHalArrSize; i++) {
			secondHalfArr[i] = nums[i + firstHalfArrSize];
		}
		// tiep tuc goi recursive cho toi khi nums.length = 1 moi bat dau swap
		// vay tu nums.length de chia xuong con 1 thi se co' log2(nums.length) lan chia
		// lan chia dau tien ton 1 effort
		// lan chia thu 2 ton 2 effort
		// lan chia thu 3 ton 4 effort
		// lan chia thu log2(nums.length) ton 2^(log2(nums.length) - 1) effort
		// vay tong cong ton 2^0 + 2^1 + 2^2 +..+ 2^(log2(nums.length)-1) effort de goi
		// recursive
		if (firstHalfArrSize > 1)
			mergeSort(firstHalfArr);
		if (secondHalArrSize > 1)
			mergeSort(secondHalfArr);
		// merge 2 sorted subarray
		int firstArrCurrentIndex = 0;
		int secondArrCurrentIndex = 0;
		int currentNumsArrIndex = 0;
		// loop qua 2 sub array de compare va copy qua nums cho toi khi finish 1 trong 2
		// cai array
		// moi recursive se loop qua firstHalf va secondHalf, tuc la nums.length effort
		// co log2(nums.length) level, vay tong cong ton log2(nums.length) * nums.length
		// effort
		while ((firstArrCurrentIndex < firstHalfArrSize) && (secondArrCurrentIndex < secondHalArrSize)) {
			if (firstHalfArr[firstArrCurrentIndex] <= secondHalfArr[secondArrCurrentIndex]) {
				nums[currentNumsArrIndex++] = firstHalfArr[firstArrCurrentIndex++];
			} else {
				nums[currentNumsArrIndex++] = secondHalfArr[secondArrCurrentIndex++];
			}
		}
		// copy phan con lai cua 1 trong 2 cai array qua nums
		if (firstArrCurrentIndex < firstHalfArrSize) {
			nums[currentNumsArrIndex++] = firstHalfArr[firstArrCurrentIndex++];
		} else if (secondArrCurrentIndex < secondHalArrSize) {
			nums[currentNumsArrIndex++] = secondHalfArr[secondArrCurrentIndex++];
		}
		// vay tong cong se ton 2^0 + 2^1 + ... + 2^(log2(nums.length)-1) +
		// log2(nums.length) * nums.length effort
	}

	public static int findSingleNumber(int[] nums) {
		// vi array da sort nen worst cua findSingleNumber la 1 + nums.length / 2
		// vay tong cong effot de tim so single la 2^0 + 2^1 + ... +
		// 2^(log2(nums.length)-1) + log2(nums.length) * nums.length + 1 + nums.length /
		// 2
		int singleNumber = nums[0];
		if (nums.length == 1)
			return singleNumber;
		for (int i = 1; i < nums.length; i++) {
			if (singleNumber == nums[i])
				singleNumber = nums[++i];
			else
				return singleNumber;
		}
		return singleNumber;
	}

	public static int singleNumber(int[] nums) {
		int singleNumber = nums[0];
		int count = 0;
		for (int i = 0; i < nums.length; i++) {
			if (nums[i] == nums.length)
				continue;
			boolean pairFound = false;
			for (int j = i + 1; j < nums.length; j++) {
				System.out.println(Arrays.toString(nums));
				count++;
				if (nums[i] == nums[j]) {
					pairFound = true;
					nums[j] = nums.length;
					break;
				}
			}
			if (!pairFound) {
				singleNumber = nums[i];
				break;
			}
		}
		System.out.println("N: " + nums.length + " - loop: " + count);
		return singleNumber;
	}

	public static int findSingle(int[] nums) {
		int[] firstHalf = new int[1 + nums.length / 2];
		int[] secondHalf = new int[1 + nums.length / 2];
		int firstHalfIndex = 0;
		int secondHalfIndex = 0;
		for (int num : nums) {
			if (num % 2 == 0) 
				firstHalf[firstHalfIndex++] = num;
			else
				secondHalf[secondHalfIndex++] = num;
		}
		if(firstHalfIndex > secondHalfIndex) {
			
		}else {
			
		}
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-10-10 02:58:31.784
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-10-10 02:58:31.785
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2022-10-10 10:19:21.107 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_AU
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2022-10-10 10:20:01.595
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-10-10 10:20:01.595
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-10-10 10:20:01.595
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-10-10 10:20:06.436
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\ffpbp'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-10-11 19:35:18.858 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_AU
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2022-10-11 19:35:50.618
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-10-11 19:35:50.618
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-10-11 19:35:50.618
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-10-11 19:35:57.459
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\ffpbp'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-10-12 22:46:26.097 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_AU
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2022-10-12 22:47:18.952
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-10-12 22:47:18.952
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-10-12 22:47:18.953
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-10-12 22:47:23.836
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\ffpbp'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-10-13 21:59:29.646 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_AU
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.core.resources 2 10035 2022-10-13 21:59:37.638
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY org.eclipse.jface 2 0 2022-10-13 22:00:10.690
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-10-13 22:00:10.690
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-10-13 22:00:10.690
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-10-13 22:00:17.997
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\ffpbp'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.ui 4 10001 2022-10-14 21:41:41.822
!MESSAGE Internal Error
!STACK 1
Java Model Exception: Error in Java Model (code 969): Payment(Constant.PaymentType, String) [in Payment [in [Working copy] Payment.java [in <default> [in src [in CMK3D1]]]]] does not exist
	at org.eclipse.jdt.internal.core.JavaElement.newNotPresentException(JavaElement.java:574)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:617)
	at org.eclipse.jdt.internal.core.JavaElement.getElementInfo(JavaElement.java:328)
	at org.eclipse.jdt.internal.core.JavaElement.getElementInfo(JavaElement.java:314)
	at org.eclipse.jdt.internal.core.Member.getFlags(Member.java:172)
	at org.eclipse.jdt.internal.corext.util.JdtFlags.isPrivate(JdtFlags.java:157)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaElementHyperlinkSuperImplementationDetector.isOverriddenMethod(JavaElementHyperlinkSuperImplementationDetector.java:57)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaElementHyperlinkSuperImplementationDetector.addHyperlinks(JavaElementHyperlinkSuperImplementationDetector.java:44)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaElementHyperlinkDetector.detectHyperlinks(JavaElementHyperlinkDetector.java:136)
	at org.eclipse.ui.texteditor.HyperlinkDetectorRegistry$HyperlinkDetectorDelegate.detectHyperlinks(HyperlinkDetectorRegistry.java:81)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.findHyperlinks(HyperlinkManager.java:289)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.findHyperlinks(HyperlinkManager.java:262)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.mouseMove(HyperlinkManager.java:457)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:216)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4068)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3645)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 1 org.eclipse.jdt.core 4 969 2022-10-14 21:41:41.824
!MESSAGE Payment(Constant.PaymentType, String) [in Payment [in [Working copy] Payment.java [in <default> [in src [in CMK3D1]]]]] does not exist

!ENTRY org.eclipse.jdt.ui 4 10001 2022-10-14 21:41:41.825
!MESSAGE Internal Error
!STACK 1
Java Model Exception: Error in Java Model (code 969): Payment(Constant.PaymentType, String) [in Payment [in [Working copy] Payment.java [in <default> [in src [in CMK3D1]]]]] does not exist
	at org.eclipse.jdt.internal.core.JavaElement.newNotPresentException(JavaElement.java:574)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:617)
	at org.eclipse.jdt.internal.core.JavaElement.getElementInfo(JavaElement.java:328)
	at org.eclipse.jdt.internal.core.JavaElement.getElementInfo(JavaElement.java:314)
	at org.eclipse.jdt.internal.core.SourceMethod.getReturnType(SourceMethod.java:204)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaElementHyperlinkReturnTypeDetector.addHyperlinks(JavaElementHyperlinkReturnTypeDetector.java:43)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaElementHyperlinkDetector.detectHyperlinks(JavaElementHyperlinkDetector.java:136)
	at org.eclipse.ui.texteditor.HyperlinkDetectorRegistry$HyperlinkDetectorDelegate.detectHyperlinks(HyperlinkDetectorRegistry.java:81)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.findHyperlinks(HyperlinkManager.java:289)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.findHyperlinks(HyperlinkManager.java:262)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.mouseMove(HyperlinkManager.java:457)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:216)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4068)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3645)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 1 org.eclipse.jdt.core 4 969 2022-10-14 21:41:41.825
!MESSAGE Payment(Constant.PaymentType, String) [in Payment [in [Working copy] Payment.java [in <default> [in src [in CMK3D1]]]]] does not exist
!SESSION 2022-10-15 00:28:46.172 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_AU
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2022-10-15 00:29:07.007
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-10-15 00:29:07.007
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-10-15 00:29:07.007
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-10-15 00:29:11.557
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\ffpbp'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-10-15 18:34:35.551 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_AU
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2022-10-15 18:35:34.714
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-10-15 18:35:34.714
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-10-15 18:35:34.714
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-10-15 18:35:42.119
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\ffpbp'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-10-16 15:57:25.997 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_AU
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2022-10-16 15:58:04.163
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-10-16 15:58:04.163
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-10-16 15:58:04.163
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-10-16 15:58:08.933
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\ffpbp'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-10-17 16:39:30.869 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_AU
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2022-10-17 16:40:06.143
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-10-17 16:40:06.143
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-10-17 16:40:06.143
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-10-17 16:40:11.802
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\ffpbp'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-10-18 19:29:41.490 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_AU
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2022-10-18 19:30:17.956
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-10-18 19:30:17.956
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-10-18 19:30:17.956
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-10-18 19:30:24.300
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\ffpbp'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-10-19 23:38:07.684 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_AU
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2022-10-19 23:41:30.115
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-10-19 23:41:30.115
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-10-19 23:41:30.115
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-10-19 23:41:37.241
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\ffpbp'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-10-22 18:37:38.452 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_AU
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2022-10-22 18:38:12.280
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-10-22 18:38:12.280
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-10-22 18:38:12.280
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-10-22 18:38:18.396
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\ffpbp'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-10-23 18:53:51.779 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_AU
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2022-10-23 18:54:24.960
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-10-23 18:54:24.961
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-10-23 18:54:24.961
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-10-23 18:54:31.397
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\ffpbp'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-10-24 15:37:44.553 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_AU
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2022-10-24 15:38:21.222
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-10-24 15:38:21.222
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-10-24 15:38:21.222
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-10-24 15:38:25.927
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\ffpbp'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-10-24 18:21:23.983 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_AU
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2022-10-24 18:21:27.946
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-10-24 18:21:27.946
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-10-24 18:21:27.946
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-10-24 18:21:31.740
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\ffpbp'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-10-24 19:19:24.768 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_AU
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2022-10-24 19:19:30.369
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-10-24 19:19:30.369
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-10-24 19:19:30.369
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-10-24 19:19:34.551
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\ffpbp'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.ui 4 0 2022-10-24 19:23:05.168
!MESSAGE Unhandled event loop exception
!STACK 0
org.eclipse.swt.SWTException: Graphic is disposed
	at org.eclipse.swt.SWT.error(SWT.java:4918)
	at org.eclipse.swt.SWT.error(SWT.java:4833)
	at org.eclipse.swt.SWT.error(SWT.java:4804)
	at org.eclipse.swt.graphics.Image.getImageData(Image.java:1350)
	at org.eclipse.swt.internal.ImageList.set(ImageList.java:372)
	at org.eclipse.swt.internal.ImageList.add(ImageList.java:52)
	at org.eclipse.swt.widgets.Tree.imageIndex(Tree.java:3692)
	at org.eclipse.swt.widgets.Tree.wmNotifyChild(Tree.java:7400)
	at org.eclipse.swt.widgets.Control.wmNotify(Control.java:5799)
	at org.eclipse.swt.widgets.Composite.wmNotify(Composite.java:1961)
	at org.eclipse.swt.widgets.Control.WM_NOTIFY(Control.java:5367)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4801)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5028)
	at org.eclipse.swt.internal.win32.OS.CallWindowProc(Native Method)
	at org.eclipse.swt.widgets.Tree.callWindowProc(Tree.java:1542)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4846)
	at org.eclipse.swt.widgets.Tree.windowProc(Tree.java:6016)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5036)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3643)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
	Suppressed: org.eclipse.swt.SWTException: Graphic is disposed
		at org.eclipse.swt.SWT.error(SWT.java:4918)
		at org.eclipse.swt.SWT.error(SWT.java:4833)
		at org.eclipse.swt.SWT.error(SWT.java:4804)
		at org.eclipse.swt.graphics.Image.getBounds(Image.java:1245)
		at org.eclipse.swt.widgets.Tree.CDDS_ITEMPOSTPAINT(Tree.java:759)
		at org.eclipse.swt.widgets.Tree.wmNotifyChild(Tree.java:7428)
		at org.eclipse.swt.widgets.Control.wmNotify(Control.java:5799)
		at org.eclipse.swt.widgets.Composite.wmNotify(Composite.java:1961)
		at org.eclipse.swt.widgets.Control.WM_NOTIFY(Control.java:5367)
		at org.eclipse.swt.widgets.Control.windowProc(Control.java:4801)
		at org.eclipse.swt.widgets.Display.windowProc(Display.java:5036)
		... 28 more
